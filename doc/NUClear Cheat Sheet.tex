\documentclass[a4paper]{article}
\usepackage[cm]{fullpage}              % Makes the text take up a full page
\usepackage{minted}                    % Used for source code syntax highlighting

% Minted configuration
\usemintedstyle{vs}
\newminted{cpp}{tabsize=0,linenos,bgcolor=white!95!black}

\title{NUClear Cheat Sheet}
\date{\vspace{-5ex}}
\author{\vspace{-5ex}}

\begin{document}


\maketitle

    \paragraph{on} An on statement is used to setup a callback to run with data, it takes arguments and a matching function
    \begin{cppcode}
        on<...>(callbackFunction);
    \end{cppcode}

    \paragraph{Trigger} Trigger statements setup the callbacks, they will execute when the type is emitted.
    There must always be a Trigger in an on statement.\\
    \begin{cppcode}
        on<Trigger<Data>>([](const Data& data) {
            // code
        });
    \end{cppcode}

    \paragraph{With} With statements get the most recent copy of data to use with a callback.\\
    \begin{cppcode}
        on<Trigger<Data>, With<MoreData>>([](const Data& data, const MoreData& more) {
            // Data and the latest copy of MoreData
        });
    \end{cppcode}

    \paragraph{Options} Options statements configure how and when the callback will be executed.\\
    \begin{cppcode}
        on<Trigger<Data>, Options<...>>([](const Data& data) {
            // Options configure when this code runs
        });
    \end{cppcode}

    \paragraph{Single} Single allows only a single execution of the callback at a time.
    If one is running a new trigger will be ignored.
    \begin{cppcode}
        on<Trigger<Data>, Options<Single>>([](const Data& data) {
            // If this code is running, don't start a new one, instead drop it
        });
    \end{cppcode}

    \paragraph{Sync} Sync allows only a single execution of the callback at a time.
    If one is running a new trigger will be queued to execute after.
    Sync objects are grouped by their templated type.\\
    \begin{cppcode}
        on<Trigger<Data>, Options<Sync<LockType>>>([](const Data& data) {
            // If this code is running, don't start a new one, instead queue it
        });
    \end{cppcode}

    \paragraph{Priority} Priority allows picking when the task will run in relation to other tasks.
    High priority tasks will jump the queue and run before low priority tasks.\\
    \begin{cppcode}
        on<Trigger<Data>, Options<Priority<NUClear::HIGH>>>([](const Data& data) {
            // This code will run before code with a lower priority
        });
    \end{cppcode}

    \paragraph{Every} Every is used to make a periodic function.
    It will execute at the period given, or at the frequency given (if using Per).\\
    \begin{cppcode}
        on<Trigger<Every<5, std::chrono::seconds>>>(const time_t& time) {
            // Will run every 5 seconds
        });
        on<Trigger<Every<10, Per<std::chrono::minute>>>>(const time_t& time) {
            // Will run 10 times per minute
        });
    \end{cppcode}

    \paragraph{Raw} Raw will return an unmodifyable (but storable) pointer to the data.\\
    \begin{cppcode}
        on<Trigger<Raw<Data>>>([](const std::shared_ptr<const Data>& dataPtr) {
            // The pointer to dataPtr can now be stored
        });
    \end{cppcode}

    \paragraph{Network} Network will allow Protocol Buffers to be received to other robots.\\
    \begin{cppcode}
        on<Trigger<Network<ProtocolBuffer>>>([](const Network<ProtocolBuffer>& net) {
            // net.data = the sent data
            // net.sender = where the data came from
        }
    \end{cppcode}

    \paragraph{Configuration} This allows a system to access configuration files through the config system.\\
    \begin{cppcode}
        struct Type {
            static constexpr const char* CONFIGURATION_PATH = "Something.yaml"
        }

        on<Trigger<Configuration<Type>>>([](const Configuration<Type>& config) {
            // This has the configuration from Something.yaml
        });
    \end{cppcode}
\end{document}