\documentclass{beamer}
\mode<presentation> {
	\usetheme{Malmoe}
	\usecolortheme{whale}
	\setbeamertemplate{footline}[page number]
	\setbeamertemplate{navigation symbols}{}
}

\usepackage{graphicx} 	% Allows including images
\usepackage{booktabs} 	% Allows the use of \toprule, \midrule and \bottomrule in tables
\usepackage{tikz} 		% Pretty diagrams.
\usepackage{adjustbox}	% Scale images/diagrams to slide
\usepackage{color}
\usepackage{colortbl}
\usepackage{listings}
\usetikzlibrary{
	positioning				% Allows 5px above/below of x style positioning
	, arrows				% Allows <-, ->, <-> style arrows.
	, fit					% Allows fitting lines to shapes
	, decorations.pathreplacing	% Allows decoration that affect line paths.
	, backgrounds
	, shapes
	, shapes.multipart
	, calc
	, chains
}

\definecolor{dblue}{rgb}{0,0,0.545}
\definecolor{lgrey}{rgb}{0.9,0.9,0.9}
\definecolor{darkblue}{rgb}{0.0,0.0,0.6}
\lstdefinelanguage{nuclear}{
	backgroundcolor=\color{gray!10},
	basicstyle=\footnotesize \ttfamily \color{black} \bfseries,
	breakatwhitespace=false,
	breaklines=true,
	captionpos=b,
	commentstyle=\color{green!50!black},
	deletekeywords={...},
	escapeinside={\%*}{*)},
	frame=single,
	language=C++,
	keywordstyle=\color{violet},
	morekeywords={constexpr},
	identifierstyle=\color{black},
	stringstyle=\color{red},
	numbers=left,
	numbersep=5pt,
	numberstyle=\tiny\color{black},
	rulecolor=\color{black},
	showspaces=false,
	showstringspaces=false,
	showtabs=false,
	stepnumber=1,
	tabsize=5,
	title=\lstname,
	emph={on, emit, Trigger, With, Options},
	emphstyle={\color{blue}}
}

\lstdefinelanguage{nuclear-cmake}{
	backgroundcolor=\color{gray!10},
	basicstyle=\footnotesize \ttfamily \color{black} \bfseries,
	breakatwhitespace=false,
	breaklines=true,
	captionpos=b,
	commentstyle=\color{green!50!black},
	deletekeywords={...},
	escapeinside={\%*}{*)},
	frame=single,
	language=bash,
	keywordstyle=\color{violet},
	morekeywords={ADD_HAT},
	identifierstyle=\color{black},
	stringstyle=\color{red},
	numbers=left,
	numbersep=5pt,
	numberstyle=\tiny\color{black},
	rulecolor=\color{black},
	showspaces=false,
	showstringspaces=false,
	showtabs=false,
	stepnumber=1,
	tabsize=5,
	title=\lstname,
	emph={NAME, MODULES},
	emphstyle={\color{blue}}
}

%----------------------------------------------------------------------------------------
%	TITLE PAGE
%----------------------------------------------------------------------------------------

\title[Short title]{Project NUClear - NUBots Training}

\author{
	Trent Houliston \and Jake Woods
}

\institute[UoN]
{
	University of Newcastle \\ % Your institution for the title page
	\medskip
	\textit{Trent.Houliston@uon.edu.au, Jake.f.woods@gmail.com} % Email address
}

\date{\today}

% Start of document
\begin{document}

%----------------------------------------------------------------------------------------
% Title Slide
%----------------------------------------------------------------------------------------
\begin{frame}
	\titlepage % Print the title page as the first slide
\end{frame}


%----------------------------------------------------------------------------------------
% Overview (Table of Contents
%----------------------------------------------------------------------------------------
\begin{frame}
	\tableofcontents
\end{frame}

%----------------------------------------------------------------------------------------
\section{Current System}
%----------------------------------------------------------------------------------------
\subsection{Existing Components}
\begin{frame}
	\frametitle{Existing Components}
	\begin{itemize}
		\item Blackboard
			\begin{itemize}
				\item Is the central data store of the system
				\item Most components who communicate put their data on this object
			\end{itemize}
		\item Jobs
			\begin{itemize}
				\item Is a form of message passing system
				\item Is used by Behaviour to communicate with motion
				\item Is also used by several systems to provide communication
			\end{itemize}
		\item Team Network
			\begin{itemize}
				\item The network that is used to communicate between robots
				\item Is based on streaming strings and then later interpreting them
				\item Each module must read all incoming data and decide if it is for them
			\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Existing Components}
	\begin{itemize}
		\item Game Controller Network
			\begin{itemize}
				\item The system that is used by the referees to communicate with teams
				\item Exists as functionality within blackboard
			\end{itemize}
		\item Hardware Input (CM730)
			\begin{itemize}
				\item Reads from the CM730 (Accelerometer, Gyroscope etc.)
				\item Reads from the MX28s (Motors)
				\item Reads from the FSR (Force Sensitive Resistors)
			\end{itemize}
		\item Actionators
			\begin{itemize}
				\item A wrapper layer around the hardware output
				\item Interpolates movements by sending all intervening points to the motors
				\item Handles communication to the LEDs
			\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Existing Components}
	\begin{itemize}
		\item Camera
			\begin{itemize}
				\item Reads the camera frames from the camera and writes them to blackboard
			\end{itemize}
		\item Vision
			\begin{itemize}
				\item Takes input images and finds objects
				\item Classifies images into colour classifications
				\item Uses RANSAC to find lines in the classified image
				\item Uses a highly optimized circle finder (relying on
			\end{itemize}
		\item Localisation
			\begin{itemize}
				\item Takes data from almost every other sensor that helps provide location
				\item Uses a multimodal Kalman filter to build many world models
				\item Takes the most probable one as the state of the world
				\item Also handles filtering of incoming data to clean it
			\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Existing Components}
	\begin{itemize}
		\item Behaviour
			\begin{itemize}
				\item Takes all of the available data and makes high level action plans
				\item Handles tasks from deciding roles to drawing walk paths
			\end{itemize}
		\item Kinematics
			\begin{itemize}
				\item Describes the robots model of itself
				\item Is used to go from motor angles to a self model
				\item Contains a model of the robots mass distribution along its joints
				\item Also contains reverse kinematics which go from a self model to motor angles
			\end{itemize}
		\item Configuration System
			\begin{itemize}
				\item Is the new system designed to configure components
				\item Uses a callback method to inform when the global config has changed
				\item Loads from JSON files in a specific format
			\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Existing Components}
	\begin{itemize}
		\item Motion
			\begin{itemize}
				\item Scripts
					\begin{itemize}
						\item Handles execution of Scripts (a series of waypoints)
						\item Can select from the scripts loaded in the config file
					\end{itemize}
				\item Head Motion
					\begin{itemize}
						\item Handles controlling where the head is looking
						\item Is able to either pan the head in a search or focus on a specific object
					\end{itemize}
				\item Walk Engine
					\begin{itemize}
						\item Handles all of the motor positions required to walk
						\item Takes higher priority then the other motion modules
					\end{itemize}
			\end{itemize}
	\end{itemize}
\end{frame}

\subsection{Existing Architecture}
\begin{frame}
	\frametitle{Existing Architecture}
	\begin{itemize}
		\item The system runs in a synchronised dual pipeline architecture
			\begin{itemize}
				\item The See Think loop holds most of the logic and decision making code
				\item The Sense Move loop is a much smaller loop that simply reads from the sensor and camera, and writes motor actions to the motors
			\end{itemize}
		\item The threads are synchronised to run at regular intervals
		\item Most of these systems read in from the Blackboard and write back to it
		\item Some of them will communicate using a message system called Jobs
		\item The remainder of the communication is done using direct function calls on singletons
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Existing Architecture - Data Flow Diagram}
	\begin{tikzpicture}[
			x=10.5em,y=4.75em,
			component/.style={
				rectangle
				, rounded corners
				, draw=black, very thick
				, text width=7em
				, minimum height=2.4em
				, text centered
			}
			, splitcomponent/.style={
				component
				, rectangle split
				, rectangle split parts=2
			}
			, configsystemconfig/.style={ color=green!75!black }
			, fileconfig/.style={ color=red!75!black }
			, jobconfig/.style={ color=blue!75!black }
			, hardcodedconfig/.style={ color=black }
			, publicinterface/.style={ color=orange!75!black}
			, write/.style={ ->, thick}
			, read/.style={<-, thick}
			, readwrite/.style={<->, thick}
			, >=latex
		]

		%\node at (0.5,2.5) {$P_{1}$};

		%%% Nodes
		%% Left hand Side
		\node at (0,3) [component] (vision) {Vision};
		\node at (0,2) [component] (localization) {Localization};
		\node at (0,1) [component] (behavior) {Behavior};

		%% Center
		\node at (1, 3) [splitcomponent] (blackboard) {Blackboard \nodepart{two} Game Network\\Team Network};
		\node at (1, 2) [component] (kinematics) {Kinematics};
		\node at (1, 1) [component] (jobs) {Jobs};
		\node at (1, 0) [component] (actionators) {Actionators (Hardware)};

		%% Right hand side
		\node at(2,3) [component] (sensors) {Sensors (Hardware)};
		\node at(2,2) [component] (camera) {Camera (Hardware)};
		\node at(2,1) [splitcomponent] (motion) {Motion \nodepart{two} Scripts\\Head Motion\\Walk Engine};

		%%% Connections
		%% Left side connections
		\path [readwrite, out=10, in=170] (vision) edge (blackboard);
		\path [readwrite, out=20, in=185] (localization) edge (blackboard);
		\path [read, out=10, in=200] (behavior) edge (blackboard);
		\path [write, out=5, in=185] (behavior) edge (jobs);
		\path [write, out=-5, in=160] (behavior) edge (actionators);

		%% Center connections
		\path [readwrite] (kinematics) edge (blackboard);

		%% Right side connections
		\path [write, out=170, in=10] (sensors) edge (blackboard);
		\path [write, out=185, in=-20] (camera) edge (blackboard);
		\path [write, out=-10, in=190] (jobs) edge (motion);
		\path [write, out=10, in=190] (jobs) edge (camera);
		\path [write, out=200, in=20] (motion) edge (actionators);
		\path [read, out=150, in=0] (motion) edge (kinematics);

		%%% Configuration Colours
		%% Vision
		\filldraw[fileconfig] ([yshift=-.5em,xshift=.5em]vision.north west) circle (3pt);
		\filldraw[hardcodedconfig] ([yshift=-1.25em,xshift=.5em]vision.north west) circle(3pt);
		\filldraw[publicinterface] ([yshift=-.8em,xshift=-0.9em]vision.north east) rectangle ++(6pt, 6pt);

		%% Localization
		\filldraw[fileconfig] ([yshift=-.5em,xshift=.5em]localization.north west) circle(3pt);
		\filldraw[hardcodedconfig] ([yshift=-1.25em,xshift=.5em]localization.north west) circle (3pt);
		\filldraw[publicinterface] ([yshift=-.8em,xshift=-0.9em]localization.north east) rectangle ++(6pt, 6pt);

		%% Behavior
		\filldraw[fileconfig] ([yshift=-.5em,xshift=.5em]behavior.north west) circle(3pt);
		\filldraw[hardcodedconfig] ([yshift=-1.25em,xshift=.5em]behavior.north west) circle(3pt);

		%% Blackboard
		\filldraw[publicinterface] ([yshift=-.8em,xshift=-0.9em]blackboard.north east) rectangle ++(6pt, 6pt);

		%% Kinematics
		\filldraw[fileconfig] ([yshift=-.5em,xshift=.5em]kinematics.north west) circle(3pt);
		\filldraw[publicinterface] ([yshift=-.8em,xshift=-0.9em]kinematics.north east) rectangle ++(6pt, 6pt);

		%% Jobs
		\filldraw[publicinterface] ([yshift=-.8em,xshift=-0.9em]jobs.north east) rectangle ++(6pt, 6pt);

		%% Actionators
		\filldraw[publicinterface] ([yshift=-.8em,xshift=-0.9em]actionators.north east) rectangle ++(6pt, 6pt);

		%% Sensors
		\filldraw[hardcodedconfig] ([yshift=-.5em,xshift=.5em]sensors.north west) circle(3pt);

		%% Camera
		\filldraw[jobconfig] ([yshift=-.5em,xshift=.5em]camera.north west) circle(3pt);
		\filldraw[fileconfig] ([yshift=-1.25em,xshift=.5em]camera.north west) circle(3pt);
		\filldraw[hardcodedconfig] ([yshift=-2em,xshift=.5em]camera.north west) circle (3pt);
		\filldraw[publicinterface] ([yshift=-.8em,xshift=-0.9em]camera.north east) rectangle ++(6pt, 6pt);

		%% Motion
		\filldraw[hardcodedconfig] ([yshift=-.5em,xshift=.5em]motion.north west) circle (3pt);
		\filldraw[configsystemconfig] ([yshift=-2.25em,xshift=.5em]motion.north west) circle (3pt);
		\filldraw[fileconfig] ([yshift=-3.5em,xshift=.5em]motion.north west) circle(3pt);
		\filldraw[publicinterface] ([yshift=-.8em,xshift=-0.9em]motion.north east) rectangle ++(6pt, 6pt);

		%%% Legend
		\coordinate (legendpoint) at (.55, .35);

		%% Public Interface
		\node [below=3pt of legendpoint,anchor=south east] (publicinterfacelabel) {\tiny Provides a Singleton Public Interface};
		\filldraw[publicinterface] ([yshift=-3pt,xshift=-3pt]publicinterfacelabel.west) rectangle ++(6pt, 6pt);

		%% Hard Coded Config
		\node [below=0.9em of publicinterfacelabel.south west,anchor=south west] (hardcodedconfiglabel) {\tiny Configured by Hardcoding Values};
		\filldraw[hardcodedconfig] ([yshift=.5pt]hardcodedconfiglabel.west) circle (3pt);

		%% File Config
		\node [below=0.8em of hardcodedconfiglabel.south west,anchor=south west] (fileconfiglabel) {\tiny Configured by Custom Files};
		\filldraw[fileconfig] ([yshift=.5pt]fileconfiglabel.west) circle (3pt);

		%% Job Config
		\node [below=0.8em of fileconfiglabel.south west,anchor=south west] (jobconfiglabel) {\tiny Configured by Job System};
		\filldraw[jobconfig] ([yshift=.5pt]jobconfiglabel.west) circle (3pt);

		%% Config System Config
		\node [below=0.8em of jobconfiglabel.south west,anchor=south west] (configsystemconfiglabel) {\tiny Configured by Configuration System};
		\filldraw[configsystemconfig] ([yshift=.5pt]configsystemconfiglabel.west) circle (3pt);

		%%% Decorations
		%% SeeThink header
		\node[fit=(vision)(localization)(behavior)](leftgroup){};
		\draw[rounded corners]
		(leftgroup.north west)--(leftgroup.south west) -- ++(0.10,0);
		\draw[decorate,decoration={amplitude=7pt,brace}] % Header line
		(leftgroup.north west) -- (leftgroup.north east);

		\node[above=1.1em of leftgroup,anchor=center]{SeeThink Loop};

		%% SenseMove header
		\node[fit=(sensors)(camera)(motion)](rightgroup){};
		\draw[rounded corners]
		(rightgroup.north east) -- (rightgroup.south east) -- ++(-0.10,0);
		\draw[decorate,decoration={amplitude=7pt,brace}]
		(rightgroup.north west) -- (rightgroup.north east);
		\node[above=1.1em of rightgroup,anchor=center]{SenseMove Loop};
	\end{tikzpicture}

\end{frame}

\begin{frame}
	\frametitle{Existing Architecture - Dependency Graph}
	\begin{adjustbox}{max totalsize={\textwidth}{.9\textheight},center}
	\begin{tikzpicture}[
		reactor/.style={draw, circle, ultra thick}
		, basearrow/.style={>=triangle 45, ultra thick}
		, blackboard/.style={basearrow, dashed}
		, publicinterface/.style={basearrow, color=red!75!black}
		, jobs/.style={basearrow, dotted, color=blue!75!black}
		, dependent/.style={->}
		, codependent/.style={<->}]

		%%% Legend
		\coordinate (legendpoint) at (13, -2);

		%% Public Interface Dependency
		\node [below=of legendpoint,anchor=east] (publicinterfacelabel) {\small Public Interface Dependency};
		\draw [publicinterface] (publicinterfacelabel.mid west) -- ++(-38pt, 0pt);

		%% Blackboard Dependency
		\node [below=12pt of publicinterfacelabel.south west,anchor=south west] (blackboardlabel) {\small Dependency through Blackboard};
		\draw[blackboard] (blackboardlabel.mid west) -- ++(-38pt, 0pt);

		%% Jobs Dependency
		\node [below=12pt of blackboardlabel.south west,anchor=south west] (joblabel) {\small Dependency through Job System};
		\draw[jobs] (joblabel.mid west) -- ++(-38pt, 0pt);

		%% Dependancy Type: Depends on
		\node[below=20pt of joblabel.south west,anchor=south west] (dependencylabel) {\small X depends on Y};
		\node[circle, draw, inner sep=0.5pt] (dependencynodeY) at ([yshift=1pt,xshift=-2pt]dependencylabel.mid west) {\tiny Y};
		\node[circle, draw, inner sep=0.5pt, left=24pt of dependencynodeY] (dependencynodeX) {\tiny X};
		\draw[basearrow, dependent] (dependencynodeX) edge (dependencynodeY);

		%% Dependancy Type: Codependent
		\node[below=12pt of dependencylabel.south west,anchor=south west] (codependencylabel) {\small X, Y depend on each other};
		\node[circle, draw, inner sep=0.5pt] (codependencynodeY) at ([yshift=1pt,xshift=-2pt]codependencylabel.mid west) {\tiny Y};
		\node[circle, draw, inner sep=0.5pt, left=24pt of codependencynodeY] (codependencynodeX) {\tiny X};
		\draw[basearrow, codependent] (codependencynodeX) edge (codependencynodeY);

		%% Legend Header
		\node[above=0pt of publicinterfacelabel] (legendheader) {Legend};

		%%% Draw all of our components in a circle
		\foreach [count=\i] \reactor in {Camera, Vision, Localization, Behavior, Network, Sensors, Kinematics, Motion, Actionators} {

			% Draw the reactors around the central star
			\node[reactor] (\reactor) at ({360/9 * (\i - 1)}:7cm) {$\reactor$};
		};

		%% Legend Border
		\node[fit=(legendheader)(publicinterfacelabel)(blackboardlabel)
				(joblabel)(dependencylabel)(codependencynodeX)(codependencynodeY),rectangle,draw](legendgroup){};

		%%% Dependencies
		%% Vision
		\path[blackboard, dependent] (Vision.305) edge (Camera.95);
		\path[publicinterface, dependent] (Vision.275) edge (Camera.120);
		\path[blackboard, dependent] (Vision) edge (Sensors);

		%% Localization
		\path[blackboard, dependent] (Localization) edge (Sensors);
		\path[blackboard, dependent] (Localization) edge (Vision);

		%% Behavior
		\path[blackboard, codependent] (Behavior) edge (Localization);
		\path[blackboard, dependent] (Behavior) edge (Kinematics);
		\path[blackboard, dependent] (Behavior) edge (Vision);
		\path[blackboard, dependent] (Behavior) edge (Sensors);
		\path[publicinterface, dependent] (Behavior) edge (Actionators);
		\path[publicinterface, codependent] (Behavior) edge (Network);
		\path[jobs, dependent] (Behavior) edge (Camera);

		%% Motion
		\path[blackboard, codependent] (Motion.80) edge (Behavior.300);
		\path[jobs, dependent] (Motion.120) edge (Behavior.280);
		\path[publicinterface, dependent] (Motion) edge  (Actionators);
		\path[publicinterface, dependent] (Motion) edge (Kinematics);
	\end{tikzpicture}
	\end{adjustbox}
\end{frame}

\subsection{Justification for Change}
\begin{frame}
	\frametitle{Problems in Existing System}
	\begin{itemize}
		\item Hidden Dependencies
			\begin{itemize}
				\item The existing systems dependencies are very poorly defined
				\item For example, localizations dependency on the Stationary/Mobile object system.
				\item These hidden dependencies make it difficult to work on a system without understanding the whole system
			\end{itemize}

		\item Threading Issues
			\begin{itemize}
				\item Current system does not handle synchronisation between the two threads well
				\item e.g. The kick system can be prompted mid way by the walk engine, the two can even run together resulting in the robot standing still for prolonged periods.
				\item Happens because the interactions between the two threads is undefined in most cases
			\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Problems in Existing System}
	\begin{itemize}
		\item Network Communication
			\begin{itemize}
				\item Network communication is currently entirely through Localisation and Behaviour
				\item Adding new network communication requires modifying these two systems
				\item Because of the difficulty of adding new networking, no new networking will be added
			\end{itemize}

		\item Build System
			\begin{itemize}
				\item The current build system uses a make file that calls cmake that builds a make file that is called by the original make file
				\item This makes adding and removing components to the system in a meaningful way difficult
			\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Wishlist}
	\begin{itemize}
		\item Modular Design
			\begin{itemize}
				\item Many modules that are made for robotics (walk engine, script engine) are useful for more then just soccer.
				\item Being able to use Mock inputs allows the system to be tested without access to a robot
				\item Being able to compose various modules into a binary would allow the robot to do more
				\item Enabling the sharing of these modules between researchers would result in better development (more people using the same code)
			\end{itemize}

		\item Transparent Multithreading
			\begin{itemize}
				\item Modern CPUs are getting more cores, rather then becoming faster
				\item Threading is difficult and can almost never be sensibly done at the module level
				\item Threading should be handled by the architecture in a way that can scale up to many cores
			\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Wishlist}
	\begin{itemize}
		\item Runtime Statistics
			\begin{itemize}
				\item When optimising programs for speed it is useful to see how long each section of the code took
				\item Breaking up the modules and timing their execution better shows where CPU time is being used
			\end{itemize}

		\item Fine Grained Debugging
			\begin{itemize}
				\item When debugging a large system, there is often a low signal to noise ratio as a lot of debug lines are not useful
				\item Splitting up log lines based on source can help identify problems
				\item Being able to view the call graph in real time on a repeated process helps to identify links
			\end{itemize}
	\end{itemize}
\end{frame}

%----------------------------------------------------------------------------------------
\section{C++ Review}
%----------------------------------------------------------------------------------------
\subsection{Smart Pointers and Move Semantics}
\begin{frame}
	\frametitle{C++ Review - Smart Pointers}
	\begin{itemize}
		\item Smart Pointers automatically release pointer memory for you.
		\item There are different smart pointers that decide when and how data is deleted.
		\item As of C++11 there is almost never a reason to use new/delete or raw pointers.
		\item Instead you should use std::unique\_ptr and std::shared\_ptr with std::make\_shared and std::make\_unique
		\item In NUClear you will primarily use std::unique\_ptr to send messages.
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{C++ Review - std::unique\_ptr}
	\begin{itemize}
		\item Only one unique\_ptr is allowed to point to a particular address.
		\item When copied the unique\_ptr transfers ownership to the new unique\_ptr and the old one becomes invalid.
		\item When you pass a unique\_ptr to a function you are giving away it's ownership.
		\item Don't use a unique\_ptr after it has been passed or copied. It will be null!
		\item unique\_ptr deletes it's data when it goes out of scope.
		\item This should be your go-to pointer unless you have a good reason otherwise.
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{C++ Review - std::move}
	\begin{itemize}
		\item Data stealing in C++ is known as "move semantics"
		\item It's a fancy way of expressing transfer of ownership.
		\item When something is "moved" it can't be used after moving.
		\item Compilers automatically move things that don't have a name.
		\item Some classes can only be constructed by moving data into them. Like std::unique\_ptr!
		\item When something has a name you use std::move(...) to move it!
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{C++ Review - std::move}
	\begin{lstlisting}[language=nuclear]
		// We don't use raw pointers but this is a slide!
		int* chump = new data(5);

		// Prints 5.
		std::cout << *chump << std::endl;

		// theif steals 5 from chump.
		int* thief = std::move(chump);

		// Error: Chump doesn't have 5 anymore.
		std::cout << *chump << std::endl;

		// No problem: Thief stole 5.
		std::cout << *thief << std::endl;
	\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{C++ Review - std::unique\_ptr}

	std::unique\_ptr uses move semantics!

	\begin{lstlisting}[language=nuclear]
		#include <memory> // unique_ptr & shared_ptr

		void processImage(const Image& image) {
		    std::unique_ptr<MyData> chump =
		        std::make_unique<MyData>();

		    chump->something; // Access pointer-style:* and ->

		    // theif has stolen chump's pointer.
		    // you can't use chump to get to the
		    // data since he doesn't have it.
		    std::unique_ptr<MyData> thief = std::move(data);
		    thief->something; // No problem!
		    chump->something; // Error. Bad chump!
		} // thief automatically releases memory here.
	\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{C++ Review - std::shared\_ptr}
	\begin{itemize}
		\item shared\_ptr is a reference counting pointer.
		\item When no shared\_ptr's point to a particular bit of data it will be deleted.
		\item When you copy a shared\_ptr it increments a shared reference counter.
		\item When a shared\_ptr falls out of scope is decrements the shared reference counter.
		\item When the counter is zero your data is deleted.
		\item shared\_ptr should be used when you truly need to share data and there is no clear single-owner.
			This is more rare then people might like to believe.
	\end{itemize}
\end{frame}

\subsection{Templates}
\begin{frame}
	\frametitle{C++ Review - Templates}
	\begin{itemize}
		\item Templates let you write type-agnostic code.
		\item Briefly touched on in SENG1120.
		\item Templates let you provide a "blueprint" for a function or class allowing the compiler to generate
			copies of the same class that vary based on what type they are templated with.
		\item For example the std::vector class is a template which lets the compiler generate a concrete
			std::vector$<$int$>$ or std::vector$<$MyClass$>$ on demand when a user tries to use those classes
			in a vector.
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{C++ Review - Templates}
	\begin{lstlisting}[language=nuclear]
		// Works on anything that has an operator+
		template <typename T>
		T add(const T& first, const T& second) {
		    return first + second;
		}

		// Generates a "int" version of add at compile time.
		std::cout << add<int>(1, 2) << std::endl;

		// C++ can also automatically work out the T.
		std::cout << add(1.0, 5.0) << std::endl;

		// Behind the scenes C++ generates something like this
		// for add<int>
		int add(const int& first, const int& second) {
		    return first + second;
		}
	\end{lstlisting}
\end{frame}

\subsection{Template Metaprogramming}
\begin{frame}
	\frametitle{C++ Review - Template Metaprogramming}
	\begin{itemize}
		\item Clever people realized that templates are actually turing complete.
		\item You can write some really interesting programs with templates and perform logic at compile time.
		\item Since this was an accident the syntax isn't super-friendly.
		\item However you can use Template Metaprogramming to express complex problems with no runtime cost.
		\item We use this extensively in NUClear but avoid it in the robocup code.
		\item Except for configuration (looking at you Trent!).
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{C++ Review - Calling template functions}
	\begin{itemize}
		\item NUClear's On and Emit functions look weird to new C++ programmers as they contain a lot of arguments in angle brackets
			$<>$ instead of the expected round braces ().
		\item The easiest way to think about this is angle bracket arguments are evaluated at compile time while round braces are
			evalutaed at runtime.
	\end{itemize}

	\begin{lstlisting}[language=nuclear]
		//	      <Compile>(Runtime)
		something<1, 2, 3>(4, 5, 6);

		// 1, 2 and 3 will be evaluated when the program
		// is compiled and as such can't change based on
		// user input. 4, 5 and 6 are regular parameters.
	\end{lstlisting}
\end{frame}

\subsection{Auto, Range-Based For and Lambdas}
\begin{frame}[fragile]
	\frametitle{Auto}
	\begin{itemize}
		\item Automatically get somethings type.
		\item Similar to javascript or C\#'s var.
		\item You should almost always use auto.
	\end{itemize}

	\begin{lstlisting}[language=nuclear]
		std::map<std::complex, SomeLongThing<int>> getSomeComplexType() {
		    ...
		    return complexType;
		}

		// Auto finds the type and saves you the hassle!
		// Normally you'd need to type std::map<std::complex, SomeLongThing<int>>
		auto complexType = getSomeComplexType();

		// Get something by reference.
		auto& something = someClass.something;
	\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Range-Based For}
	\begin{itemize}
		\item Finally a for-loop that doesn't suck.
		\item Anything that provides a begin() and end() function can be used with range-based for.
		\item Also arrays.
		\item If you don't need to modify the list then you should use range-based for.
		\item Otherwise use a regular iterator (with auto!).
	\end{itemize}

	\begin{lstlisting}[language=nuclear]
		std::vector<int> vec = {1,2,3,4,5};
		// You can also use auto& to get by reference.
		for(auto v : vec) {
		    // Do stuff with v
		}
	\end{lstlisting}
\end{frame}

\begin{frame}
	\frametitle{Lambdas}
	\begin{itemize}
		\item Lambdas are functions that have no name.
		\item They are useful in callback system as they allow you to write a function without providing the full boilerplate
			to define a new function in a class.
		\item First introduced in C++11 they are a conveinient way to provide NUClear callbacks.
		\item If you want to test your callback or have a lot of arguments you should use a proper member function.
		\item Otherwise lambdas are an easy way to make simple callbacks
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Lambdas}
	\begin{lstlisting}[language=nuclear]
		// A lambda has three parts. The capture, arguments and body.
		// Capture: [...] access outside variables.
		// Arguments: (...) a standard C++ argument list.
		// Body: { ... } the function implementation.

		int main() {
		    int data = 5;
		    auto myLambda = [data](int arg){
		        // do something with data and arg.
		        // data is copied so you can access is even if it goes out of scope.
		    };

		    // Calls myLambda with arg=100. data will be 5.
		    myLambda(100);
		}
	\end{lstlisting}
\end{frame}

\begin{frame}
	\frametitle{Lambdas}
	\begin{itemize}
		\item The difference between [] and () is when the argument is bound.
		\item Things in [] are bound when the lambda is created.
		\item Things in () are bound when the lambda is called. This can be much later then it's creation
		\item You can use [=] to bind everything in scope to the lambda by copy.
		\item Or you can use [\&] to bind by reference.
		\item If you're in a class you can use [this] to give the lambda access to the class members.
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Lambdas}
	\begin{lstlisting}[language=nuclear]
		int a = 5;
		SomeClass c;

		// Lambda with a copy of a and c.
		[=]() { /* body */ };

		// Lambda with a reference to a and c. Will segfault if called and a or c are destructed.
		[&]() { /* body */ };

		// Lambda with a copy of a and a reference to c. Will segfault if called and c is destructed.
		[a, &c]() { /* body */};
	\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Lambdas}
	\begin{lstlisting}[language=nuclear]
		class Example {
		private:
		    std::vector<int> data;
		    std::function<void (int)> callback;
		public:
		    Example() {
		        callback = [this](int arg) {
		            // We can only access data due to [this]
		            data.push_back(arg);
		        };
		    }

		    void doCallback() {
		        // Runs our lambda we bound from before.
		        callback(100);
		    }
		};
	\end{lstlisting}
\end{frame}

%----------------------------------------------------------------------------------------
\section{NUClear Architecture}
%----------------------------------------------------------------------------------------
\subsection{Architectural Overview}
\begin{frame}
	\frametitle{NUClear Architecture}
	\begin{itemize}
		\item NUClear is a message passing system
		\item Rather then directly interacting with each-other, indirectly interact through common data
		\item Results in very loose coupling making it easy to add remove or change components
		\item Makes it easy to have multiple components using the same input data
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Multi Threading}
	\begin{itemize}
		\item NUClear is a multi threaded framework
		\item It will transparently multithread any code that is given to it
		\item This allows it to make use of all of the resources in the system
		\item Synchronisation needs to be taken into account if multiple threads could access the same data
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle {Multi Threading}
	\begin{adjustbox}{max totalsize={\textwidth}{\textheight},center}
		\centering
		\begin{tikzpicture}
			\begin{scope}[
				task/.style={draw=black},
				cameratriggered/.style={fill=blue!10},
				sensortriggered/.style={fill=red!10}]

				\draw (1, 1) grid (21, 4);

				%% Thread 1
				\draw[cameratriggered, task] (1, 3) rectangle node {Camera} (6, 4);
				\draw[sensortriggered, task] (8, 3) rectangle node {Field Mapper} (12, 4);
				\draw[cameratriggered, task] (13, 3) rectangle node {Localisation} (17, 4);
				\draw[cameratriggered, task] (19, 3) rectangle node {Motion} (21, 4);

				%% Thread 2
				\draw[sensortriggered, task] (1, 2) rectangle node {Sensors} (5, 3);
				\draw[cameratriggered, task] (6, 2) rectangle node {Vision} (13, 3);
				\draw[cameratriggered, task] (17, 2) rectangle node {Behaviour} (19, 3);

				%% Thread 3
				\draw[sensortriggered, task] (5, 1) rectangle node {Odometry} (8, 2);
				\draw[sensortriggered, task] (12, 1) rectangle node {Map Combiner (Network)} (19, 2);

				% Row labels
				\node[anchor=east, inner sep=0] at (.8, 3.5) {Thread 1};
				\node[anchor=east, inner sep=0] at (.8, 2.5) {Thread 2};
				\node[anchor=east, inner sep=0] at (.8, 1.5) {Thread 3};

				% Column Labels
				\foreach \i in {1,...,20} {
				\node[anchor=north, inner sep=0] at (\i + .5, .8) {\i};
				}
			\end{scope}
		\end{tikzpicture}
	\end{adjustbox}
\end{frame}

\begin{frame}
	\frametitle{Powerplant}
	\begin{itemize}
		\item The Powerplant is the core component of the NUClear system
		\item It is the central datapoint for the whole system
		\item It holds the functionality for doing the following:
			\begin{itemize}
				\item Install a new reactor
				\item Start up the system
				\item Shutdown the system
			\end{itemize}
		\item You are also able to directly send messages from it (for injecting messages)
		\item Most of the time, you will never directly interact with it
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Reactor}
	\begin{itemize}
		\item A Reactor is the primary method that you will interact with the system
		\item It is a class that extends from NUClear::Reactor
		\item It has all of the methods on it that are used to listen for and emit messages, these being:
			\begin{itemize}
				\item on
				\item emit
				\item log
			\end{itemize}
		\item You then install these reactors into the Powerplant
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Reaction}
	\begin{itemize}
		\item A reaction is a single function that is run in response to new data
		\item They take as arguments constant references to the data that they use
		\item The data that is passed into a reaction function can be considered thread safe
		\item The lifetime of the data used is managed by the Powerplant
			\begin{itemize}
				\item If you really need to save the data, you will need to save a copy
			\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Networking}
	\begin{itemize}
		\item The networking system in NUClear uses ZMQ under the hood
		\begin{itemize}
			\item ZMQ is a transport agnostic middle man that allows us to do things like publish/subscribe and auto reconnection
		\end{itemize}
		\item We also use google protocol buffers as our message packing format
		\item The messages are sent over the ePGM transport
		\begin{itemize}
			\item The ePGM transport is a multicast transport with reliability built in (think tcp)
		\end{itemize}
		\item Messages that are sent can be anything that has a method to serialise (protocol buffers do by default)
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Networking}
	\begin{adjustbox}{max totalsize={\textwidth}{\textheight},center}
	\begin{tikzpicture}[x=15em,y=5em,>=latex,
		A/.style={red},
		B/.style={blue},
		reactor/.style={draw, circle, thick},
		write/.style={->,thick},
		read/.style={<-,thick}]

		%%% Left Power Plant
		\node at (0, 0) [draw,star,star points=8,star point ratio=0.875,minimum width=3cm] (plantA) {Powerplant A};
		\node [above=of plantA,reactor] (sensorsA) {Sensors};
		\node [below=of plantA,reactor,align=center] (fieldmapperA) {2d Field\\Mapper};
		\path [A, write] (sensorsA) edge node[A,left] {Image(A)} (plantA);
		\path [A, read] (fieldmapperA.110) edge node[left] {Image(A)} (plantA.260);
		\path [B, read] (fieldmapperA.70) edge node[right] {Image(B)} (plantA.280);

		%%% Right Power Plant
		\node at (2, 0)
			[draw,star,star points=8,star point ratio=0.875,minimum width=3cm]
			(plantB){Powerplant B};
		\node [above=of plantB,reactor] (sensorsB) {Sensors};
		\node [below=of plantB,reactor,align=center] (fieldmapperB) {2d Field\\Mapper};
		\path [B, write] (sensorsB) edge node[left] {Image(B)} (plantB);
		\path [A, read] (fieldmapperB.110) edge node[left] {Image(A)} (plantB.260);
		\path [B, read] (fieldmapperB.70) edge node[right] {Image(B)} (plantB.280);

		%%% Network & Network Connections
		\node at (1, 0) [draw,cloud,cloud puffs=10,minimum width=3.5cm]
		(network) {Network};

		%% Plant A connections
		\path [A, write] (plantA.10) edge node[A, above] {Image(A)} (network.169);
		\path [B, read] (plantA.-9) edge node[B, below] {Image(B)} (network.190);

		%% Plant B connections
		\path [A, read] (plantB.171) edge node[A, above] {Image(A)}  (network.10);
		\path [B, write] (plantB.190) edge node[B, below] {Image(B)} (network.-11);
	\end{tikzpicture}
	\end{adjustbox}
\end{frame}

\begin{frame}
	\frametitle{Smart Types}
	\begin{itemize}
		\item Smart Types are special types that when used in an on statement will cause different behaviour
		\item Built into NUClear there are the smart types Every, Last, and Network
		\item The Configuration System also provides the Configuration smart type
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Extension}
	\begin{itemize}
		\item The creation of new Smart Types is done through extension
		\item Extension allows you to change the way specific datatypes are handled when:
			\begin{itemize}
				\item Exists: The data type is used in an on statement
				\item Emit: Data is emitted (particular data types and whole scopes)
				\item TriggerType: What datatype will cause a reaction to run
				\item Get: Data is retrieved (can even return a different datatype)
			\end{itemize}
		\item Extensions are generally for when system wide common functionality is needed
		\item They are advanced usage and should not be the normal usage pattern
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Service Thread}
	\begin{itemize}
		\item Sometimes a whole thread is needed to listen to an external blocking source
			\begin{itemize}
				\item An example would be a user interface
			\end{itemize}
		\item However having NUClear manage the lifetime of the program is beneficial
		\item To allow this you can create service threads
		\item These threads have a run() and kill() method which start and stop the thread respectively
		\item Most use cases should not need these and should be triggered by events if possible
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{NUClear Architecure}
	\begin{adjustbox}{max totalsize={\textwidth}{.9\textheight},center}
	\begin{tikzpicture}[
		old inner xsep/.estore in=\oldinnerxsep,
		old inner ysep/.estore in=\oldinnerysep,
		double circle/.style 2 args={
			circle,
			old inner xsep=\pgfkeysvalueof{/pgf/inner xsep},
			old inner ysep=\pgfkeysvalueof{/pgf/inner ysep},
			/pgf/inner xsep=\oldinnerxsep+#1,
			/pgf/inner ysep=\oldinnerysep+#1,
			alias=sourcenode,
			append after command={
			let \p1 = (sourcenode.center),
				\p2 = (sourcenode.east),
				\n1 = {\x2-\x1-#1-0.5*\pgflinewidth}
			in
				node [inner sep=0pt, draw, circle, minimum width=2*\n1,at=(\p1),#2] {}
			}
		}
		, double circle/.default={2pt}{black}
		, reactor/.style={draw, double circle}
		, readwrite/.style={<->, thick}
	]

	% Draw our central Power Plant star
	\node [draw,star,star points=8,star point ratio=0.875,minimum width=5cm] (powerplant) {\Huge Powerplant};

	% Loop through each of our reactors
	\foreach [count=\i] \reactor in {Camera, Vision, Localisation, Behaviour, Sensors, Kinematics, Motion Manager} {

		% Draw the reactors around the central star
		\node[draw,reactor] (reactorcircle) at ({360/7 * (\i - 1)}:6cm) {$\reactor$};

		% Draw a line from our reactor to our powerplant
		\path[readwrite] (reactorcircle) edge (powerplant);
	};
	\end{tikzpicture}
	\end{adjustbox}

\end{frame}

\subsection{Key Functions}
\begin{frame}[fragile]
	\frametitle {Key Functions - On and Trigger}
	\begin{itemize}
		\item Q: "I want to do something when new data is available"
		\item A: Use On and Trigger!
		\item Notifies Power Plant that you are interested in specific data and triggers a callback when new data is available.
	\end{itemize}

	\begin{lstlisting}[language=nuclear]
		// Make sure to take arguments by const reference!
		void processImage(const Image& data) {
		    // Do something with the image data here.
		}

		// Tells PowerPlant to call processImage when new
		// image data is available.
		on<Trigger<Image>>().then(processImage);
	\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle {Key Functions - With}
	\begin{itemize}
		\item Q: "I want to access data other then the one I triggered on"
		\item A: Use With!
		\item Notifies Power Plant that you want the latest version of some other data when your trigger function is called.
	\end{itemize}

	\begin{lstlisting}[language=nuclear]
		// Order of arguments needs to match the order of
		// Trigger and With arguments.
		void processData(
		    const Image& image,
		    const SensorData& sensors) {
		    // Do something with image and sensors
		}

		// Calls process data when a new image frame is
		// captured. Also passes the most recent sensordata
		// to processData.
		on<Trigger<Image>, With<SensorData>>().then(processData);
	\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle {Key Functions - With}
	\begin{itemize}
		\item Q: "I need more then one data!"
		\item A: With can take multiple arguments!
	\end{itemize}

	\begin{lstlisting}[language=nuclear]
		void processData(
		    const Image& image,
		    const SensorData& sensors,
		    const AudioData& audio) {
		    // Do stuff with the image
		}

		// We can either use With multiple times or With<A,B>
		on<Trigger<Image>,
		   With<SensorData, AudioData>>().then(processData);
		on<Trigger<Image>,
		   With<SensorData>, With<AudioData>>().then(processData);
	\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle {Key Functions - Options Priority}
	\begin{itemize}
		\item Q: "My Reaction is much more important then everyone else's!"
		\item A: Using Priority at the end of your reaction!
		\item Reactions with higher priority will get first access to free threads in the thread pool
	\end{itemize}

	\begin{lstlisting}[language=nuclear]
		void processData(const Image& image) {
		    // Do stuff with the image
		}

		// We can also set priority to LOW or DEFAULT
		on<Trigger<Image>, Priority::HIGH>>().then(processData);
	\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle {Key Functions - Options Single}
	\begin{itemize}
		\item Q: "If I'm already processing an Image, I don't want a new one till I'm done!"
		\item A: Use the Single argument
		\item This will drop any new events of the same kind until yours is done
	\end{itemize}

	\begin{lstlisting}[language=nuclear]
		void processData(const Image& image) {
		    // Do stuff with the image
		}

		// Now only one Image will be processed at a time.
		// If new ones come they'll be dropped
		on<Trigger<Image>, Single>().then(processData);
	\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle {Key Functions - Options Sync}
	\begin{itemize}
		\item Q: "I have several state dependent reactions that can't be multithreaded! If they are then they won't run properly! But I know that if I use mutexes on them all I'll be really mean to everyone else by blocking up all the pool threads!"
		\item A: Use the Sync argument
		\item This will only allow a single event from a sync group to execute at a time (the rest queuing up and running after)
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle {Key Functions - Options Sync (cont.)}
	\begin{lstlisting}[language=nuclear]
		void processData(const Image& image) {
		    // Do some thread unsafe operations!
		}

		void processMoarData(const Duck& duck) {
		    // Do some more thread unsafe operations!
		}

		// The no two reactions with the same type in the Sync template
		// will execute at the same time
		on<Trigger<Image>, Sync<MyReactor>>(processData);
		on<Trigger<Duck>, Sync<MyReactor>>(processMoarData);
	\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Key Functions - Emit}
	\begin{itemize}
		\item Q: "I have some data that I want to send to the world"
		\item A: Use emit!
		\item Sends the data that you emit out to the rest of the system.
		\item Takes a unique pointer (this means you have to std::move it!)
	\end{itemize}

	\begin{lstlisting}[language=nuclear]
		// We have a unique pointer to the data we want to send
		std::unique_ptr<MyData> myData =
		    std::make_unique<MyData>();

		// Send the data out to the world!
		emit(std::move(myData));
	\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Key Functions - Emit}
	\begin{itemize}
		\item Q: "No seriously... I meant "The World", like all of it"
		\item A: You mean the network? Then you need a scope!
		\item When you emit, you can specify scopes. These define where the messages go.
		\item For example, we will demonstrate the network scope
	\end{itemize}

	\begin{lstlisting}[language=nuclear]
		// We have a unique pointer to the data we want to send
		std::unique_ptr<MyData> myData =
		    std::make_unique<MyData>();

		// Send the data out to the world! like all of it
		emit<Scope::NETWORK>(std::move(myData));
	\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Key Functions - Emit}
	\begin{itemize}
		\item Q: "But I wanted to emit it to my own reactors to?"
		\item A: You can use multiple scopes when you emit and it will go to all of them
	\end{itemize}

	\begin{lstlisting}[language=nuclear]
		// We have a unique pointer to the data we want to send
		std::unique_ptr<MyData> myData =
		    std::make_unique<MyData>();

		// Send the data out to the world! like all of it
		emit<NETWORK, LOCAL>(std::move(myData));
	\end{lstlisting}
\end{frame}


\begin{frame}[fragile]
	\frametitle{Key Functions - Emit}
	\begin{itemize}
		\item Q: "I want to emit some data that others can use to configure themselves"
		\item A: If you want to emit some data in your constructor, before the system is started that others can use to configure themselves, then you need the Scope::INITIALIZE scope
		\item This scope will run all the reactions before the system starts but after the modules are installed
	\end{itemize}

	\begin{lstlisting}[language=nuclear]
		// We have a unique pointer to the data we want to send
		std::unique_ptr<MyData> myData =
		    std::make_unique<MyData>();

		// Send the data out to the world! like all of it
		emit<Scope::INITIALIZE>(std::move(myData));
	\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Key Functions - Emit}
	\begin{itemize}
		\item Q: "I want to emit data, but I don't want to go through the thread pool"
		\item A: If you use the DIRECT scope, then rather then sending all the events to the thread pool. You will block and run each reaction in sequence in your current thread.
		\item This will also hide their runtime stats and bundle them into your function
		\item The use case for this is often in extensions, before the threading system is started up
	\end{itemize}

	\begin{lstlisting}[language=nuclear]
		// We have a unique pointer to the data we want to send
		std::unique_ptr<MyData> myData =
		    std::make_unique<MyData>();

		// Send the data out to the world! like all of it
		emit<Scope::DIRECT>(std::move(myData));
	\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Key Functions - Emit}
	\begin{itemize}
		\item Q: "I want to emit data to a database!"
		\item A: This is something that NUClear does not do on its own. However, you can write an extension which allows you to define your own scopes.
		\item These scopes will run any time your scope is triggered. For more information read up on NUClear extensions (not in this presentation)
	\end{itemize}

	\begin{lstlisting}[language=nuclear]
		// We have a unique pointer to the data we want to send
		std::unique_ptr<MyData> myData =
		    std::make_unique<MyData>();

		// Send the data out to the world! like all of it
		emit<MyAwesomeDatabaseScope>(std::move(myData));
	\end{lstlisting}
\end{frame}

\begin{frame}
	\frametitle{Key Functions - Emit}
	\begin{adjustbox}{max totalsize={\textwidth}{.9\textheight},center}
	\begin{tikzpicture}[>=latex,
		block/.style={
			rectangle,
			rounded corners,
			draw=black, very thick,
			minimum height=3em,
			minimum width=10em,
			align=center
		},
		header/.style={
			rectangle,
			draw = black, thick,
			minimum height=1.2em,
			minimum width=12.5em,
			align=center
		},
		every join/.style={->, thick},
		chained/.style={every node/.style={on chain}}]

		\begin{scope}[start chain=going below, chained]

			% Draw the Register node and setup the following blocks to have arrows
			\node [block,join] (register) {Register Reaction from \\ Vision system};
			\begin{scope}[start branch=on going right, every join/.style={<-}]
				\node [block,join] (onimage) {on\textless \textbf{Image}\textgreater
				\\(processimage)};
			\end{scope}

			% Draw the on Every node
			\begin{scope}[start branch=on going left, every join/.style={<-}]
				\node [block,join] (onevery) {on\textless \textbf{Every 30ms}
				\textgreater\\(getimage)};
			\end{scope}

			% Start game node
			\node[block,join] (start) {Start game};

			% In Game every node
			\node [block, join] (runtimeStart) {Begin sending\\\textbf{Every
				\textless ...\textgreater} events};

			% Sensor Reactors node
			\node [block, join, on chain=going left] {Execute Reaction(s) \\for
				\textbf{Every\textless 30ms\textgreater}};

			% Get Camera Image Node
			\node [block, join] {Get image\\from camera};

			% Emit Node
			\node [block, join] {Emit(\textbf{Image})};

			% Image Call Node
			\node [block, join, on chain=going right] {Call all Reaction\\interested
				in \textbf{Image}};

			% Execute Reactions Node
			\node [block, join, on chain=going right] {Execute Reaction(s)\\for
				\textbf{Image}};

			% Process Image Node
			\node [block, join] {Process image};

			% Emit Processed Image node
			\node [block, join] {Emit(ProcessedImage)};

			% Continuation Node
			\node [block, join, on chain=going left] (final) {...\\(System continues)};
		\end{scope}

		\coordinate (setuplineA) at ([xshift=-18em]$ (start) !.5! (runtimeStart) $);
		\coordinate (setuplineB) at ([xshift=18em]$ (start) !.5! (runtimeStart) $);
		\coordinate (setupTextPoint) at ([xshift=11em]$ (start) !.5! (runtimeStart) $);

		%% Setup dividing line and text
		\node [above] at (setupTextPoint) {Pre-Game Setup};
		\node [below] at (setupTextPoint) {Game Time};
		\draw [dashed, ultra thick, shorten >= -0.4cm, shorten <= -0.4cm]
			(setuplineA) -- (setuplineB);

		%% Add headers for the three threads
		\node [header,above=of onevery] (sensorsHeader) {Sensors};
		\node [header,above=of register] {Power Plant};
		\node [header,above=of onimage] (visionHeader) {Vision};

		%% Add the column backgrounds for Sensors and Vision
		\begin{scope}[on background layer]
			\filldraw [gray!15] (sensorsHeader.south west) rectangle
				(sensorsHeader.east |- final.south);
			\filldraw [gray!15] (visionHeader.south west) rectangle
				(visionHeader.east |- final.south);
		\end{scope}
	\end{tikzpicture}
	\end{adjustbox}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Key Functions - Log}
	\begin{itemize}
		\item Q: I'm using std::cout and my output is garbled. (thansk thraeding!)
		\item A: Use Log!
		\item NUClear provides logging out of the box.
		\item You can view logs on a per-reaction basis and they won't be garbled!
		\item Log is easy to use! It supports anything that std::cout can stream.
			Including classes with custom operator$<<$'s
		\item Log levels are set at compile time using a CMake flag.
		\item If you're not using a particular log level there is no performance hit.
	\end{itemize}

	\begin{lstlisting}[language=nuclear]
		int number = 5;
		log<DEBUG>("Your number is: ", number);
	\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Key Functions - Log}
	\begin{itemize}
		\item Five Log Levels: TRACE, DEBUG, INFO, WARN, ERROR, FATAL
		\item When log is called NUClear emits a NUClear::LogMessage that you can Trigger on.
		\item Log takes an infinite number of arguments and simply concatenates them together.
	\end{itemize}

	\begin{lstlisting}[language=nuclear]
		// Assume example has operator<< defined for istream
		MyClass example;
		log<INFO>("Running function with: ", example,
		    " with param ", example.height);
	\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Complete Reactor Example}

	\begin{lstlisting}[language=nuclear]
	// Vision.h
	class Vision : public NUClear::Reactor {
	public:
	    Vision(NUClear::PowerPlant* plant);
	};
	\end{lstlisting}

	\begin{lstlisting}[language=nuclear]
	// Vision.cpp
	Vision::Vision(NUClear::PowerPlant* plant)
	: Reactor(plant) {
	    on<Trigger<Image>>().then(
	    ([this](const Image& image) {
	        // Make a classified image and emit it
	        auto classified = std::make_unique<ClassifiedImage>(makeClassified(image));
	        emit(std::move(classified));
	    });
	}
	\end{lstlisting}
\end{frame}

\subsection{Smart Types}
\begin{frame}[fragile]
	\frametitle{Smart Types - Every}
	\begin{itemize}
		\item The every smart type is used to have an event triggered at a regular interval
		\item The first argument is the number of time units to wait
		\item The second argument is the time unit that we are using
		\begin{itemize}
			\item This is a member of std::chrono::duration (milliseconds, microseconds etc...)
		\end{itemize}
	\end{itemize}

	\begin{lstlisting}[language=nuclear]
	using std::chrono::milliseconds;
	on<Every<100, milliseconds>>>().then([] {
	    // Do something every 100 milliseconds!
	});
	\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Smart Types - Last}
	\begin{itemize}
		\item The last smart type will get you the last N emitted values of a type
		\item The first argument is the number of elements to get (at most)
		\item The second argument is the type of data to get
		\item It will give you as many as the system has (up to a max)
		\item The type of data that you get back is a vector of pointers (the LastList$<$type$>$ is there for convenience)
	\end{itemize}

	\begin{lstlisting}[language=nuclear]
	on<Last<5, Trigger<Image>>>().then([](const LastList<Image>& list) {
	    // LastList is a vector of const pointers to the last 5 Images
	});
	\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Smart Types - Network}
	\begin{itemize}
		\item The Network smart type will get you network events of a particular type
		\item The data will come from all of the other systems on your network
		\item Each Network object contains both the data, and the source of the data
	\end{itemize}

	\begin{lstlisting}[language=nuclear]
	on<Network<BallLocation>>().then([](const Network<BallLocation>& ball) {
	    // We get all the ball locations emitted to the network
	});
	\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Smart Types - Configuration}
	\begin{itemize}
		\item Configuration is a smart type that will read Configuration files from the config directory
		\item Configurations will trigger every time the file is modified
		\item They contain a datatype called config which can be automagically typed to any data it knows about
	\end{itemize}

	\begin{lstlisting}[language=nuclear]

	on<Configuration>("Mine.yaml").then([](const Configuration& config) {
	    // config.name has the name of the file
	    // config.config has our configuration
	});
	\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Smart Types - Configuration}

	\begin{itemize}
		\item Configurations can also be set as directories
		\item In this case they will emit an event for every item in the directory
		\item They will emit events whenever an element is added or modified in that directory
	\end{itemize}

	\begin{lstlisting}[language=nuclear]

	on<Configuration>("scripts/").then([](const Configuration& config) {
	    // config.name has the name of the script
	    // config.config has the script configuration
	});
	\end{lstlisting}
\end{frame}

\subsection{Antipatterns}
\begin{frame}[fragile]
	\frametitle{Infinite Looping Reaction}

	\begin{itemize}
		\item Never do an infinite loop in a reaction
		\item It ties up a thread pool thread and can eventually kill the system
		\item You should always be able to trigger on either an every or another event
		\item In the rare case that you do need to loop forever, use a service thread
	\end{itemize}

	\begin{lstlisting}[language=nuclear]
	on<Trigger<MyData>>().then([](const MyData& data) {
	    // Bad! You've killed a thread pool thread!
	    while(true) {
	        doSomething(data);
	    }
	}
	\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Data Hog}

	\begin{itemize}
		\item Whenever it makes sense, emit data rather then using it
		\item For example, if vision makes a classified image, this could be useful
		\item Rather then immediately using this classified image, we can emit and trigger on it
		\item This way others can use this data as well as us
	\end{itemize}

	\begin{lstlisting}[language=nuclear]
	on<Trigger<Image>>().then([](const Image& image) {

	    // This could be emitted for others to use
	    // Saving them the trouble of recoding or copying code
	    auto classified = makeClassifiedImage(image);

	    auto seenObjects = findObjects(classified)
	}
	\end{lstlisting}
\end{frame}

%----------------------------------------------------------------------------------------
\section{NUClear Powered Robocup}
%----------------------------------------------------------------------------------------
\subsection{Project}
\begin{frame}
	\frametitle{Project Directory Structure}
	\footnotesize
	\begin{itemize}
		\item cmake
		\begin{itemize}
			\footnotesize
			\item Includes - Contains shared CMake functions.
			\item Modules -  Code to help CMake find our dependencies.
			\item Scripts - Scripts used by cmake for build/deploying
		\end{itemize}

		\item doc - Documentation like this one! Mostly LaTeX.
		\item hats - Defines the executable payloads and their modules.
		\item lib - Library dependencies that aren't on apt-get and are easy to build.
		\item modules - NUClear modules/reactors. Subfolders for grouping.

		\item shared - Shared code accessible to all modules
		\begin{itemize}
			\footnotesize
			\item messages - The messages used by modules to communicate.
			\item utility - Shared utility code
			\begin{itemize}
				\footnotesize
				\item configuration - Configuration system tools. New serializable types can be defined here.
				\item file - File utilities
				\item idiom - Classes to assist with implementing C++ idioms
				\item image - Image processing utilities
				\item math - Math utilities
				\item strutil - String utilities
			\end{itemize}
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Build System - Modules}
	\begin{itemize}
		\item The new NUBots system uses CMake as it's build system
		\item It uses it properly unlike the old build system
		\item Each module goes into a directory according to its namespace
		\item A single CMakeLists.txt file is included in the module directory
		\item For most use cases this will contain a single function NUCLEAR\_MODULE()
		\item This will handle everything about the modules construction
		\item In the event that you need access to a library, you pass in the Includes and Libraries
		\begin{itemize}
			\item NUCLEAR\_MODULE(INCLUDES \$\{MY\_INCLUDE\_DIR\} LIBRARIES \$\{MY\_LIBRARY\})
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Build System - Setup}
	\begin{itemize}
		\item The NUBots code is setup to be used in an out of source build
		\item This means that the build directory is separate from the main directory
		\item Make a directory in the source directory (normally called build)
		\item Change to this directory and run CMake ..
		\item This should build a make file (or tell you why it can't)
		\begin{itemize}
			\item The most common reason it will fail is that you are missing a dependency
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Build System - Make}
	\begin{itemize}
		\item There are 3 main make targets that can be called
		\item make
		\begin{itemize}
			\item This will build all of the targets in the project
		\end{itemize}

		\item make install
		\begin{itemize}
			\item You need set the arguments robot=robotip
			\item You can also set config= to one of 3 values
			\begin{itemize}
				\item n or new sends only new configuration files to the robot (the default)
				\item u or update overwrites and sends any new config files to the robot
				\item i or ignore does not try to send configuration files at all
			\end{itemize}
		\end{itemize}

		\item make test
		\begin{itemize}
			\item Runs the unit test for every used module in the system
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Hats}
	\begin{itemize}
		\item Q: "What the hell is a hat?"
		\item A: Hats are the combination of modules that combine to form a single executable.
			The robot can be through of as "putting on it's robocup hat" or "putting on it's marketing hat".
		\item You can define new hats using the CMakeLists.txt in the hats subdirectory.
		\item Each hat has a name and a list of modules you want installed.
			CMake will generate and compile a .cpp file based on the name and modules you specify.
		\item Specification is done using the ADD\_HAT cmake function.
		\item The Configuration module is special due to the crazy template stuff. If you're using it you
			need to make sure to install it first in the list of modules otherwise components that are installed
			before it won't get configured.
	\end{itemize}

	\begin{lstlisting}[language=nuclear-cmake]
		ADD_HAT(NAME name MODULES modules...)
	\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Hats}
	\begin{lstlisting}[language=nuclear-cmake]
		# Add a hat named "PartyDarwin" that parties all day.
		ADD_HAT(
		    NAME partydarwin
		    MODULES
		        Platform::Darwin::HardwareIO
		        PartyDarwin)

		# Add a hat named beatdetector that detects beat.
		# Remember ConfigSystem needs to be installed first.
		ADD_HAT(
		    NAME beatdetector
		    MODULES
		        ConfigSystem
		        Platform::Darwin::HardwareIO
		        AudioInput
		        BeatDetector)

	\end{lstlisting}
\end{frame}

\subsection{Module Examples}
\begin{frame}
	\frametitle{Implemented Module Examples}
	\begin{itemize}
		\item Every example
			\begin{itemize}
				\item PartyDarwin
			\end{itemize}

		\item Last example
			\begin{itemize}
				\item BeatDetector
			\end{itemize}

		\item Configuration example
			\begin{itemize}
				\item Configuration Directory: Script Engine
				\item Configuration File: LinuxCameraStreamer
			\end{itemize}

		\item Service Thread example
			\begin{itemize}
				\item ScriptTuner
			\end{itemize}

		\item Extension example
			\begin{itemize}
				\item ConfigSystem
			\end{itemize}
	\end{itemize}
\end{frame}

\subsection{FYP Final Porting Status}
\begin{frame}
	\frametitle{Ported Modules}
	\begin{itemize}
		\item Platform::Darwin::HardwareIO
			\begin{itemize}
				\item This is the reactor that communicates directly with the hardware
				\item This is a complete rewrite of the poorly coded drivers provided by Robotis
			\end{itemize}

		\item Platform::Darwin::MotionManager
			\begin{itemize}
				\item This is a wrapper around the hardware and allows queuing of waypoints
				\item This module replaces the Actionators from the old system
			\end{itemize}

		\item LinuxCameraStreamer
			\begin{itemize}
				\item Gets a stream of images from the camera using V4L2
				\item Is an upgraded version of the camera class from the old system
			\end{itemize}
		\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Ported Modules}
	\begin{itemize}
		\item ConfigSystem
			\begin{itemize}
				\item Given JSON configuration files, loads them in and distributes them
				\item Based on the new config system in the existing system, however uses NUClear as a transport rather then its callback method
			\end{itemize}

		\item ConsoleLogHandler
			\begin{itemize}
				\item A log handler which handles logs by printing them to the console
				\item This corresponds to using cout in the old system
			\end{itemize}

		\item NUbugger
			\begin{itemize}
				\item Streams NUbugger events the the NUbugger web UI
				\item This is a port of the NUbugger system in the existing code
			\end{itemize}
		\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Ported Modules}
	\begin{itemize}
		\item ScriptEngine
			\begin{itemize}
				\item Given a script, it feeds the waypoints to run it into
				\item This corresponds to the script engine in the existing code
			\end{itemize}

		\item ScriptTuner
			\begin{itemize}
				\item By running this you are able to move the
				\item This is a port of the Script Tuner in the existing system to an NCurses UI
			\end{itemize}

		\item SignalCatcher
			\begin{itemize}
				\item When this module is installed, segfaults and sigints are converted to exceptions and shutdown commands
				\item The existing robot system also captured these signals
			\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{New Modules}
	\begin{itemize}
		\item AudioFileInput
			\begin{itemize}
				\item Reads a file given by the config system in chunks and emits it in real time
			\end{itemize}

		\item AudioInput
			\begin{itemize}
				\item Listens to the audio input from the microphone
			\end{itemize}

		\item BeatDetector
			\begin{itemize}
				\item Using a stream of audio, detects the beat frequency of the music
			\end{itemize}

		\item eSpeak
			\begin{itemize}
				\item By emitting a Say event, this uses eSpeak to perform text to speech
			\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{New Modules}
	\begin{itemize}
		\item PartyDarwin
			\begin{itemize}
				\item This module constantly flashes the Eye LEDs randomly for testing if the program has crashed
			\end{itemize}

		\item ScriptRunner
			\begin{itemize}
				\item This is the UI for the script-runner hat, which allows chaining scripts to be run by name
			\end{itemize}

		\item DanceEngine
			\begin{itemize}
				\item This is the controller to make the darwin perform dances. It randomly selects a dance from its bank of scripts
			\end{itemize}
	\end{itemize}
\end{frame}

\end{document}
