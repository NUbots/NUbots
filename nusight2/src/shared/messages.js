/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
import * as $protobuf from "protobufjs/minimal";

// Common aliases
const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
const $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

export const message = $root.message = (() => {

    /**
     * Namespace message.
     * @exports message
     * @namespace
     */
    const message = {};

    message.actuation = (function() {

        /**
         * Namespace actuation.
         * @memberof message
         * @namespace
         */
        const actuation = {};

        /**
         * BodySide enum.
         * @name message.actuation.BodySide
         * @enum {number}
         * @property {number} LEFT=0 LEFT value
         * @property {number} RIGHT=1 RIGHT value
         */
        actuation.BodySide = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "LEFT"] = 0;
            values[valuesById[1] = "RIGHT"] = 1;
            return values;
        })();

        actuation.KinematicsModel = (function() {

            /**
             * Properties of a KinematicsModel.
             * @memberof message.actuation
             * @interface IKinematicsModel
             * @property {message.actuation.KinematicsModel.ILeg|null} [leg] KinematicsModel leg
             * @property {message.actuation.KinematicsModel.IHead|null} [head] KinematicsModel head
             * @property {message.actuation.KinematicsModel.IArm|null} [arm] KinematicsModel arm
             * @property {message.actuation.KinematicsModel.IMassModel|null} [massModel] KinematicsModel massModel
             * @property {message.actuation.KinematicsModel.ITensorModel|null} [tensorModel] KinematicsModel tensorModel
             */

            /**
             * Constructs a new KinematicsModel.
             * @memberof message.actuation
             * @classdesc Contains lots of kinematics config measurements and transforms.
             * See `KinematicsConfiguration.yaml` for more detail on a particular variable.
             * Convention: all values positive
             * @implements IKinematicsModel
             * @constructor
             * @param {message.actuation.IKinematicsModel=} [properties] Properties to set
             */
            function KinematicsModel(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KinematicsModel leg.
             * @member {message.actuation.KinematicsModel.ILeg|null|undefined} leg
             * @memberof message.actuation.KinematicsModel
             * @instance
             */
            KinematicsModel.prototype.leg = null;

            /**
             * KinematicsModel head.
             * @member {message.actuation.KinematicsModel.IHead|null|undefined} head
             * @memberof message.actuation.KinematicsModel
             * @instance
             */
            KinematicsModel.prototype.head = null;

            /**
             * KinematicsModel arm.
             * @member {message.actuation.KinematicsModel.IArm|null|undefined} arm
             * @memberof message.actuation.KinematicsModel
             * @instance
             */
            KinematicsModel.prototype.arm = null;

            /**
             * KinematicsModel massModel.
             * @member {message.actuation.KinematicsModel.IMassModel|null|undefined} massModel
             * @memberof message.actuation.KinematicsModel
             * @instance
             */
            KinematicsModel.prototype.massModel = null;

            /**
             * KinematicsModel tensorModel.
             * @member {message.actuation.KinematicsModel.ITensorModel|null|undefined} tensorModel
             * @memberof message.actuation.KinematicsModel
             * @instance
             */
            KinematicsModel.prototype.tensorModel = null;

            /**
             * Encodes the specified KinematicsModel message. Does not implicitly {@link message.actuation.KinematicsModel.verify|verify} messages.
             * @function encode
             * @memberof message.actuation.KinematicsModel
             * @static
             * @param {message.actuation.IKinematicsModel} message KinematicsModel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KinematicsModel.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.leg != null && Object.hasOwnProperty.call(message, "leg"))
                    $root.message.actuation.KinematicsModel.Leg.encode(message.leg, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.head != null && Object.hasOwnProperty.call(message, "head"))
                    $root.message.actuation.KinematicsModel.Head.encode(message.head, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.arm != null && Object.hasOwnProperty.call(message, "arm"))
                    $root.message.actuation.KinematicsModel.Arm.encode(message.arm, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.massModel != null && Object.hasOwnProperty.call(message, "massModel"))
                    $root.message.actuation.KinematicsModel.MassModel.encode(message.massModel, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.tensorModel != null && Object.hasOwnProperty.call(message, "tensorModel"))
                    $root.message.actuation.KinematicsModel.TensorModel.encode(message.tensorModel, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a KinematicsModel message from the specified reader or buffer.
             * @function decode
             * @memberof message.actuation.KinematicsModel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.actuation.KinematicsModel} KinematicsModel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KinematicsModel.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.actuation.KinematicsModel();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.leg = $root.message.actuation.KinematicsModel.Leg.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.head = $root.message.actuation.KinematicsModel.Head.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.arm = $root.message.actuation.KinematicsModel.Arm.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.massModel = $root.message.actuation.KinematicsModel.MassModel.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.tensorModel = $root.message.actuation.KinematicsModel.TensorModel.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            KinematicsModel.Leg = (function() {

                /**
                 * Properties of a Leg.
                 * @memberof message.actuation.KinematicsModel
                 * @interface ILeg
                 * @property {number|null} [HIP_OFFSET_X] Leg HIP_OFFSET_X
                 * @property {number|null} [HIP_OFFSET_Y] Leg HIP_OFFSET_Y
                 * @property {number|null} [HIP_OFFSET_Z] Leg HIP_OFFSET_Z
                 * @property {number|null} [UPPER_LEG_LENGTH] Leg UPPER_LEG_LENGTH
                 * @property {number|null} [LOWER_LEG_LENGTH] Leg LOWER_LEG_LENGTH
                 * @property {number|null} [FOOT_HEIGHT] Leg FOOT_HEIGHT
                 * @property {number|null} [FOOT_LENGTH] Leg FOOT_LENGTH
                 * @property {number|null} [TOE_LENGTH] Leg TOE_LENGTH
                 * @property {number|null} [HEEL_LENGTH] Leg HEEL_LENGTH
                 * @property {number|null} [FOOT_WIDTH] Leg FOOT_WIDTH
                 * @property {number|null} [FOOT_CENTRE_TO_ANKLE_CENTRE] Leg FOOT_CENTRE_TO_ANKLE_CENTRE
                 * @property {number|null} [LENGTH_BETWEEN_LEGS] Leg LENGTH_BETWEEN_LEGS
                 * @property {number|null} [LEFT_TO_RIGHT_HIP_YAW] Leg LEFT_TO_RIGHT_HIP_YAW
                 * @property {number|null} [LEFT_TO_RIGHT_HIP_ROLL] Leg LEFT_TO_RIGHT_HIP_ROLL
                 * @property {number|null} [LEFT_TO_RIGHT_HIP_PITCH] Leg LEFT_TO_RIGHT_HIP_PITCH
                 * @property {number|null} [LEFT_TO_RIGHT_KNEE] Leg LEFT_TO_RIGHT_KNEE
                 * @property {number|null} [LEFT_TO_RIGHT_ANKLE_PITCH] Leg LEFT_TO_RIGHT_ANKLE_PITCH
                 * @property {number|null} [LEFT_TO_RIGHT_ANKLE_ROLL] Leg LEFT_TO_RIGHT_ANKLE_ROLL
                 */

                /**
                 * Constructs a new Leg.
                 * @memberof message.actuation.KinematicsModel
                 * @classdesc Represents a Leg.
                 * @implements ILeg
                 * @constructor
                 * @param {message.actuation.KinematicsModel.ILeg=} [properties] Properties to set
                 */
                function Leg(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Leg HIP_OFFSET_X.
                 * @member {number} HIP_OFFSET_X
                 * @memberof message.actuation.KinematicsModel.Leg
                 * @instance
                 */
                Leg.prototype.HIP_OFFSET_X = 0;

                /**
                 * Leg HIP_OFFSET_Y.
                 * @member {number} HIP_OFFSET_Y
                 * @memberof message.actuation.KinematicsModel.Leg
                 * @instance
                 */
                Leg.prototype.HIP_OFFSET_Y = 0;

                /**
                 * Leg HIP_OFFSET_Z.
                 * @member {number} HIP_OFFSET_Z
                 * @memberof message.actuation.KinematicsModel.Leg
                 * @instance
                 */
                Leg.prototype.HIP_OFFSET_Z = 0;

                /**
                 * Leg UPPER_LEG_LENGTH.
                 * @member {number} UPPER_LEG_LENGTH
                 * @memberof message.actuation.KinematicsModel.Leg
                 * @instance
                 */
                Leg.prototype.UPPER_LEG_LENGTH = 0;

                /**
                 * Leg LOWER_LEG_LENGTH.
                 * @member {number} LOWER_LEG_LENGTH
                 * @memberof message.actuation.KinematicsModel.Leg
                 * @instance
                 */
                Leg.prototype.LOWER_LEG_LENGTH = 0;

                /**
                 * Leg FOOT_HEIGHT.
                 * @member {number} FOOT_HEIGHT
                 * @memberof message.actuation.KinematicsModel.Leg
                 * @instance
                 */
                Leg.prototype.FOOT_HEIGHT = 0;

                /**
                 * Leg FOOT_LENGTH.
                 * @member {number} FOOT_LENGTH
                 * @memberof message.actuation.KinematicsModel.Leg
                 * @instance
                 */
                Leg.prototype.FOOT_LENGTH = 0;

                /**
                 * Leg TOE_LENGTH.
                 * @member {number} TOE_LENGTH
                 * @memberof message.actuation.KinematicsModel.Leg
                 * @instance
                 */
                Leg.prototype.TOE_LENGTH = 0;

                /**
                 * Leg HEEL_LENGTH.
                 * @member {number} HEEL_LENGTH
                 * @memberof message.actuation.KinematicsModel.Leg
                 * @instance
                 */
                Leg.prototype.HEEL_LENGTH = 0;

                /**
                 * Leg FOOT_WIDTH.
                 * @member {number} FOOT_WIDTH
                 * @memberof message.actuation.KinematicsModel.Leg
                 * @instance
                 */
                Leg.prototype.FOOT_WIDTH = 0;

                /**
                 * Leg FOOT_CENTRE_TO_ANKLE_CENTRE.
                 * @member {number} FOOT_CENTRE_TO_ANKLE_CENTRE
                 * @memberof message.actuation.KinematicsModel.Leg
                 * @instance
                 */
                Leg.prototype.FOOT_CENTRE_TO_ANKLE_CENTRE = 0;

                /**
                 * Leg LENGTH_BETWEEN_LEGS.
                 * @member {number} LENGTH_BETWEEN_LEGS
                 * @memberof message.actuation.KinematicsModel.Leg
                 * @instance
                 */
                Leg.prototype.LENGTH_BETWEEN_LEGS = 0;

                /**
                 * Leg LEFT_TO_RIGHT_HIP_YAW.
                 * @member {number} LEFT_TO_RIGHT_HIP_YAW
                 * @memberof message.actuation.KinematicsModel.Leg
                 * @instance
                 */
                Leg.prototype.LEFT_TO_RIGHT_HIP_YAW = 0;

                /**
                 * Leg LEFT_TO_RIGHT_HIP_ROLL.
                 * @member {number} LEFT_TO_RIGHT_HIP_ROLL
                 * @memberof message.actuation.KinematicsModel.Leg
                 * @instance
                 */
                Leg.prototype.LEFT_TO_RIGHT_HIP_ROLL = 0;

                /**
                 * Leg LEFT_TO_RIGHT_HIP_PITCH.
                 * @member {number} LEFT_TO_RIGHT_HIP_PITCH
                 * @memberof message.actuation.KinematicsModel.Leg
                 * @instance
                 */
                Leg.prototype.LEFT_TO_RIGHT_HIP_PITCH = 0;

                /**
                 * Leg LEFT_TO_RIGHT_KNEE.
                 * @member {number} LEFT_TO_RIGHT_KNEE
                 * @memberof message.actuation.KinematicsModel.Leg
                 * @instance
                 */
                Leg.prototype.LEFT_TO_RIGHT_KNEE = 0;

                /**
                 * Leg LEFT_TO_RIGHT_ANKLE_PITCH.
                 * @member {number} LEFT_TO_RIGHT_ANKLE_PITCH
                 * @memberof message.actuation.KinematicsModel.Leg
                 * @instance
                 */
                Leg.prototype.LEFT_TO_RIGHT_ANKLE_PITCH = 0;

                /**
                 * Leg LEFT_TO_RIGHT_ANKLE_ROLL.
                 * @member {number} LEFT_TO_RIGHT_ANKLE_ROLL
                 * @memberof message.actuation.KinematicsModel.Leg
                 * @instance
                 */
                Leg.prototype.LEFT_TO_RIGHT_ANKLE_ROLL = 0;

                /**
                 * Encodes the specified Leg message. Does not implicitly {@link message.actuation.KinematicsModel.Leg.verify|verify} messages.
                 * @function encode
                 * @memberof message.actuation.KinematicsModel.Leg
                 * @static
                 * @param {message.actuation.KinematicsModel.ILeg} message Leg message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Leg.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.HIP_OFFSET_X != null && Object.hasOwnProperty.call(message, "HIP_OFFSET_X"))
                        writer.uint32(/* id 1, wireType 5 =*/13).float(message.HIP_OFFSET_X);
                    if (message.HIP_OFFSET_Y != null && Object.hasOwnProperty.call(message, "HIP_OFFSET_Y"))
                        writer.uint32(/* id 2, wireType 5 =*/21).float(message.HIP_OFFSET_Y);
                    if (message.HIP_OFFSET_Z != null && Object.hasOwnProperty.call(message, "HIP_OFFSET_Z"))
                        writer.uint32(/* id 3, wireType 5 =*/29).float(message.HIP_OFFSET_Z);
                    if (message.UPPER_LEG_LENGTH != null && Object.hasOwnProperty.call(message, "UPPER_LEG_LENGTH"))
                        writer.uint32(/* id 4, wireType 5 =*/37).float(message.UPPER_LEG_LENGTH);
                    if (message.LOWER_LEG_LENGTH != null && Object.hasOwnProperty.call(message, "LOWER_LEG_LENGTH"))
                        writer.uint32(/* id 5, wireType 5 =*/45).float(message.LOWER_LEG_LENGTH);
                    if (message.FOOT_HEIGHT != null && Object.hasOwnProperty.call(message, "FOOT_HEIGHT"))
                        writer.uint32(/* id 6, wireType 5 =*/53).float(message.FOOT_HEIGHT);
                    if (message.FOOT_LENGTH != null && Object.hasOwnProperty.call(message, "FOOT_LENGTH"))
                        writer.uint32(/* id 7, wireType 5 =*/61).float(message.FOOT_LENGTH);
                    if (message.TOE_LENGTH != null && Object.hasOwnProperty.call(message, "TOE_LENGTH"))
                        writer.uint32(/* id 8, wireType 5 =*/69).float(message.TOE_LENGTH);
                    if (message.HEEL_LENGTH != null && Object.hasOwnProperty.call(message, "HEEL_LENGTH"))
                        writer.uint32(/* id 9, wireType 5 =*/77).float(message.HEEL_LENGTH);
                    if (message.FOOT_WIDTH != null && Object.hasOwnProperty.call(message, "FOOT_WIDTH"))
                        writer.uint32(/* id 10, wireType 5 =*/85).float(message.FOOT_WIDTH);
                    if (message.FOOT_CENTRE_TO_ANKLE_CENTRE != null && Object.hasOwnProperty.call(message, "FOOT_CENTRE_TO_ANKLE_CENTRE"))
                        writer.uint32(/* id 11, wireType 5 =*/93).float(message.FOOT_CENTRE_TO_ANKLE_CENTRE);
                    if (message.LENGTH_BETWEEN_LEGS != null && Object.hasOwnProperty.call(message, "LENGTH_BETWEEN_LEGS"))
                        writer.uint32(/* id 12, wireType 5 =*/101).float(message.LENGTH_BETWEEN_LEGS);
                    if (message.LEFT_TO_RIGHT_HIP_YAW != null && Object.hasOwnProperty.call(message, "LEFT_TO_RIGHT_HIP_YAW"))
                        writer.uint32(/* id 13, wireType 0 =*/104).int32(message.LEFT_TO_RIGHT_HIP_YAW);
                    if (message.LEFT_TO_RIGHT_HIP_ROLL != null && Object.hasOwnProperty.call(message, "LEFT_TO_RIGHT_HIP_ROLL"))
                        writer.uint32(/* id 14, wireType 0 =*/112).int32(message.LEFT_TO_RIGHT_HIP_ROLL);
                    if (message.LEFT_TO_RIGHT_HIP_PITCH != null && Object.hasOwnProperty.call(message, "LEFT_TO_RIGHT_HIP_PITCH"))
                        writer.uint32(/* id 15, wireType 0 =*/120).int32(message.LEFT_TO_RIGHT_HIP_PITCH);
                    if (message.LEFT_TO_RIGHT_KNEE != null && Object.hasOwnProperty.call(message, "LEFT_TO_RIGHT_KNEE"))
                        writer.uint32(/* id 16, wireType 0 =*/128).int32(message.LEFT_TO_RIGHT_KNEE);
                    if (message.LEFT_TO_RIGHT_ANKLE_PITCH != null && Object.hasOwnProperty.call(message, "LEFT_TO_RIGHT_ANKLE_PITCH"))
                        writer.uint32(/* id 17, wireType 0 =*/136).int32(message.LEFT_TO_RIGHT_ANKLE_PITCH);
                    if (message.LEFT_TO_RIGHT_ANKLE_ROLL != null && Object.hasOwnProperty.call(message, "LEFT_TO_RIGHT_ANKLE_ROLL"))
                        writer.uint32(/* id 18, wireType 0 =*/144).int32(message.LEFT_TO_RIGHT_ANKLE_ROLL);
                    return writer;
                };

                /**
                 * Decodes a Leg message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.actuation.KinematicsModel.Leg
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.actuation.KinematicsModel.Leg} Leg
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Leg.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.actuation.KinematicsModel.Leg();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.HIP_OFFSET_X = reader.float();
                            break;
                        case 2:
                            message.HIP_OFFSET_Y = reader.float();
                            break;
                        case 3:
                            message.HIP_OFFSET_Z = reader.float();
                            break;
                        case 4:
                            message.UPPER_LEG_LENGTH = reader.float();
                            break;
                        case 5:
                            message.LOWER_LEG_LENGTH = reader.float();
                            break;
                        case 6:
                            message.FOOT_HEIGHT = reader.float();
                            break;
                        case 7:
                            message.FOOT_LENGTH = reader.float();
                            break;
                        case 8:
                            message.TOE_LENGTH = reader.float();
                            break;
                        case 9:
                            message.HEEL_LENGTH = reader.float();
                            break;
                        case 10:
                            message.FOOT_WIDTH = reader.float();
                            break;
                        case 11:
                            message.FOOT_CENTRE_TO_ANKLE_CENTRE = reader.float();
                            break;
                        case 12:
                            message.LENGTH_BETWEEN_LEGS = reader.float();
                            break;
                        case 13:
                            message.LEFT_TO_RIGHT_HIP_YAW = reader.int32();
                            break;
                        case 14:
                            message.LEFT_TO_RIGHT_HIP_ROLL = reader.int32();
                            break;
                        case 15:
                            message.LEFT_TO_RIGHT_HIP_PITCH = reader.int32();
                            break;
                        case 16:
                            message.LEFT_TO_RIGHT_KNEE = reader.int32();
                            break;
                        case 17:
                            message.LEFT_TO_RIGHT_ANKLE_PITCH = reader.int32();
                            break;
                        case 18:
                            message.LEFT_TO_RIGHT_ANKLE_ROLL = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return Leg;
            })();

            KinematicsModel.Head = (function() {

                /**
                 * Properties of a Head.
                 * @memberof message.actuation.KinematicsModel
                 * @interface IHead
                 * @property {number|null} [NECK_BASE_POS_FROM_ORIGIN_X] Head NECK_BASE_POS_FROM_ORIGIN_X
                 * @property {number|null} [NECK_BASE_POS_FROM_ORIGIN_Y] Head NECK_BASE_POS_FROM_ORIGIN_Y
                 * @property {number|null} [NECK_BASE_POS_FROM_ORIGIN_Z] Head NECK_BASE_POS_FROM_ORIGIN_Z
                 * @property {number|null} [NECK_LENGTH] Head NECK_LENGTH
                 * @property {number|null} [NECK_TO_CAMERA_X] Head NECK_TO_CAMERA_X
                 * @property {number|null} [NECK_TO_CAMERA_Y] Head NECK_TO_CAMERA_Y
                 * @property {number|null} [NECK_TO_CAMERA_Z] Head NECK_TO_CAMERA_Z
                 * @property {number|null} [CAMERA_DECLINATION_ANGLE_OFFSET] Head CAMERA_DECLINATION_ANGLE_OFFSET
                 * @property {number|null} [INTERPUPILLARY_DISTANCE] Head INTERPUPILLARY_DISTANCE
                 * @property {number|null} [MAX_YAW] Head MAX_YAW
                 * @property {number|null} [MIN_YAW] Head MIN_YAW
                 * @property {number|null} [MAX_PITCH] Head MAX_PITCH
                 * @property {number|null} [MIN_PITCH] Head MIN_PITCH
                 */

                /**
                 * Constructs a new Head.
                 * @memberof message.actuation.KinematicsModel
                 * @classdesc Represents a Head.
                 * @implements IHead
                 * @constructor
                 * @param {message.actuation.KinematicsModel.IHead=} [properties] Properties to set
                 */
                function Head(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Head NECK_BASE_POS_FROM_ORIGIN_X.
                 * @member {number} NECK_BASE_POS_FROM_ORIGIN_X
                 * @memberof message.actuation.KinematicsModel.Head
                 * @instance
                 */
                Head.prototype.NECK_BASE_POS_FROM_ORIGIN_X = 0;

                /**
                 * Head NECK_BASE_POS_FROM_ORIGIN_Y.
                 * @member {number} NECK_BASE_POS_FROM_ORIGIN_Y
                 * @memberof message.actuation.KinematicsModel.Head
                 * @instance
                 */
                Head.prototype.NECK_BASE_POS_FROM_ORIGIN_Y = 0;

                /**
                 * Head NECK_BASE_POS_FROM_ORIGIN_Z.
                 * @member {number} NECK_BASE_POS_FROM_ORIGIN_Z
                 * @memberof message.actuation.KinematicsModel.Head
                 * @instance
                 */
                Head.prototype.NECK_BASE_POS_FROM_ORIGIN_Z = 0;

                /**
                 * Head NECK_LENGTH.
                 * @member {number} NECK_LENGTH
                 * @memberof message.actuation.KinematicsModel.Head
                 * @instance
                 */
                Head.prototype.NECK_LENGTH = 0;

                /**
                 * Head NECK_TO_CAMERA_X.
                 * @member {number} NECK_TO_CAMERA_X
                 * @memberof message.actuation.KinematicsModel.Head
                 * @instance
                 */
                Head.prototype.NECK_TO_CAMERA_X = 0;

                /**
                 * Head NECK_TO_CAMERA_Y.
                 * @member {number} NECK_TO_CAMERA_Y
                 * @memberof message.actuation.KinematicsModel.Head
                 * @instance
                 */
                Head.prototype.NECK_TO_CAMERA_Y = 0;

                /**
                 * Head NECK_TO_CAMERA_Z.
                 * @member {number} NECK_TO_CAMERA_Z
                 * @memberof message.actuation.KinematicsModel.Head
                 * @instance
                 */
                Head.prototype.NECK_TO_CAMERA_Z = 0;

                /**
                 * Head CAMERA_DECLINATION_ANGLE_OFFSET.
                 * @member {number} CAMERA_DECLINATION_ANGLE_OFFSET
                 * @memberof message.actuation.KinematicsModel.Head
                 * @instance
                 */
                Head.prototype.CAMERA_DECLINATION_ANGLE_OFFSET = 0;

                /**
                 * Head INTERPUPILLARY_DISTANCE.
                 * @member {number} INTERPUPILLARY_DISTANCE
                 * @memberof message.actuation.KinematicsModel.Head
                 * @instance
                 */
                Head.prototype.INTERPUPILLARY_DISTANCE = 0;

                /**
                 * Head MAX_YAW.
                 * @member {number} MAX_YAW
                 * @memberof message.actuation.KinematicsModel.Head
                 * @instance
                 */
                Head.prototype.MAX_YAW = 0;

                /**
                 * Head MIN_YAW.
                 * @member {number} MIN_YAW
                 * @memberof message.actuation.KinematicsModel.Head
                 * @instance
                 */
                Head.prototype.MIN_YAW = 0;

                /**
                 * Head MAX_PITCH.
                 * @member {number} MAX_PITCH
                 * @memberof message.actuation.KinematicsModel.Head
                 * @instance
                 */
                Head.prototype.MAX_PITCH = 0;

                /**
                 * Head MIN_PITCH.
                 * @member {number} MIN_PITCH
                 * @memberof message.actuation.KinematicsModel.Head
                 * @instance
                 */
                Head.prototype.MIN_PITCH = 0;

                /**
                 * Encodes the specified Head message. Does not implicitly {@link message.actuation.KinematicsModel.Head.verify|verify} messages.
                 * @function encode
                 * @memberof message.actuation.KinematicsModel.Head
                 * @static
                 * @param {message.actuation.KinematicsModel.IHead} message Head message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Head.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.NECK_BASE_POS_FROM_ORIGIN_X != null && Object.hasOwnProperty.call(message, "NECK_BASE_POS_FROM_ORIGIN_X"))
                        writer.uint32(/* id 1, wireType 5 =*/13).float(message.NECK_BASE_POS_FROM_ORIGIN_X);
                    if (message.NECK_BASE_POS_FROM_ORIGIN_Y != null && Object.hasOwnProperty.call(message, "NECK_BASE_POS_FROM_ORIGIN_Y"))
                        writer.uint32(/* id 2, wireType 5 =*/21).float(message.NECK_BASE_POS_FROM_ORIGIN_Y);
                    if (message.NECK_BASE_POS_FROM_ORIGIN_Z != null && Object.hasOwnProperty.call(message, "NECK_BASE_POS_FROM_ORIGIN_Z"))
                        writer.uint32(/* id 3, wireType 5 =*/29).float(message.NECK_BASE_POS_FROM_ORIGIN_Z);
                    if (message.NECK_LENGTH != null && Object.hasOwnProperty.call(message, "NECK_LENGTH"))
                        writer.uint32(/* id 4, wireType 5 =*/37).float(message.NECK_LENGTH);
                    if (message.NECK_TO_CAMERA_X != null && Object.hasOwnProperty.call(message, "NECK_TO_CAMERA_X"))
                        writer.uint32(/* id 5, wireType 5 =*/45).float(message.NECK_TO_CAMERA_X);
                    if (message.NECK_TO_CAMERA_Y != null && Object.hasOwnProperty.call(message, "NECK_TO_CAMERA_Y"))
                        writer.uint32(/* id 6, wireType 5 =*/53).float(message.NECK_TO_CAMERA_Y);
                    if (message.NECK_TO_CAMERA_Z != null && Object.hasOwnProperty.call(message, "NECK_TO_CAMERA_Z"))
                        writer.uint32(/* id 7, wireType 5 =*/61).float(message.NECK_TO_CAMERA_Z);
                    if (message.CAMERA_DECLINATION_ANGLE_OFFSET != null && Object.hasOwnProperty.call(message, "CAMERA_DECLINATION_ANGLE_OFFSET"))
                        writer.uint32(/* id 8, wireType 5 =*/69).float(message.CAMERA_DECLINATION_ANGLE_OFFSET);
                    if (message.MAX_YAW != null && Object.hasOwnProperty.call(message, "MAX_YAW"))
                        writer.uint32(/* id 9, wireType 5 =*/77).float(message.MAX_YAW);
                    if (message.MIN_YAW != null && Object.hasOwnProperty.call(message, "MIN_YAW"))
                        writer.uint32(/* id 10, wireType 5 =*/85).float(message.MIN_YAW);
                    if (message.MAX_PITCH != null && Object.hasOwnProperty.call(message, "MAX_PITCH"))
                        writer.uint32(/* id 11, wireType 5 =*/93).float(message.MAX_PITCH);
                    if (message.MIN_PITCH != null && Object.hasOwnProperty.call(message, "MIN_PITCH"))
                        writer.uint32(/* id 12, wireType 5 =*/101).float(message.MIN_PITCH);
                    if (message.INTERPUPILLARY_DISTANCE != null && Object.hasOwnProperty.call(message, "INTERPUPILLARY_DISTANCE"))
                        writer.uint32(/* id 13, wireType 5 =*/109).float(message.INTERPUPILLARY_DISTANCE);
                    return writer;
                };

                /**
                 * Decodes a Head message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.actuation.KinematicsModel.Head
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.actuation.KinematicsModel.Head} Head
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Head.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.actuation.KinematicsModel.Head();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.NECK_BASE_POS_FROM_ORIGIN_X = reader.float();
                            break;
                        case 2:
                            message.NECK_BASE_POS_FROM_ORIGIN_Y = reader.float();
                            break;
                        case 3:
                            message.NECK_BASE_POS_FROM_ORIGIN_Z = reader.float();
                            break;
                        case 4:
                            message.NECK_LENGTH = reader.float();
                            break;
                        case 5:
                            message.NECK_TO_CAMERA_X = reader.float();
                            break;
                        case 6:
                            message.NECK_TO_CAMERA_Y = reader.float();
                            break;
                        case 7:
                            message.NECK_TO_CAMERA_Z = reader.float();
                            break;
                        case 8:
                            message.CAMERA_DECLINATION_ANGLE_OFFSET = reader.float();
                            break;
                        case 13:
                            message.INTERPUPILLARY_DISTANCE = reader.float();
                            break;
                        case 9:
                            message.MAX_YAW = reader.float();
                            break;
                        case 10:
                            message.MIN_YAW = reader.float();
                            break;
                        case 11:
                            message.MAX_PITCH = reader.float();
                            break;
                        case 12:
                            message.MIN_PITCH = reader.float();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return Head;
            })();

            KinematicsModel.Arm = (function() {

                /**
                 * Properties of an Arm.
                 * @memberof message.actuation.KinematicsModel
                 * @interface IArm
                 * @property {number|null} [DISTANCE_BETWEEN_SHOULDERS] Arm DISTANCE_BETWEEN_SHOULDERS
                 * @property {number|null} [SHOULDER_Z_OFFSET] Arm SHOULDER_Z_OFFSET
                 * @property {number|null} [SHOULDER_X_OFFSET] Arm SHOULDER_X_OFFSET
                 * @property {number|null} [SHOULDER_LENGTH] Arm SHOULDER_LENGTH
                 * @property {number|null} [SHOULDER_WIDTH] Arm SHOULDER_WIDTH
                 * @property {number|null} [SHOULDER_HEIGHT] Arm SHOULDER_HEIGHT
                 * @property {number|null} [UPPER_ARM_LENGTH] Arm UPPER_ARM_LENGTH
                 * @property {number|null} [UPPER_ARM_Y_OFFSET] Arm UPPER_ARM_Y_OFFSET
                 * @property {number|null} [UPPER_ARM_X_OFFSET] Arm UPPER_ARM_X_OFFSET
                 * @property {number|null} [LOWER_ARM_LENGTH] Arm LOWER_ARM_LENGTH
                 * @property {number|null} [LOWER_ARM_Y_OFFSET] Arm LOWER_ARM_Y_OFFSET
                 * @property {number|null} [LOWER_ARM_Z_OFFSET] Arm LOWER_ARM_Z_OFFSET
                 */

                /**
                 * Constructs a new Arm.
                 * @memberof message.actuation.KinematicsModel
                 * @classdesc Represents an Arm.
                 * @implements IArm
                 * @constructor
                 * @param {message.actuation.KinematicsModel.IArm=} [properties] Properties to set
                 */
                function Arm(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Arm DISTANCE_BETWEEN_SHOULDERS.
                 * @member {number} DISTANCE_BETWEEN_SHOULDERS
                 * @memberof message.actuation.KinematicsModel.Arm
                 * @instance
                 */
                Arm.prototype.DISTANCE_BETWEEN_SHOULDERS = 0;

                /**
                 * Arm SHOULDER_Z_OFFSET.
                 * @member {number} SHOULDER_Z_OFFSET
                 * @memberof message.actuation.KinematicsModel.Arm
                 * @instance
                 */
                Arm.prototype.SHOULDER_Z_OFFSET = 0;

                /**
                 * Arm SHOULDER_X_OFFSET.
                 * @member {number} SHOULDER_X_OFFSET
                 * @memberof message.actuation.KinematicsModel.Arm
                 * @instance
                 */
                Arm.prototype.SHOULDER_X_OFFSET = 0;

                /**
                 * Arm SHOULDER_LENGTH.
                 * @member {number} SHOULDER_LENGTH
                 * @memberof message.actuation.KinematicsModel.Arm
                 * @instance
                 */
                Arm.prototype.SHOULDER_LENGTH = 0;

                /**
                 * Arm SHOULDER_WIDTH.
                 * @member {number} SHOULDER_WIDTH
                 * @memberof message.actuation.KinematicsModel.Arm
                 * @instance
                 */
                Arm.prototype.SHOULDER_WIDTH = 0;

                /**
                 * Arm SHOULDER_HEIGHT.
                 * @member {number} SHOULDER_HEIGHT
                 * @memberof message.actuation.KinematicsModel.Arm
                 * @instance
                 */
                Arm.prototype.SHOULDER_HEIGHT = 0;

                /**
                 * Arm UPPER_ARM_LENGTH.
                 * @member {number} UPPER_ARM_LENGTH
                 * @memberof message.actuation.KinematicsModel.Arm
                 * @instance
                 */
                Arm.prototype.UPPER_ARM_LENGTH = 0;

                /**
                 * Arm UPPER_ARM_Y_OFFSET.
                 * @member {number} UPPER_ARM_Y_OFFSET
                 * @memberof message.actuation.KinematicsModel.Arm
                 * @instance
                 */
                Arm.prototype.UPPER_ARM_Y_OFFSET = 0;

                /**
                 * Arm UPPER_ARM_X_OFFSET.
                 * @member {number} UPPER_ARM_X_OFFSET
                 * @memberof message.actuation.KinematicsModel.Arm
                 * @instance
                 */
                Arm.prototype.UPPER_ARM_X_OFFSET = 0;

                /**
                 * Arm LOWER_ARM_LENGTH.
                 * @member {number} LOWER_ARM_LENGTH
                 * @memberof message.actuation.KinematicsModel.Arm
                 * @instance
                 */
                Arm.prototype.LOWER_ARM_LENGTH = 0;

                /**
                 * Arm LOWER_ARM_Y_OFFSET.
                 * @member {number} LOWER_ARM_Y_OFFSET
                 * @memberof message.actuation.KinematicsModel.Arm
                 * @instance
                 */
                Arm.prototype.LOWER_ARM_Y_OFFSET = 0;

                /**
                 * Arm LOWER_ARM_Z_OFFSET.
                 * @member {number} LOWER_ARM_Z_OFFSET
                 * @memberof message.actuation.KinematicsModel.Arm
                 * @instance
                 */
                Arm.prototype.LOWER_ARM_Z_OFFSET = 0;

                /**
                 * Encodes the specified Arm message. Does not implicitly {@link message.actuation.KinematicsModel.Arm.verify|verify} messages.
                 * @function encode
                 * @memberof message.actuation.KinematicsModel.Arm
                 * @static
                 * @param {message.actuation.KinematicsModel.IArm} message Arm message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Arm.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.DISTANCE_BETWEEN_SHOULDERS != null && Object.hasOwnProperty.call(message, "DISTANCE_BETWEEN_SHOULDERS"))
                        writer.uint32(/* id 1, wireType 5 =*/13).float(message.DISTANCE_BETWEEN_SHOULDERS);
                    if (message.SHOULDER_Z_OFFSET != null && Object.hasOwnProperty.call(message, "SHOULDER_Z_OFFSET"))
                        writer.uint32(/* id 2, wireType 5 =*/21).float(message.SHOULDER_Z_OFFSET);
                    if (message.SHOULDER_X_OFFSET != null && Object.hasOwnProperty.call(message, "SHOULDER_X_OFFSET"))
                        writer.uint32(/* id 3, wireType 5 =*/29).float(message.SHOULDER_X_OFFSET);
                    if (message.SHOULDER_LENGTH != null && Object.hasOwnProperty.call(message, "SHOULDER_LENGTH"))
                        writer.uint32(/* id 4, wireType 5 =*/37).float(message.SHOULDER_LENGTH);
                    if (message.SHOULDER_WIDTH != null && Object.hasOwnProperty.call(message, "SHOULDER_WIDTH"))
                        writer.uint32(/* id 5, wireType 5 =*/45).float(message.SHOULDER_WIDTH);
                    if (message.SHOULDER_HEIGHT != null && Object.hasOwnProperty.call(message, "SHOULDER_HEIGHT"))
                        writer.uint32(/* id 6, wireType 5 =*/53).float(message.SHOULDER_HEIGHT);
                    if (message.UPPER_ARM_LENGTH != null && Object.hasOwnProperty.call(message, "UPPER_ARM_LENGTH"))
                        writer.uint32(/* id 7, wireType 5 =*/61).float(message.UPPER_ARM_LENGTH);
                    if (message.UPPER_ARM_Y_OFFSET != null && Object.hasOwnProperty.call(message, "UPPER_ARM_Y_OFFSET"))
                        writer.uint32(/* id 8, wireType 5 =*/69).float(message.UPPER_ARM_Y_OFFSET);
                    if (message.UPPER_ARM_X_OFFSET != null && Object.hasOwnProperty.call(message, "UPPER_ARM_X_OFFSET"))
                        writer.uint32(/* id 9, wireType 5 =*/77).float(message.UPPER_ARM_X_OFFSET);
                    if (message.LOWER_ARM_LENGTH != null && Object.hasOwnProperty.call(message, "LOWER_ARM_LENGTH"))
                        writer.uint32(/* id 10, wireType 5 =*/85).float(message.LOWER_ARM_LENGTH);
                    if (message.LOWER_ARM_Y_OFFSET != null && Object.hasOwnProperty.call(message, "LOWER_ARM_Y_OFFSET"))
                        writer.uint32(/* id 11, wireType 5 =*/93).float(message.LOWER_ARM_Y_OFFSET);
                    if (message.LOWER_ARM_Z_OFFSET != null && Object.hasOwnProperty.call(message, "LOWER_ARM_Z_OFFSET"))
                        writer.uint32(/* id 12, wireType 5 =*/101).float(message.LOWER_ARM_Z_OFFSET);
                    return writer;
                };

                /**
                 * Decodes an Arm message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.actuation.KinematicsModel.Arm
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.actuation.KinematicsModel.Arm} Arm
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Arm.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.actuation.KinematicsModel.Arm();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.DISTANCE_BETWEEN_SHOULDERS = reader.float();
                            break;
                        case 2:
                            message.SHOULDER_Z_OFFSET = reader.float();
                            break;
                        case 3:
                            message.SHOULDER_X_OFFSET = reader.float();
                            break;
                        case 4:
                            message.SHOULDER_LENGTH = reader.float();
                            break;
                        case 5:
                            message.SHOULDER_WIDTH = reader.float();
                            break;
                        case 6:
                            message.SHOULDER_HEIGHT = reader.float();
                            break;
                        case 7:
                            message.UPPER_ARM_LENGTH = reader.float();
                            break;
                        case 8:
                            message.UPPER_ARM_Y_OFFSET = reader.float();
                            break;
                        case 9:
                            message.UPPER_ARM_X_OFFSET = reader.float();
                            break;
                        case 10:
                            message.LOWER_ARM_LENGTH = reader.float();
                            break;
                        case 11:
                            message.LOWER_ARM_Y_OFFSET = reader.float();
                            break;
                        case 12:
                            message.LOWER_ARM_Z_OFFSET = reader.float();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return Arm;
            })();

            KinematicsModel.MassModel = (function() {

                /**
                 * Properties of a MassModel.
                 * @memberof message.actuation.KinematicsModel
                 * @interface IMassModel
                 * @property {Ivec4|null} [head] MassModel head
                 * @property {Ivec4|null} [armUpper] MassModel armUpper
                 * @property {Ivec4|null} [armLower] MassModel armLower
                 * @property {Ivec4|null} [torso] MassModel torso
                 * @property {Ivec4|null} [hipBlock] MassModel hipBlock
                 * @property {Ivec4|null} [legUpper] MassModel legUpper
                 * @property {Ivec4|null} [legLower] MassModel legLower
                 * @property {Ivec4|null} [ankleBlock] MassModel ankleBlock
                 * @property {Ivec4|null} [foot] MassModel foot
                 */

                /**
                 * Constructs a new MassModel.
                 * @memberof message.actuation.KinematicsModel
                 * @classdesc A Particles CoM is in particle space
                 * @implements IMassModel
                 * @constructor
                 * @param {message.actuation.KinematicsModel.IMassModel=} [properties] Properties to set
                 */
                function MassModel(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MassModel head.
                 * @member {Ivec4|null|undefined} head
                 * @memberof message.actuation.KinematicsModel.MassModel
                 * @instance
                 */
                MassModel.prototype.head = null;

                /**
                 * MassModel armUpper.
                 * @member {Ivec4|null|undefined} armUpper
                 * @memberof message.actuation.KinematicsModel.MassModel
                 * @instance
                 */
                MassModel.prototype.armUpper = null;

                /**
                 * MassModel armLower.
                 * @member {Ivec4|null|undefined} armLower
                 * @memberof message.actuation.KinematicsModel.MassModel
                 * @instance
                 */
                MassModel.prototype.armLower = null;

                /**
                 * MassModel torso.
                 * @member {Ivec4|null|undefined} torso
                 * @memberof message.actuation.KinematicsModel.MassModel
                 * @instance
                 */
                MassModel.prototype.torso = null;

                /**
                 * MassModel hipBlock.
                 * @member {Ivec4|null|undefined} hipBlock
                 * @memberof message.actuation.KinematicsModel.MassModel
                 * @instance
                 */
                MassModel.prototype.hipBlock = null;

                /**
                 * MassModel legUpper.
                 * @member {Ivec4|null|undefined} legUpper
                 * @memberof message.actuation.KinematicsModel.MassModel
                 * @instance
                 */
                MassModel.prototype.legUpper = null;

                /**
                 * MassModel legLower.
                 * @member {Ivec4|null|undefined} legLower
                 * @memberof message.actuation.KinematicsModel.MassModel
                 * @instance
                 */
                MassModel.prototype.legLower = null;

                /**
                 * MassModel ankleBlock.
                 * @member {Ivec4|null|undefined} ankleBlock
                 * @memberof message.actuation.KinematicsModel.MassModel
                 * @instance
                 */
                MassModel.prototype.ankleBlock = null;

                /**
                 * MassModel foot.
                 * @member {Ivec4|null|undefined} foot
                 * @memberof message.actuation.KinematicsModel.MassModel
                 * @instance
                 */
                MassModel.prototype.foot = null;

                /**
                 * Encodes the specified MassModel message. Does not implicitly {@link message.actuation.KinematicsModel.MassModel.verify|verify} messages.
                 * @function encode
                 * @memberof message.actuation.KinematicsModel.MassModel
                 * @static
                 * @param {message.actuation.KinematicsModel.IMassModel} message MassModel message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MassModel.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.head != null && Object.hasOwnProperty.call(message, "head"))
                        $root.vec4.encode(message.head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.armUpper != null && Object.hasOwnProperty.call(message, "armUpper"))
                        $root.vec4.encode(message.armUpper, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.armLower != null && Object.hasOwnProperty.call(message, "armLower"))
                        $root.vec4.encode(message.armLower, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.torso != null && Object.hasOwnProperty.call(message, "torso"))
                        $root.vec4.encode(message.torso, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.hipBlock != null && Object.hasOwnProperty.call(message, "hipBlock"))
                        $root.vec4.encode(message.hipBlock, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.legUpper != null && Object.hasOwnProperty.call(message, "legUpper"))
                        $root.vec4.encode(message.legUpper, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.legLower != null && Object.hasOwnProperty.call(message, "legLower"))
                        $root.vec4.encode(message.legLower, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.ankleBlock != null && Object.hasOwnProperty.call(message, "ankleBlock"))
                        $root.vec4.encode(message.ankleBlock, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.foot != null && Object.hasOwnProperty.call(message, "foot"))
                        $root.vec4.encode(message.foot, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    return writer;
                };

                /**
                 * Decodes a MassModel message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.actuation.KinematicsModel.MassModel
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.actuation.KinematicsModel.MassModel} MassModel
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MassModel.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.actuation.KinematicsModel.MassModel();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.head = $root.vec4.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.armUpper = $root.vec4.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.armLower = $root.vec4.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.torso = $root.vec4.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.hipBlock = $root.vec4.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.legUpper = $root.vec4.decode(reader, reader.uint32());
                            break;
                        case 7:
                            message.legLower = $root.vec4.decode(reader, reader.uint32());
                            break;
                        case 8:
                            message.ankleBlock = $root.vec4.decode(reader, reader.uint32());
                            break;
                        case 9:
                            message.foot = $root.vec4.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return MassModel;
            })();

            KinematicsModel.TensorModel = (function() {

                /**
                 * Properties of a TensorModel.
                 * @memberof message.actuation.KinematicsModel
                 * @interface ITensorModel
                 * @property {Imat3|null} [head] TensorModel head
                 * @property {Imat3|null} [armUpper] TensorModel armUpper
                 * @property {Imat3|null} [armLower] TensorModel armLower
                 * @property {Imat3|null} [torso] TensorModel torso
                 * @property {Imat3|null} [hipBlock] TensorModel hipBlock
                 * @property {Imat3|null} [legUpper] TensorModel legUpper
                 * @property {Imat3|null} [legLower] TensorModel legLower
                 * @property {Imat3|null} [ankleBlock] TensorModel ankleBlock
                 * @property {Imat3|null} [foot] TensorModel foot
                 */

                /**
                 * Constructs a new TensorModel.
                 * @memberof message.actuation.KinematicsModel
                 * @classdesc SI Units
                 * @implements ITensorModel
                 * @constructor
                 * @param {message.actuation.KinematicsModel.ITensorModel=} [properties] Properties to set
                 */
                function TensorModel(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TensorModel head.
                 * @member {Imat3|null|undefined} head
                 * @memberof message.actuation.KinematicsModel.TensorModel
                 * @instance
                 */
                TensorModel.prototype.head = null;

                /**
                 * TensorModel armUpper.
                 * @member {Imat3|null|undefined} armUpper
                 * @memberof message.actuation.KinematicsModel.TensorModel
                 * @instance
                 */
                TensorModel.prototype.armUpper = null;

                /**
                 * TensorModel armLower.
                 * @member {Imat3|null|undefined} armLower
                 * @memberof message.actuation.KinematicsModel.TensorModel
                 * @instance
                 */
                TensorModel.prototype.armLower = null;

                /**
                 * TensorModel torso.
                 * @member {Imat3|null|undefined} torso
                 * @memberof message.actuation.KinematicsModel.TensorModel
                 * @instance
                 */
                TensorModel.prototype.torso = null;

                /**
                 * TensorModel hipBlock.
                 * @member {Imat3|null|undefined} hipBlock
                 * @memberof message.actuation.KinematicsModel.TensorModel
                 * @instance
                 */
                TensorModel.prototype.hipBlock = null;

                /**
                 * TensorModel legUpper.
                 * @member {Imat3|null|undefined} legUpper
                 * @memberof message.actuation.KinematicsModel.TensorModel
                 * @instance
                 */
                TensorModel.prototype.legUpper = null;

                /**
                 * TensorModel legLower.
                 * @member {Imat3|null|undefined} legLower
                 * @memberof message.actuation.KinematicsModel.TensorModel
                 * @instance
                 */
                TensorModel.prototype.legLower = null;

                /**
                 * TensorModel ankleBlock.
                 * @member {Imat3|null|undefined} ankleBlock
                 * @memberof message.actuation.KinematicsModel.TensorModel
                 * @instance
                 */
                TensorModel.prototype.ankleBlock = null;

                /**
                 * TensorModel foot.
                 * @member {Imat3|null|undefined} foot
                 * @memberof message.actuation.KinematicsModel.TensorModel
                 * @instance
                 */
                TensorModel.prototype.foot = null;

                /**
                 * Encodes the specified TensorModel message. Does not implicitly {@link message.actuation.KinematicsModel.TensorModel.verify|verify} messages.
                 * @function encode
                 * @memberof message.actuation.KinematicsModel.TensorModel
                 * @static
                 * @param {message.actuation.KinematicsModel.ITensorModel} message TensorModel message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TensorModel.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.head != null && Object.hasOwnProperty.call(message, "head"))
                        $root.mat3.encode(message.head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.armUpper != null && Object.hasOwnProperty.call(message, "armUpper"))
                        $root.mat3.encode(message.armUpper, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.armLower != null && Object.hasOwnProperty.call(message, "armLower"))
                        $root.mat3.encode(message.armLower, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.torso != null && Object.hasOwnProperty.call(message, "torso"))
                        $root.mat3.encode(message.torso, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.hipBlock != null && Object.hasOwnProperty.call(message, "hipBlock"))
                        $root.mat3.encode(message.hipBlock, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.legUpper != null && Object.hasOwnProperty.call(message, "legUpper"))
                        $root.mat3.encode(message.legUpper, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.legLower != null && Object.hasOwnProperty.call(message, "legLower"))
                        $root.mat3.encode(message.legLower, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.ankleBlock != null && Object.hasOwnProperty.call(message, "ankleBlock"))
                        $root.mat3.encode(message.ankleBlock, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.foot != null && Object.hasOwnProperty.call(message, "foot"))
                        $root.mat3.encode(message.foot, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    return writer;
                };

                /**
                 * Decodes a TensorModel message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.actuation.KinematicsModel.TensorModel
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.actuation.KinematicsModel.TensorModel} TensorModel
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TensorModel.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.actuation.KinematicsModel.TensorModel();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.head = $root.mat3.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.armUpper = $root.mat3.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.armLower = $root.mat3.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.torso = $root.mat3.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.hipBlock = $root.mat3.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.legUpper = $root.mat3.decode(reader, reader.uint32());
                            break;
                        case 7:
                            message.legLower = $root.mat3.decode(reader, reader.uint32());
                            break;
                        case 8:
                            message.ankleBlock = $root.mat3.decode(reader, reader.uint32());
                            break;
                        case 9:
                            message.foot = $root.mat3.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return TensorModel;
            })();

            return KinematicsModel;
        })();

        actuation.LeftLeg = (function() {

            /**
             * Properties of a LeftLeg.
             * @memberof message.actuation
             * @interface ILeftLeg
             * @property {Object.<string,message.actuation.IServoCommand>|null} [servos] Information for each servo in the left leg, with the key corresponding to ServoID
             */

            /**
             * Constructs a new LeftLeg.
             * @memberof message.actuation
             * @classdesc Left leg servo command information including time, gain, torque, position
             * @implements ILeftLeg
             * @constructor
             * @param {message.actuation.ILeftLeg=} [properties] Properties to set
             */
            function LeftLeg(properties) {
                this.servos = {};
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Information for each servo in the left leg, with the key corresponding to ServoID
             * @member {Object.<string,message.actuation.IServoCommand>} servos
             * @memberof message.actuation.LeftLeg
             * @instance
             */
            LeftLeg.prototype.servos = $util.emptyObject;

            /**
             * Encodes the specified LeftLeg message. Does not implicitly {@link message.actuation.LeftLeg.verify|verify} messages.
             * @function encode
             * @memberof message.actuation.LeftLeg
             * @static
             * @param {message.actuation.ILeftLeg} message LeftLeg message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LeftLeg.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.servos != null && Object.hasOwnProperty.call(message, "servos"))
                    for (let keys = Object.keys(message.servos), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 0 =*/8).uint32(keys[i]);
                        $root.message.actuation.ServoCommand.encode(message.servos[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };

            /**
             * Decodes a LeftLeg message from the specified reader or buffer.
             * @function decode
             * @memberof message.actuation.LeftLeg
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.actuation.LeftLeg} LeftLeg
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LeftLeg.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.actuation.LeftLeg(), key, value;
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (message.servos === $util.emptyObject)
                            message.servos = {};
                        let end2 = reader.uint32() + reader.pos;
                        key = 0;
                        value = null;
                        while (reader.pos < end2) {
                            let tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.uint32();
                                break;
                            case 2:
                                value = $root.message.actuation.ServoCommand.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.servos[key] = value;
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return LeftLeg;
        })();

        actuation.LeftLegSequence = (function() {

            /**
             * Properties of a LeftLegSequence.
             * @memberof message.actuation
             * @interface ILeftLegSequence
             * @property {Array.<message.actuation.ILeftLeg>|null} [frames] LeftLegSequence frames
             */

            /**
             * Constructs a new LeftLegSequence.
             * @memberof message.actuation
             * @classdesc Represents a LeftLegSequence.
             * @implements ILeftLegSequence
             * @constructor
             * @param {message.actuation.ILeftLegSequence=} [properties] Properties to set
             */
            function LeftLegSequence(properties) {
                this.frames = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LeftLegSequence frames.
             * @member {Array.<message.actuation.ILeftLeg>} frames
             * @memberof message.actuation.LeftLegSequence
             * @instance
             */
            LeftLegSequence.prototype.frames = $util.emptyArray;

            /**
             * Encodes the specified LeftLegSequence message. Does not implicitly {@link message.actuation.LeftLegSequence.verify|verify} messages.
             * @function encode
             * @memberof message.actuation.LeftLegSequence
             * @static
             * @param {message.actuation.ILeftLegSequence} message LeftLegSequence message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LeftLegSequence.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.frames != null && message.frames.length)
                    for (let i = 0; i < message.frames.length; ++i)
                        $root.message.actuation.LeftLeg.encode(message.frames[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a LeftLegSequence message from the specified reader or buffer.
             * @function decode
             * @memberof message.actuation.LeftLegSequence
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.actuation.LeftLegSequence} LeftLegSequence
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LeftLegSequence.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.actuation.LeftLegSequence();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.frames && message.frames.length))
                            message.frames = [];
                        message.frames.push($root.message.actuation.LeftLeg.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return LeftLegSequence;
        })();

        actuation.RightLeg = (function() {

            /**
             * Properties of a RightLeg.
             * @memberof message.actuation
             * @interface IRightLeg
             * @property {Object.<string,message.actuation.IServoCommand>|null} [servos] Information for each servo in the right leg, with the key corresponding to ServoID
             */

            /**
             * Constructs a new RightLeg.
             * @memberof message.actuation
             * @classdesc Right leg servo command information including time, gain, torque, position
             * @implements IRightLeg
             * @constructor
             * @param {message.actuation.IRightLeg=} [properties] Properties to set
             */
            function RightLeg(properties) {
                this.servos = {};
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Information for each servo in the right leg, with the key corresponding to ServoID
             * @member {Object.<string,message.actuation.IServoCommand>} servos
             * @memberof message.actuation.RightLeg
             * @instance
             */
            RightLeg.prototype.servos = $util.emptyObject;

            /**
             * Encodes the specified RightLeg message. Does not implicitly {@link message.actuation.RightLeg.verify|verify} messages.
             * @function encode
             * @memberof message.actuation.RightLeg
             * @static
             * @param {message.actuation.IRightLeg} message RightLeg message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RightLeg.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.servos != null && Object.hasOwnProperty.call(message, "servos"))
                    for (let keys = Object.keys(message.servos), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 0 =*/8).uint32(keys[i]);
                        $root.message.actuation.ServoCommand.encode(message.servos[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };

            /**
             * Decodes a RightLeg message from the specified reader or buffer.
             * @function decode
             * @memberof message.actuation.RightLeg
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.actuation.RightLeg} RightLeg
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RightLeg.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.actuation.RightLeg(), key, value;
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (message.servos === $util.emptyObject)
                            message.servos = {};
                        let end2 = reader.uint32() + reader.pos;
                        key = 0;
                        value = null;
                        while (reader.pos < end2) {
                            let tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.uint32();
                                break;
                            case 2:
                                value = $root.message.actuation.ServoCommand.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.servos[key] = value;
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return RightLeg;
        })();

        actuation.RightLegSequence = (function() {

            /**
             * Properties of a RightLegSequence.
             * @memberof message.actuation
             * @interface IRightLegSequence
             * @property {Array.<message.actuation.IRightLeg>|null} [frames] RightLegSequence frames
             */

            /**
             * Constructs a new RightLegSequence.
             * @memberof message.actuation
             * @classdesc Represents a RightLegSequence.
             * @implements IRightLegSequence
             * @constructor
             * @param {message.actuation.IRightLegSequence=} [properties] Properties to set
             */
            function RightLegSequence(properties) {
                this.frames = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RightLegSequence frames.
             * @member {Array.<message.actuation.IRightLeg>} frames
             * @memberof message.actuation.RightLegSequence
             * @instance
             */
            RightLegSequence.prototype.frames = $util.emptyArray;

            /**
             * Encodes the specified RightLegSequence message. Does not implicitly {@link message.actuation.RightLegSequence.verify|verify} messages.
             * @function encode
             * @memberof message.actuation.RightLegSequence
             * @static
             * @param {message.actuation.IRightLegSequence} message RightLegSequence message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RightLegSequence.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.frames != null && message.frames.length)
                    for (let i = 0; i < message.frames.length; ++i)
                        $root.message.actuation.RightLeg.encode(message.frames[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a RightLegSequence message from the specified reader or buffer.
             * @function decode
             * @memberof message.actuation.RightLegSequence
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.actuation.RightLegSequence} RightLegSequence
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RightLegSequence.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.actuation.RightLegSequence();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.frames && message.frames.length))
                            message.frames = [];
                        message.frames.push($root.message.actuation.RightLeg.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return RightLegSequence;
        })();

        actuation.Legs = (function() {

            /**
             * Properties of a Legs.
             * @memberof message.actuation
             * @interface ILegs
             * @property {Object.<string,message.actuation.IServoCommand>|null} [servos] Information for each servo in the legs, with the key corresponding to ServoID
             */

            /**
             * Constructs a new Legs.
             * @memberof message.actuation
             * @classdesc Right and left leg servo command information including time, gain, torque, position
             * @implements ILegs
             * @constructor
             * @param {message.actuation.ILegs=} [properties] Properties to set
             */
            function Legs(properties) {
                this.servos = {};
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Information for each servo in the legs, with the key corresponding to ServoID
             * @member {Object.<string,message.actuation.IServoCommand>} servos
             * @memberof message.actuation.Legs
             * @instance
             */
            Legs.prototype.servos = $util.emptyObject;

            /**
             * Encodes the specified Legs message. Does not implicitly {@link message.actuation.Legs.verify|verify} messages.
             * @function encode
             * @memberof message.actuation.Legs
             * @static
             * @param {message.actuation.ILegs} message Legs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Legs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.servos != null && Object.hasOwnProperty.call(message, "servos"))
                    for (let keys = Object.keys(message.servos), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 0 =*/8).uint32(keys[i]);
                        $root.message.actuation.ServoCommand.encode(message.servos[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };

            /**
             * Decodes a Legs message from the specified reader or buffer.
             * @function decode
             * @memberof message.actuation.Legs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.actuation.Legs} Legs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Legs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.actuation.Legs(), key, value;
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (message.servos === $util.emptyObject)
                            message.servos = {};
                        let end2 = reader.uint32() + reader.pos;
                        key = 0;
                        value = null;
                        while (reader.pos < end2) {
                            let tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.uint32();
                                break;
                            case 2:
                                value = $root.message.actuation.ServoCommand.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.servos[key] = value;
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return Legs;
        })();

        actuation.LegsSequence = (function() {

            /**
             * Properties of a LegsSequence.
             * @memberof message.actuation
             * @interface ILegsSequence
             * @property {Array.<message.actuation.ILegs>|null} [frames] LegsSequence frames
             */

            /**
             * Constructs a new LegsSequence.
             * @memberof message.actuation
             * @classdesc Represents a LegsSequence.
             * @implements ILegsSequence
             * @constructor
             * @param {message.actuation.ILegsSequence=} [properties] Properties to set
             */
            function LegsSequence(properties) {
                this.frames = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LegsSequence frames.
             * @member {Array.<message.actuation.ILegs>} frames
             * @memberof message.actuation.LegsSequence
             * @instance
             */
            LegsSequence.prototype.frames = $util.emptyArray;

            /**
             * Encodes the specified LegsSequence message. Does not implicitly {@link message.actuation.LegsSequence.verify|verify} messages.
             * @function encode
             * @memberof message.actuation.LegsSequence
             * @static
             * @param {message.actuation.ILegsSequence} message LegsSequence message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LegsSequence.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.frames != null && message.frames.length)
                    for (let i = 0; i < message.frames.length; ++i)
                        $root.message.actuation.Legs.encode(message.frames[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a LegsSequence message from the specified reader or buffer.
             * @function decode
             * @memberof message.actuation.LegsSequence
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.actuation.LegsSequence} LegsSequence
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LegsSequence.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.actuation.LegsSequence();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.frames && message.frames.length))
                            message.frames = [];
                        message.frames.push($root.message.actuation.Legs.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return LegsSequence;
        })();

        actuation.LeftArm = (function() {

            /**
             * Properties of a LeftArm.
             * @memberof message.actuation
             * @interface ILeftArm
             * @property {Object.<string,message.actuation.IServoCommand>|null} [servos] Information for each servo in the left arm, with the key corresponding to ServoID
             */

            /**
             * Constructs a new LeftArm.
             * @memberof message.actuation
             * @classdesc Left arm servo command information including time, gain, torque, position
             * @implements ILeftArm
             * @constructor
             * @param {message.actuation.ILeftArm=} [properties] Properties to set
             */
            function LeftArm(properties) {
                this.servos = {};
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Information for each servo in the left arm, with the key corresponding to ServoID
             * @member {Object.<string,message.actuation.IServoCommand>} servos
             * @memberof message.actuation.LeftArm
             * @instance
             */
            LeftArm.prototype.servos = $util.emptyObject;

            /**
             * Encodes the specified LeftArm message. Does not implicitly {@link message.actuation.LeftArm.verify|verify} messages.
             * @function encode
             * @memberof message.actuation.LeftArm
             * @static
             * @param {message.actuation.ILeftArm} message LeftArm message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LeftArm.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.servos != null && Object.hasOwnProperty.call(message, "servos"))
                    for (let keys = Object.keys(message.servos), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 0 =*/8).uint32(keys[i]);
                        $root.message.actuation.ServoCommand.encode(message.servos[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };

            /**
             * Decodes a LeftArm message from the specified reader or buffer.
             * @function decode
             * @memberof message.actuation.LeftArm
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.actuation.LeftArm} LeftArm
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LeftArm.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.actuation.LeftArm(), key, value;
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (message.servos === $util.emptyObject)
                            message.servos = {};
                        let end2 = reader.uint32() + reader.pos;
                        key = 0;
                        value = null;
                        while (reader.pos < end2) {
                            let tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.uint32();
                                break;
                            case 2:
                                value = $root.message.actuation.ServoCommand.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.servos[key] = value;
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return LeftArm;
        })();

        actuation.LeftArmSequence = (function() {

            /**
             * Properties of a LeftArmSequence.
             * @memberof message.actuation
             * @interface ILeftArmSequence
             * @property {Array.<message.actuation.ILeftArm>|null} [frames] LeftArmSequence frames
             */

            /**
             * Constructs a new LeftArmSequence.
             * @memberof message.actuation
             * @classdesc Represents a LeftArmSequence.
             * @implements ILeftArmSequence
             * @constructor
             * @param {message.actuation.ILeftArmSequence=} [properties] Properties to set
             */
            function LeftArmSequence(properties) {
                this.frames = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LeftArmSequence frames.
             * @member {Array.<message.actuation.ILeftArm>} frames
             * @memberof message.actuation.LeftArmSequence
             * @instance
             */
            LeftArmSequence.prototype.frames = $util.emptyArray;

            /**
             * Encodes the specified LeftArmSequence message. Does not implicitly {@link message.actuation.LeftArmSequence.verify|verify} messages.
             * @function encode
             * @memberof message.actuation.LeftArmSequence
             * @static
             * @param {message.actuation.ILeftArmSequence} message LeftArmSequence message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LeftArmSequence.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.frames != null && message.frames.length)
                    for (let i = 0; i < message.frames.length; ++i)
                        $root.message.actuation.LeftArm.encode(message.frames[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a LeftArmSequence message from the specified reader or buffer.
             * @function decode
             * @memberof message.actuation.LeftArmSequence
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.actuation.LeftArmSequence} LeftArmSequence
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LeftArmSequence.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.actuation.LeftArmSequence();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.frames && message.frames.length))
                            message.frames = [];
                        message.frames.push($root.message.actuation.LeftArm.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return LeftArmSequence;
        })();

        actuation.RightArm = (function() {

            /**
             * Properties of a RightArm.
             * @memberof message.actuation
             * @interface IRightArm
             * @property {Object.<string,message.actuation.IServoCommand>|null} [servos] Information for each servo in the right arm, with the key corresponding to ServoID
             */

            /**
             * Constructs a new RightArm.
             * @memberof message.actuation
             * @classdesc Right arm servo command information including time, gain, torque, position
             * @implements IRightArm
             * @constructor
             * @param {message.actuation.IRightArm=} [properties] Properties to set
             */
            function RightArm(properties) {
                this.servos = {};
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Information for each servo in the right arm, with the key corresponding to ServoID
             * @member {Object.<string,message.actuation.IServoCommand>} servos
             * @memberof message.actuation.RightArm
             * @instance
             */
            RightArm.prototype.servos = $util.emptyObject;

            /**
             * Encodes the specified RightArm message. Does not implicitly {@link message.actuation.RightArm.verify|verify} messages.
             * @function encode
             * @memberof message.actuation.RightArm
             * @static
             * @param {message.actuation.IRightArm} message RightArm message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RightArm.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.servos != null && Object.hasOwnProperty.call(message, "servos"))
                    for (let keys = Object.keys(message.servos), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 0 =*/8).uint32(keys[i]);
                        $root.message.actuation.ServoCommand.encode(message.servos[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };

            /**
             * Decodes a RightArm message from the specified reader or buffer.
             * @function decode
             * @memberof message.actuation.RightArm
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.actuation.RightArm} RightArm
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RightArm.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.actuation.RightArm(), key, value;
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (message.servos === $util.emptyObject)
                            message.servos = {};
                        let end2 = reader.uint32() + reader.pos;
                        key = 0;
                        value = null;
                        while (reader.pos < end2) {
                            let tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.uint32();
                                break;
                            case 2:
                                value = $root.message.actuation.ServoCommand.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.servos[key] = value;
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return RightArm;
        })();

        actuation.RightArmSequence = (function() {

            /**
             * Properties of a RightArmSequence.
             * @memberof message.actuation
             * @interface IRightArmSequence
             * @property {Array.<message.actuation.IRightArm>|null} [frames] RightArmSequence frames
             */

            /**
             * Constructs a new RightArmSequence.
             * @memberof message.actuation
             * @classdesc Represents a RightArmSequence.
             * @implements IRightArmSequence
             * @constructor
             * @param {message.actuation.IRightArmSequence=} [properties] Properties to set
             */
            function RightArmSequence(properties) {
                this.frames = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RightArmSequence frames.
             * @member {Array.<message.actuation.IRightArm>} frames
             * @memberof message.actuation.RightArmSequence
             * @instance
             */
            RightArmSequence.prototype.frames = $util.emptyArray;

            /**
             * Encodes the specified RightArmSequence message. Does not implicitly {@link message.actuation.RightArmSequence.verify|verify} messages.
             * @function encode
             * @memberof message.actuation.RightArmSequence
             * @static
             * @param {message.actuation.IRightArmSequence} message RightArmSequence message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RightArmSequence.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.frames != null && message.frames.length)
                    for (let i = 0; i < message.frames.length; ++i)
                        $root.message.actuation.RightArm.encode(message.frames[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a RightArmSequence message from the specified reader or buffer.
             * @function decode
             * @memberof message.actuation.RightArmSequence
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.actuation.RightArmSequence} RightArmSequence
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RightArmSequence.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.actuation.RightArmSequence();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.frames && message.frames.length))
                            message.frames = [];
                        message.frames.push($root.message.actuation.RightArm.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return RightArmSequence;
        })();

        actuation.Arms = (function() {

            /**
             * Properties of an Arms.
             * @memberof message.actuation
             * @interface IArms
             * @property {Object.<string,message.actuation.IServoCommand>|null} [servos] Information for each servo in the arms, with the key corresponding to ServoID
             */

            /**
             * Constructs a new Arms.
             * @memberof message.actuation
             * @classdesc Left and right arm servo command information including time, gain, torque, position
             * @implements IArms
             * @constructor
             * @param {message.actuation.IArms=} [properties] Properties to set
             */
            function Arms(properties) {
                this.servos = {};
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Information for each servo in the arms, with the key corresponding to ServoID
             * @member {Object.<string,message.actuation.IServoCommand>} servos
             * @memberof message.actuation.Arms
             * @instance
             */
            Arms.prototype.servos = $util.emptyObject;

            /**
             * Encodes the specified Arms message. Does not implicitly {@link message.actuation.Arms.verify|verify} messages.
             * @function encode
             * @memberof message.actuation.Arms
             * @static
             * @param {message.actuation.IArms} message Arms message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Arms.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.servos != null && Object.hasOwnProperty.call(message, "servos"))
                    for (let keys = Object.keys(message.servos), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 0 =*/8).uint32(keys[i]);
                        $root.message.actuation.ServoCommand.encode(message.servos[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };

            /**
             * Decodes an Arms message from the specified reader or buffer.
             * @function decode
             * @memberof message.actuation.Arms
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.actuation.Arms} Arms
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Arms.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.actuation.Arms(), key, value;
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (message.servos === $util.emptyObject)
                            message.servos = {};
                        let end2 = reader.uint32() + reader.pos;
                        key = 0;
                        value = null;
                        while (reader.pos < end2) {
                            let tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.uint32();
                                break;
                            case 2:
                                value = $root.message.actuation.ServoCommand.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.servos[key] = value;
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return Arms;
        })();

        actuation.ArmsSequence = (function() {

            /**
             * Properties of an ArmsSequence.
             * @memberof message.actuation
             * @interface IArmsSequence
             * @property {Array.<message.actuation.IArms>|null} [frames] ArmsSequence frames
             */

            /**
             * Constructs a new ArmsSequence.
             * @memberof message.actuation
             * @classdesc Represents an ArmsSequence.
             * @implements IArmsSequence
             * @constructor
             * @param {message.actuation.IArmsSequence=} [properties] Properties to set
             */
            function ArmsSequence(properties) {
                this.frames = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ArmsSequence frames.
             * @member {Array.<message.actuation.IArms>} frames
             * @memberof message.actuation.ArmsSequence
             * @instance
             */
            ArmsSequence.prototype.frames = $util.emptyArray;

            /**
             * Encodes the specified ArmsSequence message. Does not implicitly {@link message.actuation.ArmsSequence.verify|verify} messages.
             * @function encode
             * @memberof message.actuation.ArmsSequence
             * @static
             * @param {message.actuation.IArmsSequence} message ArmsSequence message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ArmsSequence.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.frames != null && message.frames.length)
                    for (let i = 0; i < message.frames.length; ++i)
                        $root.message.actuation.Arms.encode(message.frames[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes an ArmsSequence message from the specified reader or buffer.
             * @function decode
             * @memberof message.actuation.ArmsSequence
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.actuation.ArmsSequence} ArmsSequence
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ArmsSequence.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.actuation.ArmsSequence();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.frames && message.frames.length))
                            message.frames = [];
                        message.frames.push($root.message.actuation.Arms.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return ArmsSequence;
        })();

        actuation.Limbs = (function() {

            /**
             * Properties of a Limbs.
             * @memberof message.actuation
             * @interface ILimbs
             * @property {Object.<string,message.actuation.IServoCommand>|null} [servos] Information for each servo in the arms and legs, with the key corresponding to ServoID
             */

            /**
             * Constructs a new Limbs.
             * @memberof message.actuation
             * @classdesc Left and right arm and leg servo command information including time, gain, torque, position
             * @implements ILimbs
             * @constructor
             * @param {message.actuation.ILimbs=} [properties] Properties to set
             */
            function Limbs(properties) {
                this.servos = {};
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Information for each servo in the arms and legs, with the key corresponding to ServoID
             * @member {Object.<string,message.actuation.IServoCommand>} servos
             * @memberof message.actuation.Limbs
             * @instance
             */
            Limbs.prototype.servos = $util.emptyObject;

            /**
             * Encodes the specified Limbs message. Does not implicitly {@link message.actuation.Limbs.verify|verify} messages.
             * @function encode
             * @memberof message.actuation.Limbs
             * @static
             * @param {message.actuation.ILimbs} message Limbs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Limbs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.servos != null && Object.hasOwnProperty.call(message, "servos"))
                    for (let keys = Object.keys(message.servos), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 0 =*/8).uint32(keys[i]);
                        $root.message.actuation.ServoCommand.encode(message.servos[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };

            /**
             * Decodes a Limbs message from the specified reader or buffer.
             * @function decode
             * @memberof message.actuation.Limbs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.actuation.Limbs} Limbs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Limbs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.actuation.Limbs(), key, value;
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (message.servos === $util.emptyObject)
                            message.servos = {};
                        let end2 = reader.uint32() + reader.pos;
                        key = 0;
                        value = null;
                        while (reader.pos < end2) {
                            let tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.uint32();
                                break;
                            case 2:
                                value = $root.message.actuation.ServoCommand.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.servos[key] = value;
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return Limbs;
        })();

        actuation.LimbsSequence = (function() {

            /**
             * Properties of a LimbsSequence.
             * @memberof message.actuation
             * @interface ILimbsSequence
             * @property {Array.<message.actuation.ILimbs>|null} [frames] LimbsSequence frames
             */

            /**
             * Constructs a new LimbsSequence.
             * @memberof message.actuation
             * @classdesc Represents a LimbsSequence.
             * @implements ILimbsSequence
             * @constructor
             * @param {message.actuation.ILimbsSequence=} [properties] Properties to set
             */
            function LimbsSequence(properties) {
                this.frames = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LimbsSequence frames.
             * @member {Array.<message.actuation.ILimbs>} frames
             * @memberof message.actuation.LimbsSequence
             * @instance
             */
            LimbsSequence.prototype.frames = $util.emptyArray;

            /**
             * Encodes the specified LimbsSequence message. Does not implicitly {@link message.actuation.LimbsSequence.verify|verify} messages.
             * @function encode
             * @memberof message.actuation.LimbsSequence
             * @static
             * @param {message.actuation.ILimbsSequence} message LimbsSequence message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LimbsSequence.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.frames != null && message.frames.length)
                    for (let i = 0; i < message.frames.length; ++i)
                        $root.message.actuation.Limbs.encode(message.frames[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a LimbsSequence message from the specified reader or buffer.
             * @function decode
             * @memberof message.actuation.LimbsSequence
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.actuation.LimbsSequence} LimbsSequence
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LimbsSequence.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.actuation.LimbsSequence();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.frames && message.frames.length))
                            message.frames = [];
                        message.frames.push($root.message.actuation.Limbs.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return LimbsSequence;
        })();

        actuation.Head = (function() {

            /**
             * Properties of a Head.
             * @memberof message.actuation
             * @interface IHead
             * @property {Object.<string,message.actuation.IServoCommand>|null} [servos] Information for each servo in the head, with the key corresponding to ServoID
             */

            /**
             * Constructs a new Head.
             * @memberof message.actuation
             * @classdesc Head servo command information including time, gain, torque, position
             * @implements IHead
             * @constructor
             * @param {message.actuation.IHead=} [properties] Properties to set
             */
            function Head(properties) {
                this.servos = {};
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Information for each servo in the head, with the key corresponding to ServoID
             * @member {Object.<string,message.actuation.IServoCommand>} servos
             * @memberof message.actuation.Head
             * @instance
             */
            Head.prototype.servos = $util.emptyObject;

            /**
             * Encodes the specified Head message. Does not implicitly {@link message.actuation.Head.verify|verify} messages.
             * @function encode
             * @memberof message.actuation.Head
             * @static
             * @param {message.actuation.IHead} message Head message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Head.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.servos != null && Object.hasOwnProperty.call(message, "servos"))
                    for (let keys = Object.keys(message.servos), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 0 =*/8).uint32(keys[i]);
                        $root.message.actuation.ServoCommand.encode(message.servos[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };

            /**
             * Decodes a Head message from the specified reader or buffer.
             * @function decode
             * @memberof message.actuation.Head
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.actuation.Head} Head
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Head.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.actuation.Head(), key, value;
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (message.servos === $util.emptyObject)
                            message.servos = {};
                        let end2 = reader.uint32() + reader.pos;
                        key = 0;
                        value = null;
                        while (reader.pos < end2) {
                            let tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.uint32();
                                break;
                            case 2:
                                value = $root.message.actuation.ServoCommand.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.servos[key] = value;
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return Head;
        })();

        actuation.HeadSequence = (function() {

            /**
             * Properties of a HeadSequence.
             * @memberof message.actuation
             * @interface IHeadSequence
             * @property {Array.<message.actuation.IHead>|null} [frames] HeadSequence frames
             */

            /**
             * Constructs a new HeadSequence.
             * @memberof message.actuation
             * @classdesc Represents a HeadSequence.
             * @implements IHeadSequence
             * @constructor
             * @param {message.actuation.IHeadSequence=} [properties] Properties to set
             */
            function HeadSequence(properties) {
                this.frames = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * HeadSequence frames.
             * @member {Array.<message.actuation.IHead>} frames
             * @memberof message.actuation.HeadSequence
             * @instance
             */
            HeadSequence.prototype.frames = $util.emptyArray;

            /**
             * Encodes the specified HeadSequence message. Does not implicitly {@link message.actuation.HeadSequence.verify|verify} messages.
             * @function encode
             * @memberof message.actuation.HeadSequence
             * @static
             * @param {message.actuation.IHeadSequence} message HeadSequence message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HeadSequence.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.frames != null && message.frames.length)
                    for (let i = 0; i < message.frames.length; ++i)
                        $root.message.actuation.Head.encode(message.frames[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a HeadSequence message from the specified reader or buffer.
             * @function decode
             * @memberof message.actuation.HeadSequence
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.actuation.HeadSequence} HeadSequence
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HeadSequence.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.actuation.HeadSequence();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.frames && message.frames.length))
                            message.frames = [];
                        message.frames.push($root.message.actuation.Head.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return HeadSequence;
        })();

        actuation.Body = (function() {

            /**
             * Properties of a Body.
             * @memberof message.actuation
             * @interface IBody
             * @property {Object.<string,message.actuation.IServoCommand>|null} [servos] Information for each servo in the body, with the key corresponding to ServoID
             */

            /**
             * Constructs a new Body.
             * @memberof message.actuation
             * @classdesc Arms, legs and head servo command information including time, gain, torque, position
             * @implements IBody
             * @constructor
             * @param {message.actuation.IBody=} [properties] Properties to set
             */
            function Body(properties) {
                this.servos = {};
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Information for each servo in the body, with the key corresponding to ServoID
             * @member {Object.<string,message.actuation.IServoCommand>} servos
             * @memberof message.actuation.Body
             * @instance
             */
            Body.prototype.servos = $util.emptyObject;

            /**
             * Encodes the specified Body message. Does not implicitly {@link message.actuation.Body.verify|verify} messages.
             * @function encode
             * @memberof message.actuation.Body
             * @static
             * @param {message.actuation.IBody} message Body message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Body.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.servos != null && Object.hasOwnProperty.call(message, "servos"))
                    for (let keys = Object.keys(message.servos), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 0 =*/8).uint32(keys[i]);
                        $root.message.actuation.ServoCommand.encode(message.servos[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };

            /**
             * Decodes a Body message from the specified reader or buffer.
             * @function decode
             * @memberof message.actuation.Body
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.actuation.Body} Body
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Body.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.actuation.Body(), key, value;
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (message.servos === $util.emptyObject)
                            message.servos = {};
                        let end2 = reader.uint32() + reader.pos;
                        key = 0;
                        value = null;
                        while (reader.pos < end2) {
                            let tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.uint32();
                                break;
                            case 2:
                                value = $root.message.actuation.ServoCommand.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.servos[key] = value;
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return Body;
        })();

        actuation.BodySequence = (function() {

            /**
             * Properties of a BodySequence.
             * @memberof message.actuation
             * @interface IBodySequence
             * @property {Array.<message.actuation.IBody>|null} [frames] BodySequence frames
             */

            /**
             * Constructs a new BodySequence.
             * @memberof message.actuation
             * @classdesc Represents a BodySequence.
             * @implements IBodySequence
             * @constructor
             * @param {message.actuation.IBodySequence=} [properties] Properties to set
             */
            function BodySequence(properties) {
                this.frames = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BodySequence frames.
             * @member {Array.<message.actuation.IBody>} frames
             * @memberof message.actuation.BodySequence
             * @instance
             */
            BodySequence.prototype.frames = $util.emptyArray;

            /**
             * Encodes the specified BodySequence message. Does not implicitly {@link message.actuation.BodySequence.verify|verify} messages.
             * @function encode
             * @memberof message.actuation.BodySequence
             * @static
             * @param {message.actuation.IBodySequence} message BodySequence message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BodySequence.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.frames != null && message.frames.length)
                    for (let i = 0; i < message.frames.length; ++i)
                        $root.message.actuation.Body.encode(message.frames[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a BodySequence message from the specified reader or buffer.
             * @function decode
             * @memberof message.actuation.BodySequence
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.actuation.BodySequence} BodySequence
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BodySequence.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.actuation.BodySequence();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.frames && message.frames.length))
                            message.frames = [];
                        message.frames.push($root.message.actuation.Body.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return BodySequence;
        })();

        actuation.LeftLegIK = (function() {

            /**
             * Properties of a LeftLegIK.
             * @memberof message.actuation
             * @interface ILeftLegIK
             * @property {google.protobuf.ITimestamp|null} [time] When the command should execute
             * @property {Imat4|null} [Htl] Target left foot position to torso
             * @property {Object.<string,message.actuation.IServoState>|null} [servos] Gain and torque of each servo, with the key corresponding to ServoID
             */

            /**
             * Constructs a new LeftLegIK.
             * @memberof message.actuation
             * @classdesc Left leg motion information including target matrix, time and gain and torque for each servo
             * @implements ILeftLegIK
             * @constructor
             * @param {message.actuation.ILeftLegIK=} [properties] Properties to set
             */
            function LeftLegIK(properties) {
                this.servos = {};
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * When the command should execute
             * @member {google.protobuf.ITimestamp|null|undefined} time
             * @memberof message.actuation.LeftLegIK
             * @instance
             */
            LeftLegIK.prototype.time = null;

            /**
             * Target left foot position to torso
             * @member {Imat4|null|undefined} Htl
             * @memberof message.actuation.LeftLegIK
             * @instance
             */
            LeftLegIK.prototype.Htl = null;

            /**
             * Gain and torque of each servo, with the key corresponding to ServoID
             * @member {Object.<string,message.actuation.IServoState>} servos
             * @memberof message.actuation.LeftLegIK
             * @instance
             */
            LeftLegIK.prototype.servos = $util.emptyObject;

            /**
             * Encodes the specified LeftLegIK message. Does not implicitly {@link message.actuation.LeftLegIK.verify|verify} messages.
             * @function encode
             * @memberof message.actuation.LeftLegIK
             * @static
             * @param {message.actuation.ILeftLegIK} message LeftLegIK message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LeftLegIK.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                    $root.google.protobuf.Timestamp.encode(message.time, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.Htl != null && Object.hasOwnProperty.call(message, "Htl"))
                    $root.mat4.encode(message.Htl, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.servos != null && Object.hasOwnProperty.call(message, "servos"))
                    for (let keys = Object.keys(message.servos), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 0 =*/8).uint32(keys[i]);
                        $root.message.actuation.ServoState.encode(message.servos[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };

            /**
             * Decodes a LeftLegIK message from the specified reader or buffer.
             * @function decode
             * @memberof message.actuation.LeftLegIK
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.actuation.LeftLegIK} LeftLegIK
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LeftLegIK.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.actuation.LeftLegIK(), key, value;
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.time = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.Htl = $root.mat4.decode(reader, reader.uint32());
                        break;
                    case 3:
                        if (message.servos === $util.emptyObject)
                            message.servos = {};
                        let end2 = reader.uint32() + reader.pos;
                        key = 0;
                        value = null;
                        while (reader.pos < end2) {
                            let tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.uint32();
                                break;
                            case 2:
                                value = $root.message.actuation.ServoState.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.servos[key] = value;
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return LeftLegIK;
        })();

        actuation.RightLegIK = (function() {

            /**
             * Properties of a RightLegIK.
             * @memberof message.actuation
             * @interface IRightLegIK
             * @property {google.protobuf.ITimestamp|null} [time] When the command should execute
             * @property {Imat4|null} [Htr] Target right foot position to torso
             * @property {Object.<string,message.actuation.IServoState>|null} [servos] Gain and torque of each servo, with the key corresponding to ServoID
             */

            /**
             * Constructs a new RightLegIK.
             * @memberof message.actuation
             * @classdesc Right leg motion information including target matrix, time and gain and torque for each servo
             * @implements IRightLegIK
             * @constructor
             * @param {message.actuation.IRightLegIK=} [properties] Properties to set
             */
            function RightLegIK(properties) {
                this.servos = {};
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * When the command should execute
             * @member {google.protobuf.ITimestamp|null|undefined} time
             * @memberof message.actuation.RightLegIK
             * @instance
             */
            RightLegIK.prototype.time = null;

            /**
             * Target right foot position to torso
             * @member {Imat4|null|undefined} Htr
             * @memberof message.actuation.RightLegIK
             * @instance
             */
            RightLegIK.prototype.Htr = null;

            /**
             * Gain and torque of each servo, with the key corresponding to ServoID
             * @member {Object.<string,message.actuation.IServoState>} servos
             * @memberof message.actuation.RightLegIK
             * @instance
             */
            RightLegIK.prototype.servos = $util.emptyObject;

            /**
             * Encodes the specified RightLegIK message. Does not implicitly {@link message.actuation.RightLegIK.verify|verify} messages.
             * @function encode
             * @memberof message.actuation.RightLegIK
             * @static
             * @param {message.actuation.IRightLegIK} message RightLegIK message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RightLegIK.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                    $root.google.protobuf.Timestamp.encode(message.time, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.Htr != null && Object.hasOwnProperty.call(message, "Htr"))
                    $root.mat4.encode(message.Htr, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.servos != null && Object.hasOwnProperty.call(message, "servos"))
                    for (let keys = Object.keys(message.servos), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 0 =*/8).uint32(keys[i]);
                        $root.message.actuation.ServoState.encode(message.servos[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };

            /**
             * Decodes a RightLegIK message from the specified reader or buffer.
             * @function decode
             * @memberof message.actuation.RightLegIK
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.actuation.RightLegIK} RightLegIK
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RightLegIK.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.actuation.RightLegIK(), key, value;
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.time = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.Htr = $root.mat4.decode(reader, reader.uint32());
                        break;
                    case 3:
                        if (message.servos === $util.emptyObject)
                            message.servos = {};
                        let end2 = reader.uint32() + reader.pos;
                        key = 0;
                        value = null;
                        while (reader.pos < end2) {
                            let tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.uint32();
                                break;
                            case 2:
                                value = $root.message.actuation.ServoState.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.servos[key] = value;
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return RightLegIK;
        })();

        actuation.HeadIK = (function() {

            /**
             * Properties of a HeadIK.
             * @memberof message.actuation
             * @interface IHeadIK
             * @property {google.protobuf.ITimestamp|null} [time] When the command should execute
             * @property {Ivec3|null} [uPCt] Vector for the head to look towards (camera to point in torso space)
             * @property {Object.<string,message.actuation.IServoState>|null} [servos] Gain and torque of each servo, with the key corresponding to ServoID
             */

            /**
             * Constructs a new HeadIK.
             * @memberof message.actuation
             * @classdesc Head motion information including look direction, time and gain and torque for each servo
             * @implements IHeadIK
             * @constructor
             * @param {message.actuation.IHeadIK=} [properties] Properties to set
             */
            function HeadIK(properties) {
                this.servos = {};
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * When the command should execute
             * @member {google.protobuf.ITimestamp|null|undefined} time
             * @memberof message.actuation.HeadIK
             * @instance
             */
            HeadIK.prototype.time = null;

            /**
             * Vector for the head to look towards (camera to point in torso space)
             * @member {Ivec3|null|undefined} uPCt
             * @memberof message.actuation.HeadIK
             * @instance
             */
            HeadIK.prototype.uPCt = null;

            /**
             * Gain and torque of each servo, with the key corresponding to ServoID
             * @member {Object.<string,message.actuation.IServoState>} servos
             * @memberof message.actuation.HeadIK
             * @instance
             */
            HeadIK.prototype.servos = $util.emptyObject;

            /**
             * Encodes the specified HeadIK message. Does not implicitly {@link message.actuation.HeadIK.verify|verify} messages.
             * @function encode
             * @memberof message.actuation.HeadIK
             * @static
             * @param {message.actuation.IHeadIK} message HeadIK message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HeadIK.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                    $root.google.protobuf.Timestamp.encode(message.time, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.uPCt != null && Object.hasOwnProperty.call(message, "uPCt"))
                    $root.vec3.encode(message.uPCt, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.servos != null && Object.hasOwnProperty.call(message, "servos"))
                    for (let keys = Object.keys(message.servos), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 0 =*/8).uint32(keys[i]);
                        $root.message.actuation.ServoState.encode(message.servos[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };

            /**
             * Decodes a HeadIK message from the specified reader or buffer.
             * @function decode
             * @memberof message.actuation.HeadIK
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.actuation.HeadIK} HeadIK
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HeadIK.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.actuation.HeadIK(), key, value;
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.time = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.uPCt = $root.vec3.decode(reader, reader.uint32());
                        break;
                    case 3:
                        if (message.servos === $util.emptyObject)
                            message.servos = {};
                        let end2 = reader.uint32() + reader.pos;
                        key = 0;
                        value = null;
                        while (reader.pos < end2) {
                            let tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.uint32();
                                break;
                            case 2:
                                value = $root.message.actuation.ServoState.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.servos[key] = value;
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return HeadIK;
        })();

        actuation.ServoState = (function() {

            /**
             * Properties of a ServoState.
             * @memberof message.actuation
             * @interface IServoState
             * @property {number|null} [gain] values are in range 0-100.
             * @property {number|null} [torque] Used to set the servo on or off. Typically either 0 (off) or 100 (on)
             */

            /**
             * Constructs a new ServoState.
             * @memberof message.actuation
             * @classdesc Represents a ServoState.
             * @implements IServoState
             * @constructor
             * @param {message.actuation.IServoState=} [properties] Properties to set
             */
            function ServoState(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * values are in range 0-100.
             * @member {number} gain
             * @memberof message.actuation.ServoState
             * @instance
             */
            ServoState.prototype.gain = 0;

            /**
             * Used to set the servo on or off. Typically either 0 (off) or 100 (on)
             * @member {number} torque
             * @memberof message.actuation.ServoState
             * @instance
             */
            ServoState.prototype.torque = 0;

            /**
             * Encodes the specified ServoState message. Does not implicitly {@link message.actuation.ServoState.verify|verify} messages.
             * @function encode
             * @memberof message.actuation.ServoState
             * @static
             * @param {message.actuation.IServoState} message ServoState message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServoState.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.gain != null && Object.hasOwnProperty.call(message, "gain"))
                    writer.uint32(/* id 1, wireType 5 =*/13).float(message.gain);
                if (message.torque != null && Object.hasOwnProperty.call(message, "torque"))
                    writer.uint32(/* id 2, wireType 5 =*/21).float(message.torque);
                return writer;
            };

            /**
             * Decodes a ServoState message from the specified reader or buffer.
             * @function decode
             * @memberof message.actuation.ServoState
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.actuation.ServoState} ServoState
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServoState.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.actuation.ServoState();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.gain = reader.float();
                        break;
                    case 2:
                        message.torque = reader.float();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return ServoState;
        })();

        actuation.ServoCommand = (function() {

            /**
             * Properties of a ServoCommand.
             * @memberof message.actuation
             * @interface IServoCommand
             * @property {google.protobuf.ITimestamp|null} [time] The time that the servo should reach the given position
             * @property {number|null} [position] The position value of the destination in radians.
             * @property {message.actuation.IServoState|null} [state] Gain and torque of the servo
             */

            /**
             * Constructs a new ServoCommand.
             * @memberof message.actuation
             * @classdesc Represents a ServoCommand.
             * @implements IServoCommand
             * @constructor
             * @param {message.actuation.IServoCommand=} [properties] Properties to set
             */
            function ServoCommand(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * The time that the servo should reach the given position
             * @member {google.protobuf.ITimestamp|null|undefined} time
             * @memberof message.actuation.ServoCommand
             * @instance
             */
            ServoCommand.prototype.time = null;

            /**
             * The position value of the destination in radians.
             * @member {number} position
             * @memberof message.actuation.ServoCommand
             * @instance
             */
            ServoCommand.prototype.position = 0;

            /**
             * Gain and torque of the servo
             * @member {message.actuation.IServoState|null|undefined} state
             * @memberof message.actuation.ServoCommand
             * @instance
             */
            ServoCommand.prototype.state = null;

            /**
             * Encodes the specified ServoCommand message. Does not implicitly {@link message.actuation.ServoCommand.verify|verify} messages.
             * @function encode
             * @memberof message.actuation.ServoCommand
             * @static
             * @param {message.actuation.IServoCommand} message ServoCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServoCommand.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                    $root.google.protobuf.Timestamp.encode(message.time, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                    writer.uint32(/* id 2, wireType 5 =*/21).float(message.position);
                if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                    $root.message.actuation.ServoState.encode(message.state, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a ServoCommand message from the specified reader or buffer.
             * @function decode
             * @memberof message.actuation.ServoCommand
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.actuation.ServoCommand} ServoCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServoCommand.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.actuation.ServoCommand();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.time = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.position = reader.float();
                        break;
                    case 3:
                        message.state = $root.message.actuation.ServoState.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return ServoCommand;
        })();

        actuation.RightShoulderPitch = (function() {

            /**
             * Properties of a RightShoulderPitch.
             * @memberof message.actuation
             * @interface IRightShoulderPitch
             * @property {message.actuation.IServoCommand|null} [command] RightShoulderPitch command
             */

            /**
             * Constructs a new RightShoulderPitch.
             * @memberof message.actuation
             * @classdesc Represents a RightShoulderPitch.
             * @implements IRightShoulderPitch
             * @constructor
             * @param {message.actuation.IRightShoulderPitch=} [properties] Properties to set
             */
            function RightShoulderPitch(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RightShoulderPitch command.
             * @member {message.actuation.IServoCommand|null|undefined} command
             * @memberof message.actuation.RightShoulderPitch
             * @instance
             */
            RightShoulderPitch.prototype.command = null;

            /**
             * Encodes the specified RightShoulderPitch message. Does not implicitly {@link message.actuation.RightShoulderPitch.verify|verify} messages.
             * @function encode
             * @memberof message.actuation.RightShoulderPitch
             * @static
             * @param {message.actuation.IRightShoulderPitch} message RightShoulderPitch message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RightShoulderPitch.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.command != null && Object.hasOwnProperty.call(message, "command"))
                    $root.message.actuation.ServoCommand.encode(message.command, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a RightShoulderPitch message from the specified reader or buffer.
             * @function decode
             * @memberof message.actuation.RightShoulderPitch
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.actuation.RightShoulderPitch} RightShoulderPitch
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RightShoulderPitch.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.actuation.RightShoulderPitch();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.command = $root.message.actuation.ServoCommand.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return RightShoulderPitch;
        })();

        actuation.LeftShoulderPitch = (function() {

            /**
             * Properties of a LeftShoulderPitch.
             * @memberof message.actuation
             * @interface ILeftShoulderPitch
             * @property {message.actuation.IServoCommand|null} [command] LeftShoulderPitch command
             */

            /**
             * Constructs a new LeftShoulderPitch.
             * @memberof message.actuation
             * @classdesc Represents a LeftShoulderPitch.
             * @implements ILeftShoulderPitch
             * @constructor
             * @param {message.actuation.ILeftShoulderPitch=} [properties] Properties to set
             */
            function LeftShoulderPitch(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LeftShoulderPitch command.
             * @member {message.actuation.IServoCommand|null|undefined} command
             * @memberof message.actuation.LeftShoulderPitch
             * @instance
             */
            LeftShoulderPitch.prototype.command = null;

            /**
             * Encodes the specified LeftShoulderPitch message. Does not implicitly {@link message.actuation.LeftShoulderPitch.verify|verify} messages.
             * @function encode
             * @memberof message.actuation.LeftShoulderPitch
             * @static
             * @param {message.actuation.ILeftShoulderPitch} message LeftShoulderPitch message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LeftShoulderPitch.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.command != null && Object.hasOwnProperty.call(message, "command"))
                    $root.message.actuation.ServoCommand.encode(message.command, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a LeftShoulderPitch message from the specified reader or buffer.
             * @function decode
             * @memberof message.actuation.LeftShoulderPitch
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.actuation.LeftShoulderPitch} LeftShoulderPitch
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LeftShoulderPitch.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.actuation.LeftShoulderPitch();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.command = $root.message.actuation.ServoCommand.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return LeftShoulderPitch;
        })();

        actuation.RightShoulderRoll = (function() {

            /**
             * Properties of a RightShoulderRoll.
             * @memberof message.actuation
             * @interface IRightShoulderRoll
             * @property {message.actuation.IServoCommand|null} [command] RightShoulderRoll command
             */

            /**
             * Constructs a new RightShoulderRoll.
             * @memberof message.actuation
             * @classdesc Represents a RightShoulderRoll.
             * @implements IRightShoulderRoll
             * @constructor
             * @param {message.actuation.IRightShoulderRoll=} [properties] Properties to set
             */
            function RightShoulderRoll(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RightShoulderRoll command.
             * @member {message.actuation.IServoCommand|null|undefined} command
             * @memberof message.actuation.RightShoulderRoll
             * @instance
             */
            RightShoulderRoll.prototype.command = null;

            /**
             * Encodes the specified RightShoulderRoll message. Does not implicitly {@link message.actuation.RightShoulderRoll.verify|verify} messages.
             * @function encode
             * @memberof message.actuation.RightShoulderRoll
             * @static
             * @param {message.actuation.IRightShoulderRoll} message RightShoulderRoll message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RightShoulderRoll.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.command != null && Object.hasOwnProperty.call(message, "command"))
                    $root.message.actuation.ServoCommand.encode(message.command, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a RightShoulderRoll message from the specified reader or buffer.
             * @function decode
             * @memberof message.actuation.RightShoulderRoll
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.actuation.RightShoulderRoll} RightShoulderRoll
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RightShoulderRoll.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.actuation.RightShoulderRoll();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.command = $root.message.actuation.ServoCommand.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return RightShoulderRoll;
        })();

        actuation.LeftShoulderRoll = (function() {

            /**
             * Properties of a LeftShoulderRoll.
             * @memberof message.actuation
             * @interface ILeftShoulderRoll
             * @property {message.actuation.IServoCommand|null} [command] LeftShoulderRoll command
             */

            /**
             * Constructs a new LeftShoulderRoll.
             * @memberof message.actuation
             * @classdesc Represents a LeftShoulderRoll.
             * @implements ILeftShoulderRoll
             * @constructor
             * @param {message.actuation.ILeftShoulderRoll=} [properties] Properties to set
             */
            function LeftShoulderRoll(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LeftShoulderRoll command.
             * @member {message.actuation.IServoCommand|null|undefined} command
             * @memberof message.actuation.LeftShoulderRoll
             * @instance
             */
            LeftShoulderRoll.prototype.command = null;

            /**
             * Encodes the specified LeftShoulderRoll message. Does not implicitly {@link message.actuation.LeftShoulderRoll.verify|verify} messages.
             * @function encode
             * @memberof message.actuation.LeftShoulderRoll
             * @static
             * @param {message.actuation.ILeftShoulderRoll} message LeftShoulderRoll message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LeftShoulderRoll.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.command != null && Object.hasOwnProperty.call(message, "command"))
                    $root.message.actuation.ServoCommand.encode(message.command, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a LeftShoulderRoll message from the specified reader or buffer.
             * @function decode
             * @memberof message.actuation.LeftShoulderRoll
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.actuation.LeftShoulderRoll} LeftShoulderRoll
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LeftShoulderRoll.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.actuation.LeftShoulderRoll();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.command = $root.message.actuation.ServoCommand.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return LeftShoulderRoll;
        })();

        actuation.RightElbow = (function() {

            /**
             * Properties of a RightElbow.
             * @memberof message.actuation
             * @interface IRightElbow
             * @property {message.actuation.IServoCommand|null} [command] RightElbow command
             */

            /**
             * Constructs a new RightElbow.
             * @memberof message.actuation
             * @classdesc Represents a RightElbow.
             * @implements IRightElbow
             * @constructor
             * @param {message.actuation.IRightElbow=} [properties] Properties to set
             */
            function RightElbow(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RightElbow command.
             * @member {message.actuation.IServoCommand|null|undefined} command
             * @memberof message.actuation.RightElbow
             * @instance
             */
            RightElbow.prototype.command = null;

            /**
             * Encodes the specified RightElbow message. Does not implicitly {@link message.actuation.RightElbow.verify|verify} messages.
             * @function encode
             * @memberof message.actuation.RightElbow
             * @static
             * @param {message.actuation.IRightElbow} message RightElbow message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RightElbow.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.command != null && Object.hasOwnProperty.call(message, "command"))
                    $root.message.actuation.ServoCommand.encode(message.command, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a RightElbow message from the specified reader or buffer.
             * @function decode
             * @memberof message.actuation.RightElbow
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.actuation.RightElbow} RightElbow
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RightElbow.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.actuation.RightElbow();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.command = $root.message.actuation.ServoCommand.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return RightElbow;
        })();

        actuation.LeftElbow = (function() {

            /**
             * Properties of a LeftElbow.
             * @memberof message.actuation
             * @interface ILeftElbow
             * @property {message.actuation.IServoCommand|null} [command] LeftElbow command
             */

            /**
             * Constructs a new LeftElbow.
             * @memberof message.actuation
             * @classdesc Represents a LeftElbow.
             * @implements ILeftElbow
             * @constructor
             * @param {message.actuation.ILeftElbow=} [properties] Properties to set
             */
            function LeftElbow(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LeftElbow command.
             * @member {message.actuation.IServoCommand|null|undefined} command
             * @memberof message.actuation.LeftElbow
             * @instance
             */
            LeftElbow.prototype.command = null;

            /**
             * Encodes the specified LeftElbow message. Does not implicitly {@link message.actuation.LeftElbow.verify|verify} messages.
             * @function encode
             * @memberof message.actuation.LeftElbow
             * @static
             * @param {message.actuation.ILeftElbow} message LeftElbow message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LeftElbow.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.command != null && Object.hasOwnProperty.call(message, "command"))
                    $root.message.actuation.ServoCommand.encode(message.command, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a LeftElbow message from the specified reader or buffer.
             * @function decode
             * @memberof message.actuation.LeftElbow
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.actuation.LeftElbow} LeftElbow
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LeftElbow.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.actuation.LeftElbow();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.command = $root.message.actuation.ServoCommand.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return LeftElbow;
        })();

        actuation.RightHipYaw = (function() {

            /**
             * Properties of a RightHipYaw.
             * @memberof message.actuation
             * @interface IRightHipYaw
             * @property {message.actuation.IServoCommand|null} [command] RightHipYaw command
             */

            /**
             * Constructs a new RightHipYaw.
             * @memberof message.actuation
             * @classdesc Represents a RightHipYaw.
             * @implements IRightHipYaw
             * @constructor
             * @param {message.actuation.IRightHipYaw=} [properties] Properties to set
             */
            function RightHipYaw(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RightHipYaw command.
             * @member {message.actuation.IServoCommand|null|undefined} command
             * @memberof message.actuation.RightHipYaw
             * @instance
             */
            RightHipYaw.prototype.command = null;

            /**
             * Encodes the specified RightHipYaw message. Does not implicitly {@link message.actuation.RightHipYaw.verify|verify} messages.
             * @function encode
             * @memberof message.actuation.RightHipYaw
             * @static
             * @param {message.actuation.IRightHipYaw} message RightHipYaw message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RightHipYaw.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.command != null && Object.hasOwnProperty.call(message, "command"))
                    $root.message.actuation.ServoCommand.encode(message.command, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a RightHipYaw message from the specified reader or buffer.
             * @function decode
             * @memberof message.actuation.RightHipYaw
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.actuation.RightHipYaw} RightHipYaw
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RightHipYaw.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.actuation.RightHipYaw();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.command = $root.message.actuation.ServoCommand.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return RightHipYaw;
        })();

        actuation.LeftHipYaw = (function() {

            /**
             * Properties of a LeftHipYaw.
             * @memberof message.actuation
             * @interface ILeftHipYaw
             * @property {message.actuation.IServoCommand|null} [command] LeftHipYaw command
             */

            /**
             * Constructs a new LeftHipYaw.
             * @memberof message.actuation
             * @classdesc Represents a LeftHipYaw.
             * @implements ILeftHipYaw
             * @constructor
             * @param {message.actuation.ILeftHipYaw=} [properties] Properties to set
             */
            function LeftHipYaw(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LeftHipYaw command.
             * @member {message.actuation.IServoCommand|null|undefined} command
             * @memberof message.actuation.LeftHipYaw
             * @instance
             */
            LeftHipYaw.prototype.command = null;

            /**
             * Encodes the specified LeftHipYaw message. Does not implicitly {@link message.actuation.LeftHipYaw.verify|verify} messages.
             * @function encode
             * @memberof message.actuation.LeftHipYaw
             * @static
             * @param {message.actuation.ILeftHipYaw} message LeftHipYaw message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LeftHipYaw.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.command != null && Object.hasOwnProperty.call(message, "command"))
                    $root.message.actuation.ServoCommand.encode(message.command, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a LeftHipYaw message from the specified reader or buffer.
             * @function decode
             * @memberof message.actuation.LeftHipYaw
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.actuation.LeftHipYaw} LeftHipYaw
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LeftHipYaw.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.actuation.LeftHipYaw();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.command = $root.message.actuation.ServoCommand.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return LeftHipYaw;
        })();

        actuation.RightHipRoll = (function() {

            /**
             * Properties of a RightHipRoll.
             * @memberof message.actuation
             * @interface IRightHipRoll
             * @property {message.actuation.IServoCommand|null} [command] RightHipRoll command
             */

            /**
             * Constructs a new RightHipRoll.
             * @memberof message.actuation
             * @classdesc Represents a RightHipRoll.
             * @implements IRightHipRoll
             * @constructor
             * @param {message.actuation.IRightHipRoll=} [properties] Properties to set
             */
            function RightHipRoll(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RightHipRoll command.
             * @member {message.actuation.IServoCommand|null|undefined} command
             * @memberof message.actuation.RightHipRoll
             * @instance
             */
            RightHipRoll.prototype.command = null;

            /**
             * Encodes the specified RightHipRoll message. Does not implicitly {@link message.actuation.RightHipRoll.verify|verify} messages.
             * @function encode
             * @memberof message.actuation.RightHipRoll
             * @static
             * @param {message.actuation.IRightHipRoll} message RightHipRoll message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RightHipRoll.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.command != null && Object.hasOwnProperty.call(message, "command"))
                    $root.message.actuation.ServoCommand.encode(message.command, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a RightHipRoll message from the specified reader or buffer.
             * @function decode
             * @memberof message.actuation.RightHipRoll
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.actuation.RightHipRoll} RightHipRoll
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RightHipRoll.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.actuation.RightHipRoll();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.command = $root.message.actuation.ServoCommand.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return RightHipRoll;
        })();

        actuation.LeftHipRoll = (function() {

            /**
             * Properties of a LeftHipRoll.
             * @memberof message.actuation
             * @interface ILeftHipRoll
             * @property {message.actuation.IServoCommand|null} [command] LeftHipRoll command
             */

            /**
             * Constructs a new LeftHipRoll.
             * @memberof message.actuation
             * @classdesc Represents a LeftHipRoll.
             * @implements ILeftHipRoll
             * @constructor
             * @param {message.actuation.ILeftHipRoll=} [properties] Properties to set
             */
            function LeftHipRoll(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LeftHipRoll command.
             * @member {message.actuation.IServoCommand|null|undefined} command
             * @memberof message.actuation.LeftHipRoll
             * @instance
             */
            LeftHipRoll.prototype.command = null;

            /**
             * Encodes the specified LeftHipRoll message. Does not implicitly {@link message.actuation.LeftHipRoll.verify|verify} messages.
             * @function encode
             * @memberof message.actuation.LeftHipRoll
             * @static
             * @param {message.actuation.ILeftHipRoll} message LeftHipRoll message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LeftHipRoll.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.command != null && Object.hasOwnProperty.call(message, "command"))
                    $root.message.actuation.ServoCommand.encode(message.command, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a LeftHipRoll message from the specified reader or buffer.
             * @function decode
             * @memberof message.actuation.LeftHipRoll
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.actuation.LeftHipRoll} LeftHipRoll
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LeftHipRoll.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.actuation.LeftHipRoll();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.command = $root.message.actuation.ServoCommand.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return LeftHipRoll;
        })();

        actuation.RightHipPitch = (function() {

            /**
             * Properties of a RightHipPitch.
             * @memberof message.actuation
             * @interface IRightHipPitch
             * @property {message.actuation.IServoCommand|null} [command] RightHipPitch command
             */

            /**
             * Constructs a new RightHipPitch.
             * @memberof message.actuation
             * @classdesc Represents a RightHipPitch.
             * @implements IRightHipPitch
             * @constructor
             * @param {message.actuation.IRightHipPitch=} [properties] Properties to set
             */
            function RightHipPitch(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RightHipPitch command.
             * @member {message.actuation.IServoCommand|null|undefined} command
             * @memberof message.actuation.RightHipPitch
             * @instance
             */
            RightHipPitch.prototype.command = null;

            /**
             * Encodes the specified RightHipPitch message. Does not implicitly {@link message.actuation.RightHipPitch.verify|verify} messages.
             * @function encode
             * @memberof message.actuation.RightHipPitch
             * @static
             * @param {message.actuation.IRightHipPitch} message RightHipPitch message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RightHipPitch.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.command != null && Object.hasOwnProperty.call(message, "command"))
                    $root.message.actuation.ServoCommand.encode(message.command, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a RightHipPitch message from the specified reader or buffer.
             * @function decode
             * @memberof message.actuation.RightHipPitch
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.actuation.RightHipPitch} RightHipPitch
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RightHipPitch.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.actuation.RightHipPitch();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.command = $root.message.actuation.ServoCommand.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return RightHipPitch;
        })();

        actuation.LeftHipPitch = (function() {

            /**
             * Properties of a LeftHipPitch.
             * @memberof message.actuation
             * @interface ILeftHipPitch
             * @property {message.actuation.IServoCommand|null} [command] LeftHipPitch command
             */

            /**
             * Constructs a new LeftHipPitch.
             * @memberof message.actuation
             * @classdesc Represents a LeftHipPitch.
             * @implements ILeftHipPitch
             * @constructor
             * @param {message.actuation.ILeftHipPitch=} [properties] Properties to set
             */
            function LeftHipPitch(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LeftHipPitch command.
             * @member {message.actuation.IServoCommand|null|undefined} command
             * @memberof message.actuation.LeftHipPitch
             * @instance
             */
            LeftHipPitch.prototype.command = null;

            /**
             * Encodes the specified LeftHipPitch message. Does not implicitly {@link message.actuation.LeftHipPitch.verify|verify} messages.
             * @function encode
             * @memberof message.actuation.LeftHipPitch
             * @static
             * @param {message.actuation.ILeftHipPitch} message LeftHipPitch message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LeftHipPitch.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.command != null && Object.hasOwnProperty.call(message, "command"))
                    $root.message.actuation.ServoCommand.encode(message.command, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a LeftHipPitch message from the specified reader or buffer.
             * @function decode
             * @memberof message.actuation.LeftHipPitch
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.actuation.LeftHipPitch} LeftHipPitch
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LeftHipPitch.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.actuation.LeftHipPitch();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.command = $root.message.actuation.ServoCommand.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return LeftHipPitch;
        })();

        actuation.RightKnee = (function() {

            /**
             * Properties of a RightKnee.
             * @memberof message.actuation
             * @interface IRightKnee
             * @property {message.actuation.IServoCommand|null} [command] RightKnee command
             */

            /**
             * Constructs a new RightKnee.
             * @memberof message.actuation
             * @classdesc Represents a RightKnee.
             * @implements IRightKnee
             * @constructor
             * @param {message.actuation.IRightKnee=} [properties] Properties to set
             */
            function RightKnee(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RightKnee command.
             * @member {message.actuation.IServoCommand|null|undefined} command
             * @memberof message.actuation.RightKnee
             * @instance
             */
            RightKnee.prototype.command = null;

            /**
             * Encodes the specified RightKnee message. Does not implicitly {@link message.actuation.RightKnee.verify|verify} messages.
             * @function encode
             * @memberof message.actuation.RightKnee
             * @static
             * @param {message.actuation.IRightKnee} message RightKnee message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RightKnee.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.command != null && Object.hasOwnProperty.call(message, "command"))
                    $root.message.actuation.ServoCommand.encode(message.command, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a RightKnee message from the specified reader or buffer.
             * @function decode
             * @memberof message.actuation.RightKnee
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.actuation.RightKnee} RightKnee
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RightKnee.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.actuation.RightKnee();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.command = $root.message.actuation.ServoCommand.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return RightKnee;
        })();

        actuation.LeftKnee = (function() {

            /**
             * Properties of a LeftKnee.
             * @memberof message.actuation
             * @interface ILeftKnee
             * @property {message.actuation.IServoCommand|null} [command] LeftKnee command
             */

            /**
             * Constructs a new LeftKnee.
             * @memberof message.actuation
             * @classdesc Represents a LeftKnee.
             * @implements ILeftKnee
             * @constructor
             * @param {message.actuation.ILeftKnee=} [properties] Properties to set
             */
            function LeftKnee(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LeftKnee command.
             * @member {message.actuation.IServoCommand|null|undefined} command
             * @memberof message.actuation.LeftKnee
             * @instance
             */
            LeftKnee.prototype.command = null;

            /**
             * Encodes the specified LeftKnee message. Does not implicitly {@link message.actuation.LeftKnee.verify|verify} messages.
             * @function encode
             * @memberof message.actuation.LeftKnee
             * @static
             * @param {message.actuation.ILeftKnee} message LeftKnee message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LeftKnee.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.command != null && Object.hasOwnProperty.call(message, "command"))
                    $root.message.actuation.ServoCommand.encode(message.command, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a LeftKnee message from the specified reader or buffer.
             * @function decode
             * @memberof message.actuation.LeftKnee
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.actuation.LeftKnee} LeftKnee
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LeftKnee.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.actuation.LeftKnee();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.command = $root.message.actuation.ServoCommand.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return LeftKnee;
        })();

        actuation.RightAnklePitch = (function() {

            /**
             * Properties of a RightAnklePitch.
             * @memberof message.actuation
             * @interface IRightAnklePitch
             * @property {message.actuation.IServoCommand|null} [command] RightAnklePitch command
             */

            /**
             * Constructs a new RightAnklePitch.
             * @memberof message.actuation
             * @classdesc Represents a RightAnklePitch.
             * @implements IRightAnklePitch
             * @constructor
             * @param {message.actuation.IRightAnklePitch=} [properties] Properties to set
             */
            function RightAnklePitch(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RightAnklePitch command.
             * @member {message.actuation.IServoCommand|null|undefined} command
             * @memberof message.actuation.RightAnklePitch
             * @instance
             */
            RightAnklePitch.prototype.command = null;

            /**
             * Encodes the specified RightAnklePitch message. Does not implicitly {@link message.actuation.RightAnklePitch.verify|verify} messages.
             * @function encode
             * @memberof message.actuation.RightAnklePitch
             * @static
             * @param {message.actuation.IRightAnklePitch} message RightAnklePitch message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RightAnklePitch.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.command != null && Object.hasOwnProperty.call(message, "command"))
                    $root.message.actuation.ServoCommand.encode(message.command, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a RightAnklePitch message from the specified reader or buffer.
             * @function decode
             * @memberof message.actuation.RightAnklePitch
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.actuation.RightAnklePitch} RightAnklePitch
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RightAnklePitch.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.actuation.RightAnklePitch();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.command = $root.message.actuation.ServoCommand.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return RightAnklePitch;
        })();

        actuation.LeftAnklePitch = (function() {

            /**
             * Properties of a LeftAnklePitch.
             * @memberof message.actuation
             * @interface ILeftAnklePitch
             * @property {message.actuation.IServoCommand|null} [command] LeftAnklePitch command
             */

            /**
             * Constructs a new LeftAnklePitch.
             * @memberof message.actuation
             * @classdesc Represents a LeftAnklePitch.
             * @implements ILeftAnklePitch
             * @constructor
             * @param {message.actuation.ILeftAnklePitch=} [properties] Properties to set
             */
            function LeftAnklePitch(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LeftAnklePitch command.
             * @member {message.actuation.IServoCommand|null|undefined} command
             * @memberof message.actuation.LeftAnklePitch
             * @instance
             */
            LeftAnklePitch.prototype.command = null;

            /**
             * Encodes the specified LeftAnklePitch message. Does not implicitly {@link message.actuation.LeftAnklePitch.verify|verify} messages.
             * @function encode
             * @memberof message.actuation.LeftAnklePitch
             * @static
             * @param {message.actuation.ILeftAnklePitch} message LeftAnklePitch message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LeftAnklePitch.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.command != null && Object.hasOwnProperty.call(message, "command"))
                    $root.message.actuation.ServoCommand.encode(message.command, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a LeftAnklePitch message from the specified reader or buffer.
             * @function decode
             * @memberof message.actuation.LeftAnklePitch
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.actuation.LeftAnklePitch} LeftAnklePitch
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LeftAnklePitch.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.actuation.LeftAnklePitch();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.command = $root.message.actuation.ServoCommand.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return LeftAnklePitch;
        })();

        actuation.RightAnkleRoll = (function() {

            /**
             * Properties of a RightAnkleRoll.
             * @memberof message.actuation
             * @interface IRightAnkleRoll
             * @property {message.actuation.IServoCommand|null} [command] RightAnkleRoll command
             */

            /**
             * Constructs a new RightAnkleRoll.
             * @memberof message.actuation
             * @classdesc Represents a RightAnkleRoll.
             * @implements IRightAnkleRoll
             * @constructor
             * @param {message.actuation.IRightAnkleRoll=} [properties] Properties to set
             */
            function RightAnkleRoll(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RightAnkleRoll command.
             * @member {message.actuation.IServoCommand|null|undefined} command
             * @memberof message.actuation.RightAnkleRoll
             * @instance
             */
            RightAnkleRoll.prototype.command = null;

            /**
             * Encodes the specified RightAnkleRoll message. Does not implicitly {@link message.actuation.RightAnkleRoll.verify|verify} messages.
             * @function encode
             * @memberof message.actuation.RightAnkleRoll
             * @static
             * @param {message.actuation.IRightAnkleRoll} message RightAnkleRoll message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RightAnkleRoll.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.command != null && Object.hasOwnProperty.call(message, "command"))
                    $root.message.actuation.ServoCommand.encode(message.command, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a RightAnkleRoll message from the specified reader or buffer.
             * @function decode
             * @memberof message.actuation.RightAnkleRoll
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.actuation.RightAnkleRoll} RightAnkleRoll
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RightAnkleRoll.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.actuation.RightAnkleRoll();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.command = $root.message.actuation.ServoCommand.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return RightAnkleRoll;
        })();

        actuation.LeftAnkleRoll = (function() {

            /**
             * Properties of a LeftAnkleRoll.
             * @memberof message.actuation
             * @interface ILeftAnkleRoll
             * @property {message.actuation.IServoCommand|null} [command] LeftAnkleRoll command
             */

            /**
             * Constructs a new LeftAnkleRoll.
             * @memberof message.actuation
             * @classdesc Represents a LeftAnkleRoll.
             * @implements ILeftAnkleRoll
             * @constructor
             * @param {message.actuation.ILeftAnkleRoll=} [properties] Properties to set
             */
            function LeftAnkleRoll(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LeftAnkleRoll command.
             * @member {message.actuation.IServoCommand|null|undefined} command
             * @memberof message.actuation.LeftAnkleRoll
             * @instance
             */
            LeftAnkleRoll.prototype.command = null;

            /**
             * Encodes the specified LeftAnkleRoll message. Does not implicitly {@link message.actuation.LeftAnkleRoll.verify|verify} messages.
             * @function encode
             * @memberof message.actuation.LeftAnkleRoll
             * @static
             * @param {message.actuation.ILeftAnkleRoll} message LeftAnkleRoll message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LeftAnkleRoll.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.command != null && Object.hasOwnProperty.call(message, "command"))
                    $root.message.actuation.ServoCommand.encode(message.command, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a LeftAnkleRoll message from the specified reader or buffer.
             * @function decode
             * @memberof message.actuation.LeftAnkleRoll
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.actuation.LeftAnkleRoll} LeftAnkleRoll
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LeftAnkleRoll.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.actuation.LeftAnkleRoll();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.command = $root.message.actuation.ServoCommand.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return LeftAnkleRoll;
        })();

        actuation.HeadYaw = (function() {

            /**
             * Properties of a HeadYaw.
             * @memberof message.actuation
             * @interface IHeadYaw
             * @property {message.actuation.IServoCommand|null} [command] HeadYaw command
             */

            /**
             * Constructs a new HeadYaw.
             * @memberof message.actuation
             * @classdesc Represents a HeadYaw.
             * @implements IHeadYaw
             * @constructor
             * @param {message.actuation.IHeadYaw=} [properties] Properties to set
             */
            function HeadYaw(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * HeadYaw command.
             * @member {message.actuation.IServoCommand|null|undefined} command
             * @memberof message.actuation.HeadYaw
             * @instance
             */
            HeadYaw.prototype.command = null;

            /**
             * Encodes the specified HeadYaw message. Does not implicitly {@link message.actuation.HeadYaw.verify|verify} messages.
             * @function encode
             * @memberof message.actuation.HeadYaw
             * @static
             * @param {message.actuation.IHeadYaw} message HeadYaw message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HeadYaw.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.command != null && Object.hasOwnProperty.call(message, "command"))
                    $root.message.actuation.ServoCommand.encode(message.command, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a HeadYaw message from the specified reader or buffer.
             * @function decode
             * @memberof message.actuation.HeadYaw
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.actuation.HeadYaw} HeadYaw
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HeadYaw.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.actuation.HeadYaw();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.command = $root.message.actuation.ServoCommand.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return HeadYaw;
        })();

        actuation.HeadPitch = (function() {

            /**
             * Properties of a HeadPitch.
             * @memberof message.actuation
             * @interface IHeadPitch
             * @property {message.actuation.IServoCommand|null} [command] HeadPitch command
             */

            /**
             * Constructs a new HeadPitch.
             * @memberof message.actuation
             * @classdesc Represents a HeadPitch.
             * @implements IHeadPitch
             * @constructor
             * @param {message.actuation.IHeadPitch=} [properties] Properties to set
             */
            function HeadPitch(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * HeadPitch command.
             * @member {message.actuation.IServoCommand|null|undefined} command
             * @memberof message.actuation.HeadPitch
             * @instance
             */
            HeadPitch.prototype.command = null;

            /**
             * Encodes the specified HeadPitch message. Does not implicitly {@link message.actuation.HeadPitch.verify|verify} messages.
             * @function encode
             * @memberof message.actuation.HeadPitch
             * @static
             * @param {message.actuation.IHeadPitch} message HeadPitch message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HeadPitch.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.command != null && Object.hasOwnProperty.call(message, "command"))
                    $root.message.actuation.ServoCommand.encode(message.command, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a HeadPitch message from the specified reader or buffer.
             * @function decode
             * @memberof message.actuation.HeadPitch
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.actuation.HeadPitch} HeadPitch
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HeadPitch.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.actuation.HeadPitch();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.command = $root.message.actuation.ServoCommand.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return HeadPitch;
        })();

        actuation.ServoTarget = (function() {

            /**
             * Properties of a ServoTarget.
             * @memberof message.actuation
             * @interface IServoTarget
             * @property {google.protobuf.ITimestamp|null} [time] When the target was created
             * @property {number|null} [id] The ID of the servo being controlled
             * @property {number|null} [position] triggered as set in Alarm LED/Shutdown
             * @property {number|null} [gain] values are in range 0~254. K_p : p_gain / 8
             * @property {number|null} [torque] Used to set the servo on or off. Typically either 0 (off) or 100 (on)
             */

            /**
             * Constructs a new ServoTarget.
             * @memberof message.actuation
             * @classdesc @author Trent Houliston
             * @implements IServoTarget
             * @constructor
             * @param {message.actuation.IServoTarget=} [properties] Properties to set
             */
            function ServoTarget(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * When the target was created
             * @member {google.protobuf.ITimestamp|null|undefined} time
             * @memberof message.actuation.ServoTarget
             * @instance
             */
            ServoTarget.prototype.time = null;

            /**
             * The ID of the servo being controlled
             * @member {number} id
             * @memberof message.actuation.ServoTarget
             * @instance
             */
            ServoTarget.prototype.id = 0;

            /**
             * triggered as set in Alarm LED/Shutdown
             * @member {number} position
             * @memberof message.actuation.ServoTarget
             * @instance
             */
            ServoTarget.prototype.position = 0;

            /**
             * values are in range 0~254. K_p : p_gain / 8
             * @member {number} gain
             * @memberof message.actuation.ServoTarget
             * @instance
             */
            ServoTarget.prototype.gain = 0;

            /**
             * Used to set the servo on or off. Typically either 0 (off) or 100 (on)
             * @member {number} torque
             * @memberof message.actuation.ServoTarget
             * @instance
             */
            ServoTarget.prototype.torque = 0;

            /**
             * Encodes the specified ServoTarget message. Does not implicitly {@link message.actuation.ServoTarget.verify|verify} messages.
             * @function encode
             * @memberof message.actuation.ServoTarget
             * @static
             * @param {message.actuation.IServoTarget} message ServoTarget message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServoTarget.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                    $root.google.protobuf.Timestamp.encode(message.time, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.id);
                if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                    writer.uint32(/* id 3, wireType 5 =*/29).float(message.position);
                if (message.gain != null && Object.hasOwnProperty.call(message, "gain"))
                    writer.uint32(/* id 4, wireType 5 =*/37).float(message.gain);
                if (message.torque != null && Object.hasOwnProperty.call(message, "torque"))
                    writer.uint32(/* id 5, wireType 5 =*/45).float(message.torque);
                return writer;
            };

            /**
             * Decodes a ServoTarget message from the specified reader or buffer.
             * @function decode
             * @memberof message.actuation.ServoTarget
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.actuation.ServoTarget} ServoTarget
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServoTarget.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.actuation.ServoTarget();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.time = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.id = reader.uint32();
                        break;
                    case 3:
                        message.position = reader.float();
                        break;
                    case 4:
                        message.gain = reader.float();
                        break;
                    case 5:
                        message.torque = reader.float();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return ServoTarget;
        })();

        actuation.ServoTargets = (function() {

            /**
             * Properties of a ServoTargets.
             * @memberof message.actuation
             * @interface IServoTargets
             * @property {Array.<message.actuation.IServoTarget>|null} [targets] ServoTargets targets
             */

            /**
             * Constructs a new ServoTargets.
             * @memberof message.actuation
             * @classdesc Represents a ServoTargets.
             * @implements IServoTargets
             * @constructor
             * @param {message.actuation.IServoTargets=} [properties] Properties to set
             */
            function ServoTargets(properties) {
                this.targets = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ServoTargets targets.
             * @member {Array.<message.actuation.IServoTarget>} targets
             * @memberof message.actuation.ServoTargets
             * @instance
             */
            ServoTargets.prototype.targets = $util.emptyArray;

            /**
             * Encodes the specified ServoTargets message. Does not implicitly {@link message.actuation.ServoTargets.verify|verify} messages.
             * @function encode
             * @memberof message.actuation.ServoTargets
             * @static
             * @param {message.actuation.IServoTargets} message ServoTargets message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServoTargets.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.targets != null && message.targets.length)
                    for (let i = 0; i < message.targets.length; ++i)
                        $root.message.actuation.ServoTarget.encode(message.targets[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a ServoTargets message from the specified reader or buffer.
             * @function decode
             * @memberof message.actuation.ServoTargets
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.actuation.ServoTargets} ServoTargets
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServoTargets.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.actuation.ServoTargets();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.targets && message.targets.length))
                            message.targets = [];
                        message.targets.push($root.message.actuation.ServoTarget.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return ServoTargets;
        })();

        return actuation;
    })();

    message.behaviour = (function() {

        /**
         * Namespace behaviour.
         * @memberof message
         * @namespace
         */
        const behaviour = {};

        behaviour.Behaviour = (function() {

            /**
             * Properties of a Behaviour.
             * @memberof message.behaviour
             * @interface IBehaviour
             * @property {message.behaviour.Behaviour.State|null} [state] Behaviour state
             */

            /**
             * Constructs a new Behaviour.
             * @memberof message.behaviour
             * @classdesc Represents a Behaviour.
             * @implements IBehaviour
             * @constructor
             * @param {message.behaviour.IBehaviour=} [properties] Properties to set
             */
            function Behaviour(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Behaviour state.
             * @member {message.behaviour.Behaviour.State} state
             * @memberof message.behaviour.Behaviour
             * @instance
             */
            Behaviour.prototype.state = 0;

            /**
             * Encodes the specified Behaviour message. Does not implicitly {@link message.behaviour.Behaviour.verify|verify} messages.
             * @function encode
             * @memberof message.behaviour.Behaviour
             * @static
             * @param {message.behaviour.IBehaviour} message Behaviour message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Behaviour.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.state);
                return writer;
            };

            /**
             * Decodes a Behaviour message from the specified reader or buffer.
             * @function decode
             * @memberof message.behaviour.Behaviour
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.behaviour.Behaviour} Behaviour
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Behaviour.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.behaviour.Behaviour();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.state = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * State enum.
             * @name message.behaviour.Behaviour.State
             * @enum {number}
             * @property {number} UNKNOWN=0 UNKNOWN value
             * @property {number} INIT=1 INIT value
             * @property {number} SEARCH_FOR_BALL=2 SEARCH_FOR_BALL value
             * @property {number} SEARCH_FOR_GOALS=3 SEARCH_FOR_GOALS value
             * @property {number} WALK_TO_BALL=4 WALK_TO_BALL value
             * @property {number} PICKED_UP=5 PICKED_UP value
             * @property {number} INITIAL=6 INITIAL value
             * @property {number} READY=7 READY value
             * @property {number} SET=8 SET value
             * @property {number} TIMEOUT=9 TIMEOUT value
             * @property {number} FINISHED=10 FINISHED value
             * @property {number} PENALISED=11 PENALISED value
             * @property {number} GOALIE_WALK=12 GOALIE_WALK value
             * @property {number} MOVE_TO_CENTRE=13 MOVE_TO_CENTRE value
             * @property {number} LOCALISING=14 LOCALISING value
             * @property {number} SHOOTOUT=15 SHOOTOUT value
             */
            Behaviour.State = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN"] = 0;
                values[valuesById[1] = "INIT"] = 1;
                values[valuesById[2] = "SEARCH_FOR_BALL"] = 2;
                values[valuesById[3] = "SEARCH_FOR_GOALS"] = 3;
                values[valuesById[4] = "WALK_TO_BALL"] = 4;
                values[valuesById[5] = "PICKED_UP"] = 5;
                values[valuesById[6] = "INITIAL"] = 6;
                values[valuesById[7] = "READY"] = 7;
                values[valuesById[8] = "SET"] = 8;
                values[valuesById[9] = "TIMEOUT"] = 9;
                values[valuesById[10] = "FINISHED"] = 10;
                values[valuesById[11] = "PENALISED"] = 11;
                values[valuesById[12] = "GOALIE_WALK"] = 12;
                values[valuesById[13] = "MOVE_TO_CENTRE"] = 13;
                values[valuesById[14] = "LOCALISING"] = 14;
                values[valuesById[15] = "SHOOTOUT"] = 15;
                return values;
            })();

            return Behaviour;
        })();

        behaviour.KickPlan = (function() {

            /**
             * Properties of a KickPlan.
             * @memberof message.behaviour
             * @interface IKickPlan
             * @property {Ivec2|null} [target] Where the robot wants to kick to. In field space
             * @property {message.behaviour.KickPlan.KickType|null} [kickType] KickPlan kickType
             */

            /**
             * Constructs a new KickPlan.
             * @memberof message.behaviour
             * @classdesc Represents a KickPlan.
             * @implements IKickPlan
             * @constructor
             * @param {message.behaviour.IKickPlan=} [properties] Properties to set
             */
            function KickPlan(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Where the robot wants to kick to. In field space
             * @member {Ivec2|null|undefined} target
             * @memberof message.behaviour.KickPlan
             * @instance
             */
            KickPlan.prototype.target = null;

            /**
             * KickPlan kickType.
             * @member {message.behaviour.KickPlan.KickType} kickType
             * @memberof message.behaviour.KickPlan
             * @instance
             */
            KickPlan.prototype.kickType = 0;

            /**
             * Encodes the specified KickPlan message. Does not implicitly {@link message.behaviour.KickPlan.verify|verify} messages.
             * @function encode
             * @memberof message.behaviour.KickPlan
             * @static
             * @param {message.behaviour.IKickPlan} message KickPlan message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KickPlan.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                    $root.vec2.encode(message.target, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.kickType != null && Object.hasOwnProperty.call(message, "kickType"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.kickType);
                return writer;
            };

            /**
             * Decodes a KickPlan message from the specified reader or buffer.
             * @function decode
             * @memberof message.behaviour.KickPlan
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.behaviour.KickPlan} KickPlan
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KickPlan.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.behaviour.KickPlan();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.target = $root.vec2.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.kickType = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * KickType enum.
             * @name message.behaviour.KickPlan.KickType
             * @enum {number}
             * @property {number} SCRIPTED=0 SCRIPTED value
             * @property {number} IK_KICK=1 IK_KICK value
             * @property {number} PENALTY=2 PENALTY value
             */
            KickPlan.KickType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "SCRIPTED"] = 0;
                values[valuesById[1] = "IK_KICK"] = 1;
                values[valuesById[2] = "PENALTY"] = 2;
                return values;
            })();

            return KickPlan;
        })();

        behaviour.WantsToKick = (function() {

            /**
             * Properties of a WantsToKick.
             * @memberof message.behaviour
             * @interface IWantsToKick
             * @property {boolean|null} [kick] WantsToKick kick
             */

            /**
             * Constructs a new WantsToKick.
             * @memberof message.behaviour
             * @classdesc Represents a WantsToKick.
             * @implements IWantsToKick
             * @constructor
             * @param {message.behaviour.IWantsToKick=} [properties] Properties to set
             */
            function WantsToKick(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WantsToKick kick.
             * @member {boolean} kick
             * @memberof message.behaviour.WantsToKick
             * @instance
             */
            WantsToKick.prototype.kick = false;

            /**
             * Encodes the specified WantsToKick message. Does not implicitly {@link message.behaviour.WantsToKick.verify|verify} messages.
             * @function encode
             * @memberof message.behaviour.WantsToKick
             * @static
             * @param {message.behaviour.IWantsToKick} message WantsToKick message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WantsToKick.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.kick != null && Object.hasOwnProperty.call(message, "kick"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.kick);
                return writer;
            };

            /**
             * Decodes a WantsToKick message from the specified reader or buffer.
             * @function decode
             * @memberof message.behaviour.WantsToKick
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.behaviour.WantsToKick} WantsToKick
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WantsToKick.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.behaviour.WantsToKick();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.kick = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return WantsToKick;
        })();

        behaviour.MotionCommand = (function() {

            /**
             * Properties of a MotionCommand.
             * @memberof message.behaviour
             * @interface IMotionCommand
             * @property {message.behaviour.MotionCommand.Type|null} [type] The type of this motion command
             * @property {Ivec3|null} [goalState] Required data for WalkToState command
             * @property {Ivec2|null} [kickTarget] Required data for WalkToBall command
             * @property {Ivec3|null} [walkCommand] Required data for DirectCommand command
             * @property {boolean|null} [clockwise] Required data for RotateOnSpot command
             */

            /**
             * Constructs a new MotionCommand.
             * @memberof message.behaviour
             * @classdesc Details of which walk behaviour to execute and where on the field to do it
             * @implements IMotionCommand
             * @constructor
             * @param {message.behaviour.IMotionCommand=} [properties] Properties to set
             */
            function MotionCommand(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * The type of this motion command
             * @member {message.behaviour.MotionCommand.Type} type
             * @memberof message.behaviour.MotionCommand
             * @instance
             */
            MotionCommand.prototype.type = 0;

            /**
             * Required data for WalkToState command
             * @member {Ivec3|null|undefined} goalState
             * @memberof message.behaviour.MotionCommand
             * @instance
             */
            MotionCommand.prototype.goalState = null;

            /**
             * Required data for WalkToBall command
             * @member {Ivec2|null|undefined} kickTarget
             * @memberof message.behaviour.MotionCommand
             * @instance
             */
            MotionCommand.prototype.kickTarget = null;

            /**
             * Required data for DirectCommand command
             * @member {Ivec3|null|undefined} walkCommand
             * @memberof message.behaviour.MotionCommand
             * @instance
             */
            MotionCommand.prototype.walkCommand = null;

            /**
             * Required data for RotateOnSpot command
             * @member {boolean} clockwise
             * @memberof message.behaviour.MotionCommand
             * @instance
             */
            MotionCommand.prototype.clockwise = false;

            /**
             * Encodes the specified MotionCommand message. Does not implicitly {@link message.behaviour.MotionCommand.verify|verify} messages.
             * @function encode
             * @memberof message.behaviour.MotionCommand
             * @static
             * @param {message.behaviour.IMotionCommand} message MotionCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MotionCommand.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.goalState != null && Object.hasOwnProperty.call(message, "goalState"))
                    $root.vec3.encode(message.goalState, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.kickTarget != null && Object.hasOwnProperty.call(message, "kickTarget"))
                    $root.vec2.encode(message.kickTarget, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.walkCommand != null && Object.hasOwnProperty.call(message, "walkCommand"))
                    $root.vec3.encode(message.walkCommand, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.clockwise != null && Object.hasOwnProperty.call(message, "clockwise"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.clockwise);
                return writer;
            };

            /**
             * Decodes a MotionCommand message from the specified reader or buffer.
             * @function decode
             * @memberof message.behaviour.MotionCommand
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.behaviour.MotionCommand} MotionCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MotionCommand.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.behaviour.MotionCommand();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.goalState = $root.vec3.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.kickTarget = $root.vec2.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.walkCommand = $root.vec3.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.clockwise = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Type enum.
             * @name message.behaviour.MotionCommand.Type
             * @enum {number}
             * @property {number} STAND_STILL=0 Stop moving and just stand still
             * @property {number} WALK_TO_STATE=1 Walk to a given position and heading on the field, avoiding obstacles
             * @property {number} BALL_APPROACH=2 Approach the ball, ready to perform a forward kick toward the given kickTarget. Avoids obstacles
             * @property {number} DIRECT_COMMAND=3 Stop all current motion and directly send the given WalkCommand to the WalkEngine
             * @property {number} ROTATE_ON_SPOT=4 Rotates on the spot
             * @property {number} WALK_TO_READY=5 Walks to ready position
             * @property {number} ROTATE_AROUND_BALL=6 Rotates around ball
             */
            MotionCommand.Type = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "STAND_STILL"] = 0;
                values[valuesById[1] = "WALK_TO_STATE"] = 1;
                values[valuesById[2] = "BALL_APPROACH"] = 2;
                values[valuesById[3] = "DIRECT_COMMAND"] = 3;
                values[valuesById[4] = "ROTATE_ON_SPOT"] = 4;
                values[valuesById[5] = "WALK_TO_READY"] = 5;
                values[valuesById[6] = "ROTATE_AROUND_BALL"] = 6;
                return values;
            })();

            return MotionCommand;
        })();

        behaviour.Nod = (function() {

            /**
             * Properties of a Nod.
             * @memberof message.behaviour
             * @interface INod
             * @property {boolean|null} [value] Nod value
             */

            /**
             * Constructs a new Nod.
             * @memberof message.behaviour
             * @classdesc Represents a Nod.
             * @implements INod
             * @constructor
             * @param {message.behaviour.INod=} [properties] Properties to set
             */
            function Nod(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Nod value.
             * @member {boolean} value
             * @memberof message.behaviour.Nod
             * @instance
             */
            Nod.prototype.value = false;

            /**
             * Encodes the specified Nod message. Does not implicitly {@link message.behaviour.Nod.verify|verify} messages.
             * @function encode
             * @memberof message.behaviour.Nod
             * @static
             * @param {message.behaviour.INod} message Nod message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Nod.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.value);
                return writer;
            };

            /**
             * Decodes a Nod message from the specified reader or buffer.
             * @function decode
             * @memberof message.behaviour.Nod
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.behaviour.Nod} Nod
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Nod.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.behaviour.Nod();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.value = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return Nod;
        })();

        behaviour.ServoCommand = (function() {

            /**
             * Properties of a ServoCommand.
             * @memberof message.behaviour
             * @interface IServoCommand
             * @property {number|Long|null} [source] The subsumption ID which created the command
             * @property {google.protobuf.ITimestamp|null} [time] The time when the command was created
             * @property {number|null} [id] The servo which is being commanded
             * @property {number|null} [position] is triggered as set in Alarm LED/Shutdown
             * @property {number|null} [gain] K_p : p_gain / 8
             * @property {number|null} [torque] Used to set the servo on or off. Typically either 0 (off) or 100 (on)
             */

            /**
             * Constructs a new ServoCommand.
             * @memberof message.behaviour
             * @classdesc Represents a ServoCommand.
             * @implements IServoCommand
             * @constructor
             * @param {message.behaviour.IServoCommand=} [properties] Properties to set
             */
            function ServoCommand(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * The subsumption ID which created the command
             * @member {number|Long} source
             * @memberof message.behaviour.ServoCommand
             * @instance
             */
            ServoCommand.prototype.source = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * The time when the command was created
             * @member {google.protobuf.ITimestamp|null|undefined} time
             * @memberof message.behaviour.ServoCommand
             * @instance
             */
            ServoCommand.prototype.time = null;

            /**
             * The servo which is being commanded
             * @member {number} id
             * @memberof message.behaviour.ServoCommand
             * @instance
             */
            ServoCommand.prototype.id = 0;

            /**
             * is triggered as set in Alarm LED/Shutdown
             * @member {number} position
             * @memberof message.behaviour.ServoCommand
             * @instance
             */
            ServoCommand.prototype.position = 0;

            /**
             * K_p : p_gain / 8
             * @member {number} gain
             * @memberof message.behaviour.ServoCommand
             * @instance
             */
            ServoCommand.prototype.gain = 0;

            /**
             * Used to set the servo on or off. Typically either 0 (off) or 100 (on)
             * @member {number} torque
             * @memberof message.behaviour.ServoCommand
             * @instance
             */
            ServoCommand.prototype.torque = 0;

            /**
             * Encodes the specified ServoCommand message. Does not implicitly {@link message.behaviour.ServoCommand.verify|verify} messages.
             * @function encode
             * @memberof message.behaviour.ServoCommand
             * @static
             * @param {message.behaviour.IServoCommand} message ServoCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServoCommand.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.source != null && Object.hasOwnProperty.call(message, "source"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.source);
                if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                    $root.google.protobuf.Timestamp.encode(message.time, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.id);
                if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                    writer.uint32(/* id 4, wireType 5 =*/37).float(message.position);
                if (message.gain != null && Object.hasOwnProperty.call(message, "gain"))
                    writer.uint32(/* id 5, wireType 5 =*/45).float(message.gain);
                if (message.torque != null && Object.hasOwnProperty.call(message, "torque"))
                    writer.uint32(/* id 6, wireType 5 =*/53).float(message.torque);
                return writer;
            };

            /**
             * Decodes a ServoCommand message from the specified reader or buffer.
             * @function decode
             * @memberof message.behaviour.ServoCommand
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.behaviour.ServoCommand} ServoCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServoCommand.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.behaviour.ServoCommand();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.source = reader.uint64();
                        break;
                    case 2:
                        message.time = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.id = reader.uint32();
                        break;
                    case 4:
                        message.position = reader.float();
                        break;
                    case 5:
                        message.gain = reader.float();
                        break;
                    case 6:
                        message.torque = reader.float();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return ServoCommand;
        })();

        behaviour.ServoCommands = (function() {

            /**
             * Properties of a ServoCommands.
             * @memberof message.behaviour
             * @interface IServoCommands
             * @property {Array.<message.behaviour.IServoCommand>|null} [commands] ServoCommands commands
             */

            /**
             * Constructs a new ServoCommands.
             * @memberof message.behaviour
             * @classdesc Represents a ServoCommands.
             * @implements IServoCommands
             * @constructor
             * @param {message.behaviour.IServoCommands=} [properties] Properties to set
             */
            function ServoCommands(properties) {
                this.commands = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ServoCommands commands.
             * @member {Array.<message.behaviour.IServoCommand>} commands
             * @memberof message.behaviour.ServoCommands
             * @instance
             */
            ServoCommands.prototype.commands = $util.emptyArray;

            /**
             * Encodes the specified ServoCommands message. Does not implicitly {@link message.behaviour.ServoCommands.verify|verify} messages.
             * @function encode
             * @memberof message.behaviour.ServoCommands
             * @static
             * @param {message.behaviour.IServoCommands} message ServoCommands message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServoCommands.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.commands != null && message.commands.length)
                    for (let i = 0; i < message.commands.length; ++i)
                        $root.message.behaviour.ServoCommand.encode(message.commands[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a ServoCommands message from the specified reader or buffer.
             * @function decode
             * @memberof message.behaviour.ServoCommands
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.behaviour.ServoCommands} ServoCommands
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServoCommands.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.behaviour.ServoCommands();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.commands && message.commands.length))
                            message.commands = [];
                        message.commands.push($root.message.behaviour.ServoCommand.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return ServoCommands;
        })();

        behaviour.state = (function() {

            /**
             * Namespace state.
             * @memberof message.behaviour
             * @namespace
             */
            const state = {};

            /**
             * Stability enum.
             * @name message.behaviour.state.Stability
             * @enum {number}
             * @property {number} FALLEN=0 FALLEN value
             * @property {number} FALLING=1 FALLING value
             * @property {number} DYNAMIC=2 DYNAMIC value
             * @property {number} STATIC=3 STATIC value
             * @property {number} STANDING=4 STANDING value
             */
            state.Stability = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "FALLEN"] = 0;
                values[valuesById[1] = "FALLING"] = 1;
                values[valuesById[2] = "DYNAMIC"] = 2;
                values[valuesById[3] = "STATIC"] = 3;
                values[valuesById[4] = "STANDING"] = 4;
                return values;
            })();

            return state;
        })();

        return behaviour;
    })();

    message.Line = (function() {

        /**
         * Properties of a Line.
         * @memberof message
         * @interface ILine
         * @property {Ifvec3|null} [normal] Line normal
         * @property {number|null} [distance] Line distance
         */

        /**
         * Constructs a new Line.
         * @memberof message
         * @classdesc Hesse normal form representation of a line. See https://en.wikipedia.org/wiki/Hesse_normal_form
         * @implements ILine
         * @constructor
         * @param {message.ILine=} [properties] Properties to set
         */
        function Line(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Line normal.
         * @member {Ifvec3|null|undefined} normal
         * @memberof message.Line
         * @instance
         */
        Line.prototype.normal = null;

        /**
         * Line distance.
         * @member {number} distance
         * @memberof message.Line
         * @instance
         */
        Line.prototype.distance = 0;

        /**
         * Encodes the specified Line message. Does not implicitly {@link message.Line.verify|verify} messages.
         * @function encode
         * @memberof message.Line
         * @static
         * @param {message.ILine} message Line message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Line.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.normal != null && Object.hasOwnProperty.call(message, "normal"))
                $root.fvec3.encode(message.normal, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.distance != null && Object.hasOwnProperty.call(message, "distance"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.distance);
            return writer;
        };

        /**
         * Decodes a Line message from the specified reader or buffer.
         * @function decode
         * @memberof message.Line
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {message.Line} Line
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Line.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.Line();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.normal = $root.fvec3.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.distance = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return Line;
    })();

    message.Circle = (function() {

        /**
         * Properties of a Circle.
         * @memberof message
         * @interface ICircle
         * @property {number|null} [radius] Circle radius
         * @property {Ivec2|null} [centre] Circle centre
         */

        /**
         * Constructs a new Circle.
         * @memberof message
         * @classdesc Represents a Circle.
         * @implements ICircle
         * @constructor
         * @param {message.ICircle=} [properties] Properties to set
         */
        function Circle(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Circle radius.
         * @member {number} radius
         * @memberof message.Circle
         * @instance
         */
        Circle.prototype.radius = 0;

        /**
         * Circle centre.
         * @member {Ivec2|null|undefined} centre
         * @memberof message.Circle
         * @instance
         */
        Circle.prototype.centre = null;

        /**
         * Encodes the specified Circle message. Does not implicitly {@link message.Circle.verify|verify} messages.
         * @function encode
         * @memberof message.Circle
         * @static
         * @param {message.ICircle} message Circle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Circle.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.radius != null && Object.hasOwnProperty.call(message, "radius"))
                writer.uint32(/* id 1, wireType 1 =*/9).double(message.radius);
            if (message.centre != null && Object.hasOwnProperty.call(message, "centre"))
                $root.vec2.encode(message.centre, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a Circle message from the specified reader or buffer.
         * @function decode
         * @memberof message.Circle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {message.Circle} Circle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Circle.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.Circle();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.radius = reader.double();
                    break;
                case 2:
                    message.centre = $root.vec2.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return Circle;
    })();

    message.Ellipse = (function() {

        /**
         * Properties of an Ellipse.
         * @memberof message
         * @interface IEllipse
         * @property {Imat3|null} [ellipse] See http://en.wikipedia.org/wiki/Matrix_representation_of_conic_sections
         */

        /**
         * Constructs a new Ellipse.
         * @memberof message
         * @classdesc A 3D matrix representation of the Ellipse
         * @implements IEllipse
         * @constructor
         * @param {message.IEllipse=} [properties] Properties to set
         */
        function Ellipse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * See http://en.wikipedia.org/wiki/Matrix_representation_of_conic_sections
         * @member {Imat3|null|undefined} ellipse
         * @memberof message.Ellipse
         * @instance
         */
        Ellipse.prototype.ellipse = null;

        /**
         * Encodes the specified Ellipse message. Does not implicitly {@link message.Ellipse.verify|verify} messages.
         * @function encode
         * @memberof message.Ellipse
         * @static
         * @param {message.IEllipse} message Ellipse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Ellipse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ellipse != null && Object.hasOwnProperty.call(message, "ellipse"))
                $root.mat3.encode(message.ellipse, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes an Ellipse message from the specified reader or buffer.
         * @function decode
         * @memberof message.Ellipse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {message.Ellipse} Ellipse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Ellipse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.Ellipse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ellipse = $root.mat3.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return Ellipse;
    })();

    message.Quad = (function() {

        /**
         * Properties of a Quad.
         * @memberof message
         * @interface IQuad
         * @property {Ivec2|null} [tl] Quad tl
         * @property {Ivec2|null} [tr] Quad tr
         * @property {Ivec2|null} [bl] Quad bl
         * @property {Ivec2|null} [br] Quad br
         */

        /**
         * Constructs a new Quad.
         * @memberof message
         * @classdesc Four corner points of a quadrilateral
         * @implements IQuad
         * @constructor
         * @param {message.IQuad=} [properties] Properties to set
         */
        function Quad(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Quad tl.
         * @member {Ivec2|null|undefined} tl
         * @memberof message.Quad
         * @instance
         */
        Quad.prototype.tl = null;

        /**
         * Quad tr.
         * @member {Ivec2|null|undefined} tr
         * @memberof message.Quad
         * @instance
         */
        Quad.prototype.tr = null;

        /**
         * Quad bl.
         * @member {Ivec2|null|undefined} bl
         * @memberof message.Quad
         * @instance
         */
        Quad.prototype.bl = null;

        /**
         * Quad br.
         * @member {Ivec2|null|undefined} br
         * @memberof message.Quad
         * @instance
         */
        Quad.prototype.br = null;

        /**
         * Encodes the specified Quad message. Does not implicitly {@link message.Quad.verify|verify} messages.
         * @function encode
         * @memberof message.Quad
         * @static
         * @param {message.IQuad} message Quad message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Quad.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tl != null && Object.hasOwnProperty.call(message, "tl"))
                $root.vec2.encode(message.tl, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.tr != null && Object.hasOwnProperty.call(message, "tr"))
                $root.vec2.encode(message.tr, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.bl != null && Object.hasOwnProperty.call(message, "bl"))
                $root.vec2.encode(message.bl, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.br != null && Object.hasOwnProperty.call(message, "br"))
                $root.vec2.encode(message.br, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a Quad message from the specified reader or buffer.
         * @function decode
         * @memberof message.Quad
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {message.Quad} Quad
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Quad.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.Quad();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tl = $root.vec2.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.tr = $root.vec2.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.bl = $root.vec2.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.br = $root.vec2.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return Quad;
    })();

    message.Polygon = (function() {

        /**
         * Properties of a Polygon.
         * @memberof message
         * @interface IPolygon
         * @property {Array.<Ivec2>|null} [vertices] Polygon vertices
         */

        /**
         * Constructs a new Polygon.
         * @memberof message
         * @classdesc Represents a Polygon.
         * @implements IPolygon
         * @constructor
         * @param {message.IPolygon=} [properties] Properties to set
         */
        function Polygon(properties) {
            this.vertices = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Polygon vertices.
         * @member {Array.<Ivec2>} vertices
         * @memberof message.Polygon
         * @instance
         */
        Polygon.prototype.vertices = $util.emptyArray;

        /**
         * Encodes the specified Polygon message. Does not implicitly {@link message.Polygon.verify|verify} messages.
         * @function encode
         * @memberof message.Polygon
         * @static
         * @param {message.IPolygon} message Polygon message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Polygon.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.vertices != null && message.vertices.length)
                for (let i = 0; i < message.vertices.length; ++i)
                    $root.vec2.encode(message.vertices[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a Polygon message from the specified reader or buffer.
         * @function decode
         * @memberof message.Polygon
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {message.Polygon} Polygon
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Polygon.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.Polygon();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.vertices && message.vertices.length))
                        message.vertices = [];
                    message.vertices.push($root.vec2.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return Polygon;
    })();

    message.Frustum = (function() {

        /**
         * Properties of a Frustum.
         * @memberof message
         * @interface IFrustum
         * @property {Ivec3|null} [tl] Frustum tl
         * @property {Ivec3|null} [tr] Frustum tr
         * @property {Ivec3|null} [bl] Frustum bl
         * @property {Ivec3|null} [br] Frustum br
         */

        /**
         * Constructs a new Frustum.
         * @memberof message
         * @classdesc Contains the positions of the four corners of a frustrum
         * @implements IFrustum
         * @constructor
         * @param {message.IFrustum=} [properties] Properties to set
         */
        function Frustum(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Frustum tl.
         * @member {Ivec3|null|undefined} tl
         * @memberof message.Frustum
         * @instance
         */
        Frustum.prototype.tl = null;

        /**
         * Frustum tr.
         * @member {Ivec3|null|undefined} tr
         * @memberof message.Frustum
         * @instance
         */
        Frustum.prototype.tr = null;

        /**
         * Frustum bl.
         * @member {Ivec3|null|undefined} bl
         * @memberof message.Frustum
         * @instance
         */
        Frustum.prototype.bl = null;

        /**
         * Frustum br.
         * @member {Ivec3|null|undefined} br
         * @memberof message.Frustum
         * @instance
         */
        Frustum.prototype.br = null;

        /**
         * Encodes the specified Frustum message. Does not implicitly {@link message.Frustum.verify|verify} messages.
         * @function encode
         * @memberof message.Frustum
         * @static
         * @param {message.IFrustum} message Frustum message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Frustum.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tl != null && Object.hasOwnProperty.call(message, "tl"))
                $root.vec3.encode(message.tl, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.tr != null && Object.hasOwnProperty.call(message, "tr"))
                $root.vec3.encode(message.tr, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.bl != null && Object.hasOwnProperty.call(message, "bl"))
                $root.vec3.encode(message.bl, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.br != null && Object.hasOwnProperty.call(message, "br"))
                $root.vec3.encode(message.br, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a Frustum message from the specified reader or buffer.
         * @function decode
         * @memberof message.Frustum
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {message.Frustum} Frustum
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Frustum.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.Frustum();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tl = $root.vec3.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.tr = $root.vec3.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.bl = $root.vec3.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.br = $root.vec3.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return Frustum;
    })();

    message.Cone = (function() {

        /**
         * Properties of a Cone.
         * @memberof message
         * @interface ICone
         * @property {Ifvec3|null} [axis] 3D axis of the centre of the cone
         * @property {number|null} [radius] Cos(theta) of the cone angle
         */

        /**
         * Constructs a new Cone.
         * @memberof message
         * @classdesc Represents a Cone.
         * @implements ICone
         * @constructor
         * @param {message.ICone=} [properties] Properties to set
         */
        function Cone(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * 3D axis of the centre of the cone
         * @member {Ifvec3|null|undefined} axis
         * @memberof message.Cone
         * @instance
         */
        Cone.prototype.axis = null;

        /**
         * Cos(theta) of the cone angle
         * @member {number} radius
         * @memberof message.Cone
         * @instance
         */
        Cone.prototype.radius = 0;

        /**
         * Encodes the specified Cone message. Does not implicitly {@link message.Cone.verify|verify} messages.
         * @function encode
         * @memberof message.Cone
         * @static
         * @param {message.ICone} message Cone message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Cone.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.axis != null && Object.hasOwnProperty.call(message, "axis"))
                $root.fvec3.encode(message.axis, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.radius != null && Object.hasOwnProperty.call(message, "radius"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.radius);
            return writer;
        };

        /**
         * Decodes a Cone message from the specified reader or buffer.
         * @function decode
         * @memberof message.Cone
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {message.Cone} Cone
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Cone.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.Cone();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.axis = $root.fvec3.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.radius = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return Cone;
    })();

    message.input = (function() {

        /**
         * Namespace input.
         * @memberof message
         * @namespace
         */
        const input = {};

        input.GameEvents = (function() {

            /**
             * Properties of a GameEvents.
             * @memberof message.input
             * @interface IGameEvents
             */

            /**
             * Constructs a new GameEvents.
             * @memberof message.input
             * @classdesc Represents a GameEvents.
             * @implements IGameEvents
             * @constructor
             * @param {message.input.IGameEvents=} [properties] Properties to set
             */
            function GameEvents(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Encodes the specified GameEvents message. Does not implicitly {@link message.input.GameEvents.verify|verify} messages.
             * @function encode
             * @memberof message.input.GameEvents
             * @static
             * @param {message.input.IGameEvents} message GameEvents message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GameEvents.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Decodes a GameEvents message from the specified reader or buffer.
             * @function decode
             * @memberof message.input.GameEvents
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.input.GameEvents} GameEvents
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GameEvents.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.GameEvents();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Context describes which actor/team is being referred to by an event
             * @name message.input.GameEvents.Context
             * @enum {number}
             * @property {number} UNKNOWN_CONTEXT=0 UNKNOWN_CONTEXT value
             * @property {number} SELF=1 SELF value
             * @property {number} TEAM=2 TEAM value
             * @property {number} OPPONENT=3 OPPONENT value
             * @property {number} UNKNOWN=4 UNKNOWN value
             */
            GameEvents.Context = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN_CONTEXT"] = 0;
                values[valuesById[1] = "SELF"] = 1;
                values[valuesById[2] = "TEAM"] = 2;
                values[valuesById[3] = "OPPONENT"] = 3;
                values[valuesById[4] = "UNKNOWN"] = 4;
                return values;
            })();

            /**
             * TeamColour enum.
             * @name message.input.GameEvents.TeamColour
             * @enum {number}
             * @property {number} UNKNOWN_TEAM_COLOUR=0 UNKNOWN_TEAM_COLOUR value
             * @property {number} CYAN=1 CYAN value
             * @property {number} MAGENTA=2 MAGENTA value
             */
            GameEvents.TeamColour = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN_TEAM_COLOUR"] = 0;
                values[valuesById[1] = "CYAN"] = 1;
                values[valuesById[2] = "MAGENTA"] = 2;
                return values;
            })();

            GameEvents.Score = (function() {

                /**
                 * Properties of a Score.
                 * @memberof message.input.GameEvents
                 * @interface IScore
                 * @property {number|null} [ownScore] Score ownScore
                 * @property {number|null} [opponentScore] Score opponentScore
                 */

                /**
                 * Constructs a new Score.
                 * @memberof message.input.GameEvents
                 * @classdesc Represents a Score.
                 * @implements IScore
                 * @constructor
                 * @param {message.input.GameEvents.IScore=} [properties] Properties to set
                 */
                function Score(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Score ownScore.
                 * @member {number} ownScore
                 * @memberof message.input.GameEvents.Score
                 * @instance
                 */
                Score.prototype.ownScore = 0;

                /**
                 * Score opponentScore.
                 * @member {number} opponentScore
                 * @memberof message.input.GameEvents.Score
                 * @instance
                 */
                Score.prototype.opponentScore = 0;

                /**
                 * Encodes the specified Score message. Does not implicitly {@link message.input.GameEvents.Score.verify|verify} messages.
                 * @function encode
                 * @memberof message.input.GameEvents.Score
                 * @static
                 * @param {message.input.GameEvents.IScore} message Score message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Score.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.ownScore != null && Object.hasOwnProperty.call(message, "ownScore"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.ownScore);
                    if (message.opponentScore != null && Object.hasOwnProperty.call(message, "opponentScore"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.opponentScore);
                    return writer;
                };

                /**
                 * Decodes a Score message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.input.GameEvents.Score
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.GameEvents.Score} Score
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Score.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.GameEvents.Score();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.ownScore = reader.uint32();
                            break;
                        case 2:
                            message.opponentScore = reader.uint32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return Score;
            })();

            GameEvents.GoalScored = (function() {

                /**
                 * Properties of a GoalScored.
                 * @memberof message.input.GameEvents
                 * @interface IGoalScored
                 * @property {message.input.GameEvents.Context|null} [context] The actor/team who scored the goal
                 * @property {number|null} [totalScore] GoalScored totalScore
                 */

                /**
                 * Constructs a new GoalScored.
                 * @memberof message.input.GameEvents
                 * @classdesc Represents a GoalScored.
                 * @implements IGoalScored
                 * @constructor
                 * @param {message.input.GameEvents.IGoalScored=} [properties] Properties to set
                 */
                function GoalScored(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * The actor/team who scored the goal
                 * @member {message.input.GameEvents.Context} context
                 * @memberof message.input.GameEvents.GoalScored
                 * @instance
                 */
                GoalScored.prototype.context = 0;

                /**
                 * GoalScored totalScore.
                 * @member {number} totalScore
                 * @memberof message.input.GameEvents.GoalScored
                 * @instance
                 */
                GoalScored.prototype.totalScore = 0;

                /**
                 * Encodes the specified GoalScored message. Does not implicitly {@link message.input.GameEvents.GoalScored.verify|verify} messages.
                 * @function encode
                 * @memberof message.input.GameEvents.GoalScored
                 * @static
                 * @param {message.input.GameEvents.IGoalScored} message GoalScored message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GoalScored.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.context != null && Object.hasOwnProperty.call(message, "context"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.context);
                    if (message.totalScore != null && Object.hasOwnProperty.call(message, "totalScore"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.totalScore);
                    return writer;
                };

                /**
                 * Decodes a GoalScored message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.input.GameEvents.GoalScored
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.GameEvents.GoalScored} GoalScored
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GoalScored.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.GameEvents.GoalScored();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.context = reader.int32();
                            break;
                        case 2:
                            message.totalScore = reader.uint32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return GoalScored;
            })();

            GameEvents.Penalisation = (function() {

                /**
                 * Properties of a Penalisation.
                 * @memberof message.input.GameEvents
                 * @interface IPenalisation
                 * @property {message.input.GameEvents.Context|null} [context] Penalisation context
                 * @property {number|null} [robotId] Penalisation robotId
                 * @property {google.protobuf.ITimestamp|null} [ends] The timestamp when the robot may resume playing
                 * @property {message.input.GameState.Data.PenaltyReason|null} [reason] Penalisation reason
                 */

                /**
                 * Constructs a new Penalisation.
                 * @memberof message.input.GameEvents
                 * @classdesc Represents a Penalisation.
                 * @implements IPenalisation
                 * @constructor
                 * @param {message.input.GameEvents.IPenalisation=} [properties] Properties to set
                 */
                function Penalisation(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Penalisation context.
                 * @member {message.input.GameEvents.Context} context
                 * @memberof message.input.GameEvents.Penalisation
                 * @instance
                 */
                Penalisation.prototype.context = 0;

                /**
                 * Penalisation robotId.
                 * @member {number} robotId
                 * @memberof message.input.GameEvents.Penalisation
                 * @instance
                 */
                Penalisation.prototype.robotId = 0;

                /**
                 * The timestamp when the robot may resume playing
                 * @member {google.protobuf.ITimestamp|null|undefined} ends
                 * @memberof message.input.GameEvents.Penalisation
                 * @instance
                 */
                Penalisation.prototype.ends = null;

                /**
                 * Penalisation reason.
                 * @member {message.input.GameState.Data.PenaltyReason} reason
                 * @memberof message.input.GameEvents.Penalisation
                 * @instance
                 */
                Penalisation.prototype.reason = 0;

                /**
                 * Encodes the specified Penalisation message. Does not implicitly {@link message.input.GameEvents.Penalisation.verify|verify} messages.
                 * @function encode
                 * @memberof message.input.GameEvents.Penalisation
                 * @static
                 * @param {message.input.GameEvents.IPenalisation} message Penalisation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Penalisation.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.context != null && Object.hasOwnProperty.call(message, "context"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.context);
                    if (message.robotId != null && Object.hasOwnProperty.call(message, "robotId"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.robotId);
                    if (message.ends != null && Object.hasOwnProperty.call(message, "ends"))
                        $root.google.protobuf.Timestamp.encode(message.ends, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.reason);
                    return writer;
                };

                /**
                 * Decodes a Penalisation message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.input.GameEvents.Penalisation
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.GameEvents.Penalisation} Penalisation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Penalisation.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.GameEvents.Penalisation();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.context = reader.int32();
                            break;
                        case 2:
                            message.robotId = reader.uint32();
                            break;
                        case 3:
                            message.ends = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.reason = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return Penalisation;
            })();

            GameEvents.Unpenalisation = (function() {

                /**
                 * Properties of an Unpenalisation.
                 * @memberof message.input.GameEvents
                 * @interface IUnpenalisation
                 * @property {message.input.GameEvents.Context|null} [context] Unpenalisation context
                 * @property {number|null} [robotId] Unpenalisation robotId
                 */

                /**
                 * Constructs a new Unpenalisation.
                 * @memberof message.input.GameEvents
                 * @classdesc The context and robot which were unpenalised
                 * @implements IUnpenalisation
                 * @constructor
                 * @param {message.input.GameEvents.IUnpenalisation=} [properties] Properties to set
                 */
                function Unpenalisation(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Unpenalisation context.
                 * @member {message.input.GameEvents.Context} context
                 * @memberof message.input.GameEvents.Unpenalisation
                 * @instance
                 */
                Unpenalisation.prototype.context = 0;

                /**
                 * Unpenalisation robotId.
                 * @member {number} robotId
                 * @memberof message.input.GameEvents.Unpenalisation
                 * @instance
                 */
                Unpenalisation.prototype.robotId = 0;

                /**
                 * Encodes the specified Unpenalisation message. Does not implicitly {@link message.input.GameEvents.Unpenalisation.verify|verify} messages.
                 * @function encode
                 * @memberof message.input.GameEvents.Unpenalisation
                 * @static
                 * @param {message.input.GameEvents.IUnpenalisation} message Unpenalisation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Unpenalisation.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.context != null && Object.hasOwnProperty.call(message, "context"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.context);
                    if (message.robotId != null && Object.hasOwnProperty.call(message, "robotId"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.robotId);
                    return writer;
                };

                /**
                 * Decodes an Unpenalisation message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.input.GameEvents.Unpenalisation
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.GameEvents.Unpenalisation} Unpenalisation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Unpenalisation.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.GameEvents.Unpenalisation();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.context = reader.int32();
                            break;
                        case 2:
                            message.robotId = reader.uint32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return Unpenalisation;
            })();

            GameEvents.CoachMessage = (function() {

                /**
                 * Properties of a CoachMessage.
                 * @memberof message.input.GameEvents
                 * @interface ICoachMessage
                 * @property {message.input.GameEvents.Context|null} [context] The intended recipient(s)
                 * @property {string|null} [message] CoachMessage message
                 */

                /**
                 * Constructs a new CoachMessage.
                 * @memberof message.input.GameEvents
                 * @classdesc Represents a CoachMessage.
                 * @implements ICoachMessage
                 * @constructor
                 * @param {message.input.GameEvents.ICoachMessage=} [properties] Properties to set
                 */
                function CoachMessage(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * The intended recipient(s)
                 * @member {message.input.GameEvents.Context} context
                 * @memberof message.input.GameEvents.CoachMessage
                 * @instance
                 */
                CoachMessage.prototype.context = 0;

                /**
                 * CoachMessage message.
                 * @member {string} message
                 * @memberof message.input.GameEvents.CoachMessage
                 * @instance
                 */
                CoachMessage.prototype.message = "";

                /**
                 * Encodes the specified CoachMessage message. Does not implicitly {@link message.input.GameEvents.CoachMessage.verify|verify} messages.
                 * @function encode
                 * @memberof message.input.GameEvents.CoachMessage
                 * @static
                 * @param {message.input.GameEvents.ICoachMessage} message CoachMessage message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CoachMessage.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.context != null && Object.hasOwnProperty.call(message, "context"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.context);
                    if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);
                    return writer;
                };

                /**
                 * Decodes a CoachMessage message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.input.GameEvents.CoachMessage
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.GameEvents.CoachMessage} CoachMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CoachMessage.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.GameEvents.CoachMessage();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.context = reader.int32();
                            break;
                        case 2:
                            message.message = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return CoachMessage;
            })();

            GameEvents.HalfTime = (function() {

                /**
                 * Properties of a HalfTime.
                 * @memberof message.input.GameEvents
                 * @interface IHalfTime
                 * @property {boolean|null} [firstHalf] HalfTime firstHalf
                 */

                /**
                 * Constructs a new HalfTime.
                 * @memberof message.input.GameEvents
                 * @classdesc Represents a HalfTime.
                 * @implements IHalfTime
                 * @constructor
                 * @param {message.input.GameEvents.IHalfTime=} [properties] Properties to set
                 */
                function HalfTime(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * HalfTime firstHalf.
                 * @member {boolean} firstHalf
                 * @memberof message.input.GameEvents.HalfTime
                 * @instance
                 */
                HalfTime.prototype.firstHalf = false;

                /**
                 * Encodes the specified HalfTime message. Does not implicitly {@link message.input.GameEvents.HalfTime.verify|verify} messages.
                 * @function encode
                 * @memberof message.input.GameEvents.HalfTime
                 * @static
                 * @param {message.input.GameEvents.IHalfTime} message HalfTime message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                HalfTime.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.firstHalf != null && Object.hasOwnProperty.call(message, "firstHalf"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.firstHalf);
                    return writer;
                };

                /**
                 * Decodes a HalfTime message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.input.GameEvents.HalfTime
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.GameEvents.HalfTime} HalfTime
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                HalfTime.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.GameEvents.HalfTime();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.firstHalf = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return HalfTime;
            })();

            GameEvents.BallKickedOut = (function() {

                /**
                 * Properties of a BallKickedOut.
                 * @memberof message.input.GameEvents
                 * @interface IBallKickedOut
                 * @property {message.input.GameEvents.Context|null} [context] The party which kicked the ball out
                 * @property {google.protobuf.ITimestamp|null} [time] BallKickedOut time
                 */

                /**
                 * Constructs a new BallKickedOut.
                 * @memberof message.input.GameEvents
                 * @classdesc Represents a BallKickedOut.
                 * @implements IBallKickedOut
                 * @constructor
                 * @param {message.input.GameEvents.IBallKickedOut=} [properties] Properties to set
                 */
                function BallKickedOut(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * The party which kicked the ball out
                 * @member {message.input.GameEvents.Context} context
                 * @memberof message.input.GameEvents.BallKickedOut
                 * @instance
                 */
                BallKickedOut.prototype.context = 0;

                /**
                 * BallKickedOut time.
                 * @member {google.protobuf.ITimestamp|null|undefined} time
                 * @memberof message.input.GameEvents.BallKickedOut
                 * @instance
                 */
                BallKickedOut.prototype.time = null;

                /**
                 * Encodes the specified BallKickedOut message. Does not implicitly {@link message.input.GameEvents.BallKickedOut.verify|verify} messages.
                 * @function encode
                 * @memberof message.input.GameEvents.BallKickedOut
                 * @static
                 * @param {message.input.GameEvents.IBallKickedOut} message BallKickedOut message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BallKickedOut.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.context != null && Object.hasOwnProperty.call(message, "context"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.context);
                    if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                        $root.google.protobuf.Timestamp.encode(message.time, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Decodes a BallKickedOut message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.input.GameEvents.BallKickedOut
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.GameEvents.BallKickedOut} BallKickedOut
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BallKickedOut.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.GameEvents.BallKickedOut();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.context = reader.int32();
                            break;
                        case 3:
                            message.time = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return BallKickedOut;
            })();

            GameEvents.KickOffTeam = (function() {

                /**
                 * Properties of a KickOffTeam.
                 * @memberof message.input.GameEvents
                 * @interface IKickOffTeam
                 * @property {message.input.GameEvents.Context|null} [context] KickOffTeam context
                 */

                /**
                 * Constructs a new KickOffTeam.
                 * @memberof message.input.GameEvents
                 * @classdesc Represents a KickOffTeam.
                 * @implements IKickOffTeam
                 * @constructor
                 * @param {message.input.GameEvents.IKickOffTeam=} [properties] Properties to set
                 */
                function KickOffTeam(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * KickOffTeam context.
                 * @member {message.input.GameEvents.Context} context
                 * @memberof message.input.GameEvents.KickOffTeam
                 * @instance
                 */
                KickOffTeam.prototype.context = 0;

                /**
                 * Encodes the specified KickOffTeam message. Does not implicitly {@link message.input.GameEvents.KickOffTeam.verify|verify} messages.
                 * @function encode
                 * @memberof message.input.GameEvents.KickOffTeam
                 * @static
                 * @param {message.input.GameEvents.IKickOffTeam} message KickOffTeam message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                KickOffTeam.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.context != null && Object.hasOwnProperty.call(message, "context"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.context);
                    return writer;
                };

                /**
                 * Decodes a KickOffTeam message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.input.GameEvents.KickOffTeam
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.GameEvents.KickOffTeam} KickOffTeam
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                KickOffTeam.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.GameEvents.KickOffTeam();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.context = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return KickOffTeam;
            })();

            GameEvents.GamePhase = (function() {

                /**
                 * Properties of a GamePhase.
                 * @memberof message.input.GameEvents
                 * @interface IGamePhase
                 * @property {message.input.GameState.Data.Phase|null} [phase] GamePhase phase
                 * @property {google.protobuf.ITimestamp|null} [readyTime] Set some time after game-states INITIAL or READY
                 * @property {google.protobuf.ITimestamp|null} [endHalf] Set some time after game-states SET or PLAYING
                 * @property {google.protobuf.ITimestamp|null} [ballFree] GamePhase ballFree
                 * @property {google.protobuf.ITimestamp|null} [ends] Set some time after game-state TIMEOUT
                 * @property {google.protobuf.ITimestamp|null} [nextHalf] Set some time after game-state FINISHED
                 */

                /**
                 * Constructs a new GamePhase.
                 * @memberof message.input.GameEvents
                 * @classdesc Represents a GamePhase.
                 * @implements IGamePhase
                 * @constructor
                 * @param {message.input.GameEvents.IGamePhase=} [properties] Properties to set
                 */
                function GamePhase(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * GamePhase phase.
                 * @member {message.input.GameState.Data.Phase} phase
                 * @memberof message.input.GameEvents.GamePhase
                 * @instance
                 */
                GamePhase.prototype.phase = 0;

                /**
                 * Set some time after game-states INITIAL or READY
                 * @member {google.protobuf.ITimestamp|null|undefined} readyTime
                 * @memberof message.input.GameEvents.GamePhase
                 * @instance
                 */
                GamePhase.prototype.readyTime = null;

                /**
                 * Set some time after game-states SET or PLAYING
                 * @member {google.protobuf.ITimestamp|null|undefined} endHalf
                 * @memberof message.input.GameEvents.GamePhase
                 * @instance
                 */
                GamePhase.prototype.endHalf = null;

                /**
                 * GamePhase ballFree.
                 * @member {google.protobuf.ITimestamp|null|undefined} ballFree
                 * @memberof message.input.GameEvents.GamePhase
                 * @instance
                 */
                GamePhase.prototype.ballFree = null;

                /**
                 * Set some time after game-state TIMEOUT
                 * @member {google.protobuf.ITimestamp|null|undefined} ends
                 * @memberof message.input.GameEvents.GamePhase
                 * @instance
                 */
                GamePhase.prototype.ends = null;

                /**
                 * Set some time after game-state FINISHED
                 * @member {google.protobuf.ITimestamp|null|undefined} nextHalf
                 * @memberof message.input.GameEvents.GamePhase
                 * @instance
                 */
                GamePhase.prototype.nextHalf = null;

                /**
                 * Encodes the specified GamePhase message. Does not implicitly {@link message.input.GameEvents.GamePhase.verify|verify} messages.
                 * @function encode
                 * @memberof message.input.GameEvents.GamePhase
                 * @static
                 * @param {message.input.GameEvents.IGamePhase} message GamePhase message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GamePhase.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.phase != null && Object.hasOwnProperty.call(message, "phase"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.phase);
                    if (message.readyTime != null && Object.hasOwnProperty.call(message, "readyTime"))
                        $root.google.protobuf.Timestamp.encode(message.readyTime, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.endHalf != null && Object.hasOwnProperty.call(message, "endHalf"))
                        $root.google.protobuf.Timestamp.encode(message.endHalf, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.ballFree != null && Object.hasOwnProperty.call(message, "ballFree"))
                        $root.google.protobuf.Timestamp.encode(message.ballFree, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.ends != null && Object.hasOwnProperty.call(message, "ends"))
                        $root.google.protobuf.Timestamp.encode(message.ends, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.nextHalf != null && Object.hasOwnProperty.call(message, "nextHalf"))
                        $root.google.protobuf.Timestamp.encode(message.nextHalf, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    return writer;
                };

                /**
                 * Decodes a GamePhase message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.input.GameEvents.GamePhase
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.GameEvents.GamePhase} GamePhase
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GamePhase.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.GameEvents.GamePhase();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.phase = reader.int32();
                            break;
                        case 2:
                            message.readyTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.endHalf = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.ballFree = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.ends = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.nextHalf = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return GamePhase;
            })();

            GameEvents.GameMode = (function() {

                /**
                 * Properties of a GameMode.
                 * @memberof message.input.GameEvents
                 * @interface IGameMode
                 * @property {message.input.GameState.Data.Mode|null} [mode] GameMode mode
                 */

                /**
                 * Constructs a new GameMode.
                 * @memberof message.input.GameEvents
                 * @classdesc Represents a GameMode.
                 * @implements IGameMode
                 * @constructor
                 * @param {message.input.GameEvents.IGameMode=} [properties] Properties to set
                 */
                function GameMode(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * GameMode mode.
                 * @member {message.input.GameState.Data.Mode} mode
                 * @memberof message.input.GameEvents.GameMode
                 * @instance
                 */
                GameMode.prototype.mode = 0;

                /**
                 * Encodes the specified GameMode message. Does not implicitly {@link message.input.GameEvents.GameMode.verify|verify} messages.
                 * @function encode
                 * @memberof message.input.GameEvents.GameMode
                 * @static
                 * @param {message.input.GameEvents.IGameMode} message GameMode message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GameMode.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.mode != null && Object.hasOwnProperty.call(message, "mode"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.mode);
                    return writer;
                };

                /**
                 * Decodes a GameMode message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.input.GameEvents.GameMode
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.GameEvents.GameMode} GameMode
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GameMode.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.GameEvents.GameMode();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.mode = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return GameMode;
            })();

            return GameEvents;
        })();

        input.GameState = (function() {

            /**
             * Properties of a GameState.
             * @memberof message.input
             * @interface IGameState
             * @property {message.input.GameState.IData|null} [data] GameState data
             */

            /**
             * Constructs a new GameState.
             * @memberof message.input
             * @classdesc Represents a GameState.
             * @implements IGameState
             * @constructor
             * @param {message.input.IGameState=} [properties] Properties to set
             */
            function GameState(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GameState data.
             * @member {message.input.GameState.IData|null|undefined} data
             * @memberof message.input.GameState
             * @instance
             */
            GameState.prototype.data = null;

            /**
             * Encodes the specified GameState message. Does not implicitly {@link message.input.GameState.verify|verify} messages.
             * @function encode
             * @memberof message.input.GameState
             * @static
             * @param {message.input.IGameState} message GameState message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GameState.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    $root.message.input.GameState.Data.encode(message.data, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a GameState message from the specified reader or buffer.
             * @function decode
             * @memberof message.input.GameState
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.input.GameState} GameState
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GameState.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.GameState();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.data = $root.message.input.GameState.Data.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            GameState.Data = (function() {

                /**
                 * Properties of a Data.
                 * @memberof message.input.GameState
                 * @interface IData
                 * @property {message.input.GameState.Data.Phase|null} [phase] Data phase
                 * @property {message.input.GameState.Data.Mode|null} [mode] Data mode
                 * @property {boolean|null} [firstHalf] Data firstHalf
                 * @property {boolean|null} [kickedOutByUs] Data kickedOutByUs
                 * @property {google.protobuf.ITimestamp|null} [kickedOutTime] Data kickedOutTime
                 * @property {boolean|null} [ourKickOff] Data ourKickOff
                 * @property {google.protobuf.ITimestamp|null} [primaryTime] Timestamp when the robot thinks the half is due to end
                 * @property {google.protobuf.ITimestamp|null} [secondaryTime] A timestamp used for other times. E.g. how long in ready, or how long until penalty ends
                 * @property {message.input.GameState.Data.ITeam|null} [team] Data team
                 * @property {message.input.GameState.Data.ITeam|null} [opponent] Data opponent
                 * @property {message.input.GameState.Data.IRobot|null} [self] Data self
                 */

                /**
                 * Constructs a new Data.
                 * @memberof message.input.GameState
                 * @classdesc Represents a Data.
                 * @implements IData
                 * @constructor
                 * @param {message.input.GameState.IData=} [properties] Properties to set
                 */
                function Data(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Data phase.
                 * @member {message.input.GameState.Data.Phase} phase
                 * @memberof message.input.GameState.Data
                 * @instance
                 */
                Data.prototype.phase = 0;

                /**
                 * Data mode.
                 * @member {message.input.GameState.Data.Mode} mode
                 * @memberof message.input.GameState.Data
                 * @instance
                 */
                Data.prototype.mode = 0;

                /**
                 * Data firstHalf.
                 * @member {boolean} firstHalf
                 * @memberof message.input.GameState.Data
                 * @instance
                 */
                Data.prototype.firstHalf = false;

                /**
                 * Data kickedOutByUs.
                 * @member {boolean} kickedOutByUs
                 * @memberof message.input.GameState.Data
                 * @instance
                 */
                Data.prototype.kickedOutByUs = false;

                /**
                 * Data kickedOutTime.
                 * @member {google.protobuf.ITimestamp|null|undefined} kickedOutTime
                 * @memberof message.input.GameState.Data
                 * @instance
                 */
                Data.prototype.kickedOutTime = null;

                /**
                 * Data ourKickOff.
                 * @member {boolean} ourKickOff
                 * @memberof message.input.GameState.Data
                 * @instance
                 */
                Data.prototype.ourKickOff = false;

                /**
                 * Timestamp when the robot thinks the half is due to end
                 * @member {google.protobuf.ITimestamp|null|undefined} primaryTime
                 * @memberof message.input.GameState.Data
                 * @instance
                 */
                Data.prototype.primaryTime = null;

                /**
                 * A timestamp used for other times. E.g. how long in ready, or how long until penalty ends
                 * @member {google.protobuf.ITimestamp|null|undefined} secondaryTime
                 * @memberof message.input.GameState.Data
                 * @instance
                 */
                Data.prototype.secondaryTime = null;

                /**
                 * Data team.
                 * @member {message.input.GameState.Data.ITeam|null|undefined} team
                 * @memberof message.input.GameState.Data
                 * @instance
                 */
                Data.prototype.team = null;

                /**
                 * Data opponent.
                 * @member {message.input.GameState.Data.ITeam|null|undefined} opponent
                 * @memberof message.input.GameState.Data
                 * @instance
                 */
                Data.prototype.opponent = null;

                /**
                 * Data self.
                 * @member {message.input.GameState.Data.IRobot|null|undefined} self
                 * @memberof message.input.GameState.Data
                 * @instance
                 */
                Data.prototype.self = null;

                /**
                 * Encodes the specified Data message. Does not implicitly {@link message.input.GameState.Data.verify|verify} messages.
                 * @function encode
                 * @memberof message.input.GameState.Data
                 * @static
                 * @param {message.input.GameState.IData} message Data message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Data.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.phase != null && Object.hasOwnProperty.call(message, "phase"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.phase);
                    if (message.mode != null && Object.hasOwnProperty.call(message, "mode"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.mode);
                    if (message.firstHalf != null && Object.hasOwnProperty.call(message, "firstHalf"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.firstHalf);
                    if (message.kickedOutByUs != null && Object.hasOwnProperty.call(message, "kickedOutByUs"))
                        writer.uint32(/* id 4, wireType 0 =*/32).bool(message.kickedOutByUs);
                    if (message.kickedOutTime != null && Object.hasOwnProperty.call(message, "kickedOutTime"))
                        $root.google.protobuf.Timestamp.encode(message.kickedOutTime, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.ourKickOff != null && Object.hasOwnProperty.call(message, "ourKickOff"))
                        writer.uint32(/* id 6, wireType 0 =*/48).bool(message.ourKickOff);
                    if (message.primaryTime != null && Object.hasOwnProperty.call(message, "primaryTime"))
                        $root.google.protobuf.Timestamp.encode(message.primaryTime, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.secondaryTime != null && Object.hasOwnProperty.call(message, "secondaryTime"))
                        $root.google.protobuf.Timestamp.encode(message.secondaryTime, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.team != null && Object.hasOwnProperty.call(message, "team"))
                        $root.message.input.GameState.Data.Team.encode(message.team, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    if (message.opponent != null && Object.hasOwnProperty.call(message, "opponent"))
                        $root.message.input.GameState.Data.Team.encode(message.opponent, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                    if (message.self != null && Object.hasOwnProperty.call(message, "self"))
                        $root.message.input.GameState.Data.Robot.encode(message.self, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                    return writer;
                };

                /**
                 * Decodes a Data message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.input.GameState.Data
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.GameState.Data} Data
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Data.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.GameState.Data();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.phase = reader.int32();
                            break;
                        case 2:
                            message.mode = reader.int32();
                            break;
                        case 3:
                            message.firstHalf = reader.bool();
                            break;
                        case 4:
                            message.kickedOutByUs = reader.bool();
                            break;
                        case 5:
                            message.kickedOutTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.ourKickOff = reader.bool();
                            break;
                        case 7:
                            message.primaryTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 8:
                            message.secondaryTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 9:
                            message.team = $root.message.input.GameState.Data.Team.decode(reader, reader.uint32());
                            break;
                        case 10:
                            message.opponent = $root.message.input.GameState.Data.Team.decode(reader, reader.uint32());
                            break;
                        case 11:
                            message.self = $root.message.input.GameState.Data.Robot.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Mode enum.
                 * @name message.input.GameState.Data.Mode
                 * @enum {number}
                 * @property {number} UNKNOWN_MODE=0 UNKNOWN_MODE value
                 * @property {number} NORMAL=1 NORMAL value
                 * @property {number} PENALTY_SHOOTOUT=2 PENALTY_SHOOTOUT value
                 * @property {number} OVERTIME=3 OVERTIME value
                 */
                Data.Mode = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "UNKNOWN_MODE"] = 0;
                    values[valuesById[1] = "NORMAL"] = 1;
                    values[valuesById[2] = "PENALTY_SHOOTOUT"] = 2;
                    values[valuesById[3] = "OVERTIME"] = 3;
                    return values;
                })();

                /**
                 * Phase enum.
                 * @name message.input.GameState.Data.Phase
                 * @enum {number}
                 * @property {number} UNKNOWN_PHASE=0 UNKNOWN_PHASE value
                 * @property {number} INITIAL=1 INITIAL value
                 * @property {number} READY=2 READY value
                 * @property {number} SET=3 SET value
                 * @property {number} PLAYING=4 PLAYING value
                 * @property {number} TIMEOUT=5 TIMEOUT value
                 * @property {number} FINISHED=6 FINISHED value
                 */
                Data.Phase = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "UNKNOWN_PHASE"] = 0;
                    values[valuesById[1] = "INITIAL"] = 1;
                    values[valuesById[2] = "READY"] = 2;
                    values[valuesById[3] = "SET"] = 3;
                    values[valuesById[4] = "PLAYING"] = 4;
                    values[valuesById[5] = "TIMEOUT"] = 5;
                    values[valuesById[6] = "FINISHED"] = 6;
                    return values;
                })();

                /**
                 * PenaltyReason enum.
                 * @name message.input.GameState.Data.PenaltyReason
                 * @enum {number}
                 * @property {number} UNKNOWN_PENALTY_REASON=0 UNKNOWN_PENALTY_REASON value
                 * @property {number} UNPENALISED=1 UNPENALISED value
                 * @property {number} BALL_MANIPULATION=2 BALL_MANIPULATION value
                 * @property {number} PHYSICAL_CONTACT=3 PHYSICAL_CONTACT value
                 * @property {number} ILLEGAL_ATTACK=4 ILLEGAL_ATTACK value
                 * @property {number} ILLEGAL_DEFENSE=5 ILLEGAL_DEFENSE value
                 * @property {number} REQUEST_FOR_PICKUP=6 REQUEST_FOR_PICKUP value
                 * @property {number} REQUEST_FOR_SERVICE=7 REQUEST_FOR_SERVICE value
                 * @property {number} REQUEST_FOR_PICKUP_TO_SERVICE=8 REQUEST_FOR_PICKUP_TO_SERVICE value
                 * @property {number} SUBSTITUTE=9 SUBSTITUTE value
                 * @property {number} MANUAL=10 MANUAL value
                 * @property {number} PLAYER_PUSHING=11 PLAYER_PUSHING value
                 */
                Data.PenaltyReason = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "UNKNOWN_PENALTY_REASON"] = 0;
                    values[valuesById[1] = "UNPENALISED"] = 1;
                    values[valuesById[2] = "BALL_MANIPULATION"] = 2;
                    values[valuesById[3] = "PHYSICAL_CONTACT"] = 3;
                    values[valuesById[4] = "ILLEGAL_ATTACK"] = 4;
                    values[valuesById[5] = "ILLEGAL_DEFENSE"] = 5;
                    values[valuesById[6] = "REQUEST_FOR_PICKUP"] = 6;
                    values[valuesById[7] = "REQUEST_FOR_SERVICE"] = 7;
                    values[valuesById[8] = "REQUEST_FOR_PICKUP_TO_SERVICE"] = 8;
                    values[valuesById[9] = "SUBSTITUTE"] = 9;
                    values[valuesById[10] = "MANUAL"] = 10;
                    values[valuesById[11] = "PLAYER_PUSHING"] = 11;
                    return values;
                })();

                Data.Robot = (function() {

                    /**
                     * Properties of a Robot.
                     * @memberof message.input.GameState.Data
                     * @interface IRobot
                     * @property {number|null} [id] Robot id
                     * @property {message.input.GameState.Data.PenaltyReason|null} [penaltyReason] Robot penaltyReason
                     * @property {google.protobuf.ITimestamp|null} [unpenalised] The timestamp when the robot will be playing again
                     */

                    /**
                     * Constructs a new Robot.
                     * @memberof message.input.GameState.Data
                     * @classdesc Used to keep track of penalised robots
                     * @implements IRobot
                     * @constructor
                     * @param {message.input.GameState.Data.IRobot=} [properties] Properties to set
                     */
                    function Robot(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Robot id.
                     * @member {number} id
                     * @memberof message.input.GameState.Data.Robot
                     * @instance
                     */
                    Robot.prototype.id = 0;

                    /**
                     * Robot penaltyReason.
                     * @member {message.input.GameState.Data.PenaltyReason} penaltyReason
                     * @memberof message.input.GameState.Data.Robot
                     * @instance
                     */
                    Robot.prototype.penaltyReason = 0;

                    /**
                     * The timestamp when the robot will be playing again
                     * @member {google.protobuf.ITimestamp|null|undefined} unpenalised
                     * @memberof message.input.GameState.Data.Robot
                     * @instance
                     */
                    Robot.prototype.unpenalised = null;

                    /**
                     * Encodes the specified Robot message. Does not implicitly {@link message.input.GameState.Data.Robot.verify|verify} messages.
                     * @function encode
                     * @memberof message.input.GameState.Data.Robot
                     * @static
                     * @param {message.input.GameState.Data.IRobot} message Robot message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Robot.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                        if (message.penaltyReason != null && Object.hasOwnProperty.call(message, "penaltyReason"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.penaltyReason);
                        if (message.unpenalised != null && Object.hasOwnProperty.call(message, "unpenalised"))
                            $root.google.protobuf.Timestamp.encode(message.unpenalised, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Decodes a Robot message from the specified reader or buffer.
                     * @function decode
                     * @memberof message.input.GameState.Data.Robot
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {message.input.GameState.Data.Robot} Robot
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Robot.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.GameState.Data.Robot();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.id = reader.uint32();
                                break;
                            case 2:
                                message.penaltyReason = reader.int32();
                                break;
                            case 3:
                                message.unpenalised = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    return Robot;
                })();

                Data.Team = (function() {

                    /**
                     * Properties of a Team.
                     * @memberof message.input.GameState.Data
                     * @interface ITeam
                     * @property {number|null} [teamId] Team teamId
                     * @property {number|null} [score] Team score
                     * @property {string|null} [coachMessage] Team coachMessage
                     * @property {Array.<message.input.GameState.Data.IRobot>|null} [players] Team players
                     */

                    /**
                     * Constructs a new Team.
                     * @memberof message.input.GameState.Data
                     * @classdesc Represents a Team.
                     * @implements ITeam
                     * @constructor
                     * @param {message.input.GameState.Data.ITeam=} [properties] Properties to set
                     */
                    function Team(properties) {
                        this.players = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Team teamId.
                     * @member {number} teamId
                     * @memberof message.input.GameState.Data.Team
                     * @instance
                     */
                    Team.prototype.teamId = 0;

                    /**
                     * Team score.
                     * @member {number} score
                     * @memberof message.input.GameState.Data.Team
                     * @instance
                     */
                    Team.prototype.score = 0;

                    /**
                     * Team coachMessage.
                     * @member {string} coachMessage
                     * @memberof message.input.GameState.Data.Team
                     * @instance
                     */
                    Team.prototype.coachMessage = "";

                    /**
                     * Team players.
                     * @member {Array.<message.input.GameState.Data.IRobot>} players
                     * @memberof message.input.GameState.Data.Team
                     * @instance
                     */
                    Team.prototype.players = $util.emptyArray;

                    /**
                     * Encodes the specified Team message. Does not implicitly {@link message.input.GameState.Data.Team.verify|verify} messages.
                     * @function encode
                     * @memberof message.input.GameState.Data.Team
                     * @static
                     * @param {message.input.GameState.Data.ITeam} message Team message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Team.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.teamId != null && Object.hasOwnProperty.call(message, "teamId"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.teamId);
                        if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.score);
                        if (message.coachMessage != null && Object.hasOwnProperty.call(message, "coachMessage"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.coachMessage);
                        if (message.players != null && message.players.length)
                            for (let i = 0; i < message.players.length; ++i)
                                $root.message.input.GameState.Data.Robot.encode(message.players[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Decodes a Team message from the specified reader or buffer.
                     * @function decode
                     * @memberof message.input.GameState.Data.Team
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {message.input.GameState.Data.Team} Team
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Team.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.GameState.Data.Team();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.teamId = reader.uint32();
                                break;
                            case 2:
                                message.score = reader.uint32();
                                break;
                            case 3:
                                message.coachMessage = reader.string();
                                break;
                            case 4:
                                if (!(message.players && message.players.length))
                                    message.players = [];
                                message.players.push($root.message.input.GameState.Data.Robot.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    return Team;
                })();

                return Data;
            })();

            return GameState;
        })();

        input.Image = (function() {

            /**
             * Properties of an Image.
             * @memberof message.input
             * @interface IImage
             * @property {number|null} [format] see module::output::compressor::turbojpeg::Compressor::compress for currently supported formats
             * @property {Iuvec2|null} [dimensions] Number of pixels of {x, y} of the image
             * @property {Uint8Array|null} [data] Image data
             * @property {number|null} [id] Image id
             * @property {string|null} [name] Image name
             * @property {google.protobuf.ITimestamp|null} [timestamp] Image timestamp
             * @property {Imat4|null} [Hcw] World to camera Isometry3d transform
             * @property {message.input.Image.ILens|null} [lens] Image lens
             * @property {message.platform.webots.IVisionGroundTruth|null} [visionGroundTruth] Ground truth data from webots
             */

            /**
             * Constructs a new Image.
             * @memberof message.input
             * @classdesc Represents an Image.
             * @implements IImage
             * @constructor
             * @param {message.input.IImage=} [properties] Properties to set
             */
            function Image(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * see module::output::compressor::turbojpeg::Compressor::compress for currently supported formats
             * @member {number} format
             * @memberof message.input.Image
             * @instance
             */
            Image.prototype.format = 0;

            /**
             * Number of pixels of {x, y} of the image
             * @member {Iuvec2|null|undefined} dimensions
             * @memberof message.input.Image
             * @instance
             */
            Image.prototype.dimensions = null;

            /**
             * Image data.
             * @member {Uint8Array} data
             * @memberof message.input.Image
             * @instance
             */
            Image.prototype.data = $util.newBuffer([]);

            /**
             * Image id.
             * @member {number} id
             * @memberof message.input.Image
             * @instance
             */
            Image.prototype.id = 0;

            /**
             * Image name.
             * @member {string} name
             * @memberof message.input.Image
             * @instance
             */
            Image.prototype.name = "";

            /**
             * Image timestamp.
             * @member {google.protobuf.ITimestamp|null|undefined} timestamp
             * @memberof message.input.Image
             * @instance
             */
            Image.prototype.timestamp = null;

            /**
             * World to camera Isometry3d transform
             * @member {Imat4|null|undefined} Hcw
             * @memberof message.input.Image
             * @instance
             */
            Image.prototype.Hcw = null;

            /**
             * Image lens.
             * @member {message.input.Image.ILens|null|undefined} lens
             * @memberof message.input.Image
             * @instance
             */
            Image.prototype.lens = null;

            /**
             * Ground truth data from webots
             * @member {message.platform.webots.IVisionGroundTruth|null|undefined} visionGroundTruth
             * @memberof message.input.Image
             * @instance
             */
            Image.prototype.visionGroundTruth = null;

            /**
             * Encodes the specified Image message. Does not implicitly {@link message.input.Image.verify|verify} messages.
             * @function encode
             * @memberof message.input.Image
             * @static
             * @param {message.input.IImage} message Image message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Image.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.format != null && Object.hasOwnProperty.call(message, "format"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.format);
                if (message.dimensions != null && Object.hasOwnProperty.call(message, "dimensions"))
                    $root.uvec2.encode(message.dimensions, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.data);
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.id);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.name);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    $root.google.protobuf.Timestamp.encode(message.timestamp, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.Hcw != null && Object.hasOwnProperty.call(message, "Hcw"))
                    $root.mat4.encode(message.Hcw, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.lens != null && Object.hasOwnProperty.call(message, "lens"))
                    $root.message.input.Image.Lens.encode(message.lens, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.visionGroundTruth != null && Object.hasOwnProperty.call(message, "visionGroundTruth"))
                    $root.message.platform.webots.VisionGroundTruth.encode(message.visionGroundTruth, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes an Image message from the specified reader or buffer.
             * @function decode
             * @memberof message.input.Image
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.input.Image} Image
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Image.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.Image();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.format = reader.uint32();
                        break;
                    case 2:
                        message.dimensions = $root.uvec2.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.data = reader.bytes();
                        break;
                    case 4:
                        message.id = reader.uint32();
                        break;
                    case 5:
                        message.name = reader.string();
                        break;
                    case 6:
                        message.timestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.Hcw = $root.mat4.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.lens = $root.message.input.Image.Lens.decode(reader, reader.uint32());
                        break;
                    case 9:
                        message.visionGroundTruth = $root.message.platform.webots.VisionGroundTruth.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            Image.Lens = (function() {

                /**
                 * Properties of a Lens.
                 * @memberof message.input.Image
                 * @interface ILens
                 * @property {message.input.Image.Lens.Projection|null} [projection] Lens projection
                 * @property {number|null} [focalLength] Normalised focal length: focal length in pixels / image width
                 * @property {number|null} [fov] The angular diameter that the lens covers (the area that light hits on the sensor). In radians
                 * @property {Ifvec2|null} [centre] Normalised image centre offset: pixels from centre to optical axis / image width
                 * @property {Ifvec2|null} [k] Lens k
                 */

                /**
                 * Constructs a new Lens.
                 * @memberof message.input.Image
                 * @classdesc Represents a Lens.
                 * @implements ILens
                 * @constructor
                 * @param {message.input.Image.ILens=} [properties] Properties to set
                 */
                function Lens(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Lens projection.
                 * @member {message.input.Image.Lens.Projection} projection
                 * @memberof message.input.Image.Lens
                 * @instance
                 */
                Lens.prototype.projection = 0;

                /**
                 * Normalised focal length: focal length in pixels / image width
                 * @member {number} focalLength
                 * @memberof message.input.Image.Lens
                 * @instance
                 */
                Lens.prototype.focalLength = 0;

                /**
                 * The angular diameter that the lens covers (the area that light hits on the sensor). In radians
                 * @member {number} fov
                 * @memberof message.input.Image.Lens
                 * @instance
                 */
                Lens.prototype.fov = 0;

                /**
                 * Normalised image centre offset: pixels from centre to optical axis / image width
                 * @member {Ifvec2|null|undefined} centre
                 * @memberof message.input.Image.Lens
                 * @instance
                 */
                Lens.prototype.centre = null;

                /**
                 * Lens k.
                 * @member {Ifvec2|null|undefined} k
                 * @memberof message.input.Image.Lens
                 * @instance
                 */
                Lens.prototype.k = null;

                /**
                 * Encodes the specified Lens message. Does not implicitly {@link message.input.Image.Lens.verify|verify} messages.
                 * @function encode
                 * @memberof message.input.Image.Lens
                 * @static
                 * @param {message.input.Image.ILens} message Lens message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Lens.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.projection != null && Object.hasOwnProperty.call(message, "projection"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.projection);
                    if (message.focalLength != null && Object.hasOwnProperty.call(message, "focalLength"))
                        writer.uint32(/* id 2, wireType 5 =*/21).float(message.focalLength);
                    if (message.fov != null && Object.hasOwnProperty.call(message, "fov"))
                        writer.uint32(/* id 3, wireType 5 =*/29).float(message.fov);
                    if (message.centre != null && Object.hasOwnProperty.call(message, "centre"))
                        $root.fvec2.encode(message.centre, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.k != null && Object.hasOwnProperty.call(message, "k"))
                        $root.fvec2.encode(message.k, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    return writer;
                };

                /**
                 * Decodes a Lens message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.input.Image.Lens
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.Image.Lens} Lens
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Lens.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.Image.Lens();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.projection = reader.int32();
                            break;
                        case 2:
                            message.focalLength = reader.float();
                            break;
                        case 3:
                            message.fov = reader.float();
                            break;
                        case 4:
                            message.centre = $root.fvec2.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.k = $root.fvec2.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Projection enum.
                 * @name message.input.Image.Lens.Projection
                 * @enum {number}
                 * @property {number} UNKNOWN=0 UNKNOWN value
                 * @property {number} RECTILINEAR=1 RECTILINEAR value
                 * @property {number} EQUIDISTANT=2 EQUIDISTANT value
                 * @property {number} EQUISOLID=3 EQUISOLID value
                 */
                Lens.Projection = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "UNKNOWN"] = 0;
                    values[valuesById[1] = "RECTILINEAR"] = 1;
                    values[valuesById[2] = "EQUIDISTANT"] = 2;
                    values[valuesById[3] = "EQUISOLID"] = 3;
                    return values;
                })();

                return Lens;
            })();

            return Image;
        })();

        input.MotionCapture = (function() {

            /**
             * Properties of a MotionCapture.
             * @memberof message.input
             * @interface IMotionCapture
             * @property {number|null} [frameNumber] MotionCapture frameNumber
             * @property {number|null} [latency] MotionCapture latency
             * @property {number|null} [timecode] https://en.wikipedia.org/wiki/SMPTE_timecode
             * @property {number|null} [timecodeSub] MotionCapture timecodeSub
             * @property {number|null} [natnetTimestamp] MotionCapture natnetTimestamp
             * @property {number|null} [midExposureTimestamp] MotionCapture midExposureTimestamp
             * @property {number|null} [dataReceivedTimestamp] MotionCapture dataReceivedTimestamp
             * @property {number|null} [transmitTimestamp] MotionCapture transmitTimestamp
             * @property {boolean|null} [recording] Whether or not this frame is to be recorded
             * @property {boolean|null} [trackedModelsChanged] MotionCapture trackedModelsChanged
             * @property {Array.<message.input.MotionCapture.IMarkerSet>|null} [markerSets] MotionCapture markerSets
             * @property {Array.<message.input.MotionCapture.IMarker>|null} [markers] MotionCapture markers
             * @property {Array.<message.input.MotionCapture.IRigidBody>|null} [rigidBodies] MotionCapture rigidBodies
             * @property {Array.<message.input.MotionCapture.ISkeleton>|null} [skeletons] MotionCapture skeletons
             * @property {Array.<message.input.MotionCapture.ILabeledMarker>|null} [labeledMarkers] MotionCapture labeledMarkers
             * @property {Array.<message.input.MotionCapture.IForcePlate>|null} [forcePlates] MotionCapture forcePlates
             * @property {Array.<message.input.MotionCapture.IDevice>|null} [devices] MotionCapture devices
             */

            /**
             * Constructs a new MotionCapture.
             * @memberof message.input
             * @classdesc Contains Marker, Rigidbody, and message metadata information.
             * We use optitrack for our mocap system. Their documentation is here:
             * https://v22.wiki.optitrack.com/index.php?title=OptiTrack_Documentation_Wiki
             * @implements IMotionCapture
             * @constructor
             * @param {message.input.IMotionCapture=} [properties] Properties to set
             */
            function MotionCapture(properties) {
                this.markerSets = [];
                this.markers = [];
                this.rigidBodies = [];
                this.skeletons = [];
                this.labeledMarkers = [];
                this.forcePlates = [];
                this.devices = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MotionCapture frameNumber.
             * @member {number} frameNumber
             * @memberof message.input.MotionCapture
             * @instance
             */
            MotionCapture.prototype.frameNumber = 0;

            /**
             * MotionCapture latency.
             * @member {number} latency
             * @memberof message.input.MotionCapture
             * @instance
             */
            MotionCapture.prototype.latency = 0;

            /**
             * https://en.wikipedia.org/wiki/SMPTE_timecode
             * @member {number} timecode
             * @memberof message.input.MotionCapture
             * @instance
             */
            MotionCapture.prototype.timecode = 0;

            /**
             * MotionCapture timecodeSub.
             * @member {number} timecodeSub
             * @memberof message.input.MotionCapture
             * @instance
             */
            MotionCapture.prototype.timecodeSub = 0;

            /**
             * MotionCapture natnetTimestamp.
             * @member {number} natnetTimestamp
             * @memberof message.input.MotionCapture
             * @instance
             */
            MotionCapture.prototype.natnetTimestamp = 0;

            /**
             * MotionCapture midExposureTimestamp.
             * @member {number} midExposureTimestamp
             * @memberof message.input.MotionCapture
             * @instance
             */
            MotionCapture.prototype.midExposureTimestamp = 0;

            /**
             * MotionCapture dataReceivedTimestamp.
             * @member {number} dataReceivedTimestamp
             * @memberof message.input.MotionCapture
             * @instance
             */
            MotionCapture.prototype.dataReceivedTimestamp = 0;

            /**
             * MotionCapture transmitTimestamp.
             * @member {number} transmitTimestamp
             * @memberof message.input.MotionCapture
             * @instance
             */
            MotionCapture.prototype.transmitTimestamp = 0;

            /**
             * Whether or not this frame is to be recorded
             * @member {boolean} recording
             * @memberof message.input.MotionCapture
             * @instance
             */
            MotionCapture.prototype.recording = false;

            /**
             * MotionCapture trackedModelsChanged.
             * @member {boolean} trackedModelsChanged
             * @memberof message.input.MotionCapture
             * @instance
             */
            MotionCapture.prototype.trackedModelsChanged = false;

            /**
             * MotionCapture markerSets.
             * @member {Array.<message.input.MotionCapture.IMarkerSet>} markerSets
             * @memberof message.input.MotionCapture
             * @instance
             */
            MotionCapture.prototype.markerSets = $util.emptyArray;

            /**
             * MotionCapture markers.
             * @member {Array.<message.input.MotionCapture.IMarker>} markers
             * @memberof message.input.MotionCapture
             * @instance
             */
            MotionCapture.prototype.markers = $util.emptyArray;

            /**
             * MotionCapture rigidBodies.
             * @member {Array.<message.input.MotionCapture.IRigidBody>} rigidBodies
             * @memberof message.input.MotionCapture
             * @instance
             */
            MotionCapture.prototype.rigidBodies = $util.emptyArray;

            /**
             * MotionCapture skeletons.
             * @member {Array.<message.input.MotionCapture.ISkeleton>} skeletons
             * @memberof message.input.MotionCapture
             * @instance
             */
            MotionCapture.prototype.skeletons = $util.emptyArray;

            /**
             * MotionCapture labeledMarkers.
             * @member {Array.<message.input.MotionCapture.ILabeledMarker>} labeledMarkers
             * @memberof message.input.MotionCapture
             * @instance
             */
            MotionCapture.prototype.labeledMarkers = $util.emptyArray;

            /**
             * MotionCapture forcePlates.
             * @member {Array.<message.input.MotionCapture.IForcePlate>} forcePlates
             * @memberof message.input.MotionCapture
             * @instance
             */
            MotionCapture.prototype.forcePlates = $util.emptyArray;

            /**
             * MotionCapture devices.
             * @member {Array.<message.input.MotionCapture.IDevice>} devices
             * @memberof message.input.MotionCapture
             * @instance
             */
            MotionCapture.prototype.devices = $util.emptyArray;

            /**
             * Encodes the specified MotionCapture message. Does not implicitly {@link message.input.MotionCapture.verify|verify} messages.
             * @function encode
             * @memberof message.input.MotionCapture
             * @static
             * @param {message.input.IMotionCapture} message MotionCapture message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MotionCapture.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.frameNumber != null && Object.hasOwnProperty.call(message, "frameNumber"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.frameNumber);
                if (message.latency != null && Object.hasOwnProperty.call(message, "latency"))
                    writer.uint32(/* id 2, wireType 5 =*/21).float(message.latency);
                if (message.timecode != null && Object.hasOwnProperty.call(message, "timecode"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.timecode);
                if (message.timecodeSub != null && Object.hasOwnProperty.call(message, "timecodeSub"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.timecodeSub);
                if (message.natnetTimestamp != null && Object.hasOwnProperty.call(message, "natnetTimestamp"))
                    writer.uint32(/* id 5, wireType 1 =*/41).double(message.natnetTimestamp);
                if (message.midExposureTimestamp != null && Object.hasOwnProperty.call(message, "midExposureTimestamp"))
                    writer.uint32(/* id 6, wireType 1 =*/49).double(message.midExposureTimestamp);
                if (message.dataReceivedTimestamp != null && Object.hasOwnProperty.call(message, "dataReceivedTimestamp"))
                    writer.uint32(/* id 7, wireType 1 =*/57).double(message.dataReceivedTimestamp);
                if (message.transmitTimestamp != null && Object.hasOwnProperty.call(message, "transmitTimestamp"))
                    writer.uint32(/* id 8, wireType 1 =*/65).double(message.transmitTimestamp);
                if (message.recording != null && Object.hasOwnProperty.call(message, "recording"))
                    writer.uint32(/* id 9, wireType 0 =*/72).bool(message.recording);
                if (message.trackedModelsChanged != null && Object.hasOwnProperty.call(message, "trackedModelsChanged"))
                    writer.uint32(/* id 10, wireType 0 =*/80).bool(message.trackedModelsChanged);
                if (message.markerSets != null && message.markerSets.length)
                    for (let i = 0; i < message.markerSets.length; ++i)
                        $root.message.input.MotionCapture.MarkerSet.encode(message.markerSets[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.markers != null && message.markers.length)
                    for (let i = 0; i < message.markers.length; ++i)
                        $root.message.input.MotionCapture.Marker.encode(message.markers[i], writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                if (message.rigidBodies != null && message.rigidBodies.length)
                    for (let i = 0; i < message.rigidBodies.length; ++i)
                        $root.message.input.MotionCapture.RigidBody.encode(message.rigidBodies[i], writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                if (message.skeletons != null && message.skeletons.length)
                    for (let i = 0; i < message.skeletons.length; ++i)
                        $root.message.input.MotionCapture.Skeleton.encode(message.skeletons[i], writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                if (message.labeledMarkers != null && message.labeledMarkers.length)
                    for (let i = 0; i < message.labeledMarkers.length; ++i)
                        $root.message.input.MotionCapture.LabeledMarker.encode(message.labeledMarkers[i], writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                if (message.forcePlates != null && message.forcePlates.length)
                    for (let i = 0; i < message.forcePlates.length; ++i)
                        $root.message.input.MotionCapture.ForcePlate.encode(message.forcePlates[i], writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
                if (message.devices != null && message.devices.length)
                    for (let i = 0; i < message.devices.length; ++i)
                        $root.message.input.MotionCapture.Device.encode(message.devices[i], writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a MotionCapture message from the specified reader or buffer.
             * @function decode
             * @memberof message.input.MotionCapture
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.input.MotionCapture} MotionCapture
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MotionCapture.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.MotionCapture();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.frameNumber = reader.uint32();
                        break;
                    case 2:
                        message.latency = reader.float();
                        break;
                    case 3:
                        message.timecode = reader.uint32();
                        break;
                    case 4:
                        message.timecodeSub = reader.uint32();
                        break;
                    case 5:
                        message.natnetTimestamp = reader.double();
                        break;
                    case 6:
                        message.midExposureTimestamp = reader.double();
                        break;
                    case 7:
                        message.dataReceivedTimestamp = reader.double();
                        break;
                    case 8:
                        message.transmitTimestamp = reader.double();
                        break;
                    case 9:
                        message.recording = reader.bool();
                        break;
                    case 10:
                        message.trackedModelsChanged = reader.bool();
                        break;
                    case 11:
                        if (!(message.markerSets && message.markerSets.length))
                            message.markerSets = [];
                        message.markerSets.push($root.message.input.MotionCapture.MarkerSet.decode(reader, reader.uint32()));
                        break;
                    case 12:
                        if (!(message.markers && message.markers.length))
                            message.markers = [];
                        message.markers.push($root.message.input.MotionCapture.Marker.decode(reader, reader.uint32()));
                        break;
                    case 13:
                        if (!(message.rigidBodies && message.rigidBodies.length))
                            message.rigidBodies = [];
                        message.rigidBodies.push($root.message.input.MotionCapture.RigidBody.decode(reader, reader.uint32()));
                        break;
                    case 14:
                        if (!(message.skeletons && message.skeletons.length))
                            message.skeletons = [];
                        message.skeletons.push($root.message.input.MotionCapture.Skeleton.decode(reader, reader.uint32()));
                        break;
                    case 15:
                        if (!(message.labeledMarkers && message.labeledMarkers.length))
                            message.labeledMarkers = [];
                        message.labeledMarkers.push($root.message.input.MotionCapture.LabeledMarker.decode(reader, reader.uint32()));
                        break;
                    case 16:
                        if (!(message.forcePlates && message.forcePlates.length))
                            message.forcePlates = [];
                        message.forcePlates.push($root.message.input.MotionCapture.ForcePlate.decode(reader, reader.uint32()));
                        break;
                    case 17:
                        if (!(message.devices && message.devices.length))
                            message.devices = [];
                        message.devices.push($root.message.input.MotionCapture.Device.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            MotionCapture.Marker = (function() {

                /**
                 * Properties of a Marker.
                 * @memberof message.input.MotionCapture
                 * @interface IMarker
                 * @property {number|null} [id] Marker id
                 * @property {Ifvec3|null} [position] Marker position
                 * @property {number|null} [size] Marker size
                 */

                /**
                 * Constructs a new Marker.
                 * @memberof message.input.MotionCapture
                 * @classdesc Mocap reference points to track
                 * @implements IMarker
                 * @constructor
                 * @param {message.input.MotionCapture.IMarker=} [properties] Properties to set
                 */
                function Marker(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Marker id.
                 * @member {number} id
                 * @memberof message.input.MotionCapture.Marker
                 * @instance
                 */
                Marker.prototype.id = 0;

                /**
                 * Marker position.
                 * @member {Ifvec3|null|undefined} position
                 * @memberof message.input.MotionCapture.Marker
                 * @instance
                 */
                Marker.prototype.position = null;

                /**
                 * Marker size.
                 * @member {number} size
                 * @memberof message.input.MotionCapture.Marker
                 * @instance
                 */
                Marker.prototype.size = 0;

                /**
                 * Encodes the specified Marker message. Does not implicitly {@link message.input.MotionCapture.Marker.verify|verify} messages.
                 * @function encode
                 * @memberof message.input.MotionCapture.Marker
                 * @static
                 * @param {message.input.MotionCapture.IMarker} message Marker message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Marker.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                    if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                        $root.fvec3.encode(message.position, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.size != null && Object.hasOwnProperty.call(message, "size"))
                        writer.uint32(/* id 3, wireType 5 =*/29).float(message.size);
                    return writer;
                };

                /**
                 * Decodes a Marker message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.input.MotionCapture.Marker
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.MotionCapture.Marker} Marker
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Marker.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.MotionCapture.Marker();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = reader.uint32();
                            break;
                        case 2:
                            message.position = $root.fvec3.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.size = reader.float();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return Marker;
            })();

            MotionCapture.MarkerSet = (function() {

                /**
                 * Properties of a MarkerSet.
                 * @memberof message.input.MotionCapture
                 * @interface IMarkerSet
                 * @property {string|null} [name] MarkerSet name
                 * @property {Array.<message.input.MotionCapture.IMarker>|null} [markers] MarkerSet markers
                 */

                /**
                 * Constructs a new MarkerSet.
                 * @memberof message.input.MotionCapture
                 * @classdesc Represents a MarkerSet.
                 * @implements IMarkerSet
                 * @constructor
                 * @param {message.input.MotionCapture.IMarkerSet=} [properties] Properties to set
                 */
                function MarkerSet(properties) {
                    this.markers = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MarkerSet name.
                 * @member {string} name
                 * @memberof message.input.MotionCapture.MarkerSet
                 * @instance
                 */
                MarkerSet.prototype.name = "";

                /**
                 * MarkerSet markers.
                 * @member {Array.<message.input.MotionCapture.IMarker>} markers
                 * @memberof message.input.MotionCapture.MarkerSet
                 * @instance
                 */
                MarkerSet.prototype.markers = $util.emptyArray;

                /**
                 * Encodes the specified MarkerSet message. Does not implicitly {@link message.input.MotionCapture.MarkerSet.verify|verify} messages.
                 * @function encode
                 * @memberof message.input.MotionCapture.MarkerSet
                 * @static
                 * @param {message.input.MotionCapture.IMarkerSet} message MarkerSet message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MarkerSet.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.markers != null && message.markers.length)
                        for (let i = 0; i < message.markers.length; ++i)
                            $root.message.input.MotionCapture.Marker.encode(message.markers[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Decodes a MarkerSet message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.input.MotionCapture.MarkerSet
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.MotionCapture.MarkerSet} MarkerSet
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MarkerSet.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.MotionCapture.MarkerSet();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            if (!(message.markers && message.markers.length))
                                message.markers = [];
                            message.markers.push($root.message.input.MotionCapture.Marker.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return MarkerSet;
            })();

            MotionCapture.RigidBody = (function() {

                /**
                 * Properties of a RigidBody.
                 * @memberof message.input.MotionCapture
                 * @interface IRigidBody
                 * @property {number|null} [id] RigidBody id
                 * @property {Ifvec3|null} [position] RigidBody position
                 * @property {Ifvec4|null} [rotation] Quaternion representation of the rigid body's rotation
                 * @property {Array.<message.input.MotionCapture.IMarker>|null} [markers] RigidBody markers
                 * @property {number|null} [error] RigidBody error
                 * @property {boolean|null} [trackingValid] RigidBody trackingValid
                 * @property {string|null} [name] RigidBody name
                 * @property {Ifvec3|null} [offset] RigidBody offset
                 * @property {number|null} [parent] RigidBody parent
                 * @property {Array.<number>|null} [children] RigidBody children
                 */

                /**
                 * Constructs a new RigidBody.
                 * @memberof message.input.MotionCapture
                 * @classdesc bones which make up skeletons are RigidBodys
                 * @implements IRigidBody
                 * @constructor
                 * @param {message.input.MotionCapture.IRigidBody=} [properties] Properties to set
                 */
                function RigidBody(properties) {
                    this.markers = [];
                    this.children = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * RigidBody id.
                 * @member {number} id
                 * @memberof message.input.MotionCapture.RigidBody
                 * @instance
                 */
                RigidBody.prototype.id = 0;

                /**
                 * RigidBody position.
                 * @member {Ifvec3|null|undefined} position
                 * @memberof message.input.MotionCapture.RigidBody
                 * @instance
                 */
                RigidBody.prototype.position = null;

                /**
                 * Quaternion representation of the rigid body's rotation
                 * @member {Ifvec4|null|undefined} rotation
                 * @memberof message.input.MotionCapture.RigidBody
                 * @instance
                 */
                RigidBody.prototype.rotation = null;

                /**
                 * RigidBody markers.
                 * @member {Array.<message.input.MotionCapture.IMarker>} markers
                 * @memberof message.input.MotionCapture.RigidBody
                 * @instance
                 */
                RigidBody.prototype.markers = $util.emptyArray;

                /**
                 * RigidBody error.
                 * @member {number} error
                 * @memberof message.input.MotionCapture.RigidBody
                 * @instance
                 */
                RigidBody.prototype.error = 0;

                /**
                 * RigidBody trackingValid.
                 * @member {boolean} trackingValid
                 * @memberof message.input.MotionCapture.RigidBody
                 * @instance
                 */
                RigidBody.prototype.trackingValid = false;

                /**
                 * RigidBody name.
                 * @member {string} name
                 * @memberof message.input.MotionCapture.RigidBody
                 * @instance
                 */
                RigidBody.prototype.name = "";

                /**
                 * RigidBody offset.
                 * @member {Ifvec3|null|undefined} offset
                 * @memberof message.input.MotionCapture.RigidBody
                 * @instance
                 */
                RigidBody.prototype.offset = null;

                /**
                 * RigidBody parent.
                 * @member {number} parent
                 * @memberof message.input.MotionCapture.RigidBody
                 * @instance
                 */
                RigidBody.prototype.parent = 0;

                /**
                 * RigidBody children.
                 * @member {Array.<number>} children
                 * @memberof message.input.MotionCapture.RigidBody
                 * @instance
                 */
                RigidBody.prototype.children = $util.emptyArray;

                /**
                 * Encodes the specified RigidBody message. Does not implicitly {@link message.input.MotionCapture.RigidBody.verify|verify} messages.
                 * @function encode
                 * @memberof message.input.MotionCapture.RigidBody
                 * @static
                 * @param {message.input.MotionCapture.IRigidBody} message RigidBody message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RigidBody.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                    if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                        $root.fvec3.encode(message.position, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.rotation != null && Object.hasOwnProperty.call(message, "rotation"))
                        $root.fvec4.encode(message.rotation, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.markers != null && message.markers.length)
                        for (let i = 0; i < message.markers.length; ++i)
                            $root.message.input.MotionCapture.Marker.encode(message.markers[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                        writer.uint32(/* id 5, wireType 5 =*/45).float(message.error);
                    if (message.trackingValid != null && Object.hasOwnProperty.call(message, "trackingValid"))
                        writer.uint32(/* id 6, wireType 0 =*/48).bool(message.trackingValid);
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 7, wireType 2 =*/58).string(message.name);
                    if (message.offset != null && Object.hasOwnProperty.call(message, "offset"))
                        $root.fvec3.encode(message.offset, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.parent != null && Object.hasOwnProperty.call(message, "parent"))
                        writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.parent);
                    if (message.children != null && message.children.length) {
                        writer.uint32(/* id 10, wireType 2 =*/82).fork();
                        for (let i = 0; i < message.children.length; ++i)
                            writer.uint32(message.children[i]);
                        writer.ldelim();
                    }
                    return writer;
                };

                /**
                 * Decodes a RigidBody message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.input.MotionCapture.RigidBody
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.MotionCapture.RigidBody} RigidBody
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RigidBody.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.MotionCapture.RigidBody();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = reader.uint32();
                            break;
                        case 2:
                            message.position = $root.fvec3.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.rotation = $root.fvec4.decode(reader, reader.uint32());
                            break;
                        case 4:
                            if (!(message.markers && message.markers.length))
                                message.markers = [];
                            message.markers.push($root.message.input.MotionCapture.Marker.decode(reader, reader.uint32()));
                            break;
                        case 5:
                            message.error = reader.float();
                            break;
                        case 6:
                            message.trackingValid = reader.bool();
                            break;
                        case 7:
                            message.name = reader.string();
                            break;
                        case 8:
                            message.offset = $root.fvec3.decode(reader, reader.uint32());
                            break;
                        case 9:
                            message.parent = reader.uint32();
                            break;
                        case 10:
                            if (!(message.children && message.children.length))
                                message.children = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.children.push(reader.uint32());
                            } else
                                message.children.push(reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return RigidBody;
            })();

            MotionCapture.Skeleton = (function() {

                /**
                 * Properties of a Skeleton.
                 * @memberof message.input.MotionCapture
                 * @interface ISkeleton
                 * @property {number|null} [id] Skeleton id
                 * @property {Array.<message.input.MotionCapture.IRigidBody>|null} [bones] Skeleton bones
                 * @property {string|null} [name] Skeleton name
                 */

                /**
                 * Constructs a new Skeleton.
                 * @memberof message.input.MotionCapture
                 * @classdesc The whole character for which the motion represents
                 * @implements ISkeleton
                 * @constructor
                 * @param {message.input.MotionCapture.ISkeleton=} [properties] Properties to set
                 */
                function Skeleton(properties) {
                    this.bones = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Skeleton id.
                 * @member {number} id
                 * @memberof message.input.MotionCapture.Skeleton
                 * @instance
                 */
                Skeleton.prototype.id = 0;

                /**
                 * Skeleton bones.
                 * @member {Array.<message.input.MotionCapture.IRigidBody>} bones
                 * @memberof message.input.MotionCapture.Skeleton
                 * @instance
                 */
                Skeleton.prototype.bones = $util.emptyArray;

                /**
                 * Skeleton name.
                 * @member {string} name
                 * @memberof message.input.MotionCapture.Skeleton
                 * @instance
                 */
                Skeleton.prototype.name = "";

                /**
                 * Encodes the specified Skeleton message. Does not implicitly {@link message.input.MotionCapture.Skeleton.verify|verify} messages.
                 * @function encode
                 * @memberof message.input.MotionCapture.Skeleton
                 * @static
                 * @param {message.input.MotionCapture.ISkeleton} message Skeleton message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Skeleton.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                    if (message.bones != null && message.bones.length)
                        for (let i = 0; i < message.bones.length; ++i)
                            $root.message.input.MotionCapture.RigidBody.encode(message.bones[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
                    return writer;
                };

                /**
                 * Decodes a Skeleton message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.input.MotionCapture.Skeleton
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.MotionCapture.Skeleton} Skeleton
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Skeleton.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.MotionCapture.Skeleton();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = reader.uint32();
                            break;
                        case 2:
                            if (!(message.bones && message.bones.length))
                                message.bones = [];
                            message.bones.push($root.message.input.MotionCapture.RigidBody.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            message.name = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return Skeleton;
            })();

            MotionCapture.LabeledMarker = (function() {

                /**
                 * Properties of a LabeledMarker.
                 * @memberof message.input.MotionCapture
                 * @interface ILabeledMarker
                 * @property {message.input.MotionCapture.IMarker|null} [marker] LabeledMarker marker
                 * @property {boolean|null} [occluded] LabeledMarker occluded
                 * @property {boolean|null} [pointCloudSolved] LabeledMarker pointCloudSolved
                 * @property {boolean|null} [modelSolved] LabeledMarker modelSolved
                 * @property {number|null} [err] LabeledMarker err
                 * @property {boolean|null} [hasModel] LabeledMarker hasModel
                 * @property {boolean|null} [unlabeled] LabeledMarker unlabeled
                 * @property {boolean|null} [activeMarker] LabeledMarker activeMarker
                 */

                /**
                 * Constructs a new LabeledMarker.
                 * @memberof message.input.MotionCapture
                 * @classdesc Represents a LabeledMarker.
                 * @implements ILabeledMarker
                 * @constructor
                 * @param {message.input.MotionCapture.ILabeledMarker=} [properties] Properties to set
                 */
                function LabeledMarker(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * LabeledMarker marker.
                 * @member {message.input.MotionCapture.IMarker|null|undefined} marker
                 * @memberof message.input.MotionCapture.LabeledMarker
                 * @instance
                 */
                LabeledMarker.prototype.marker = null;

                /**
                 * LabeledMarker occluded.
                 * @member {boolean} occluded
                 * @memberof message.input.MotionCapture.LabeledMarker
                 * @instance
                 */
                LabeledMarker.prototype.occluded = false;

                /**
                 * LabeledMarker pointCloudSolved.
                 * @member {boolean} pointCloudSolved
                 * @memberof message.input.MotionCapture.LabeledMarker
                 * @instance
                 */
                LabeledMarker.prototype.pointCloudSolved = false;

                /**
                 * LabeledMarker modelSolved.
                 * @member {boolean} modelSolved
                 * @memberof message.input.MotionCapture.LabeledMarker
                 * @instance
                 */
                LabeledMarker.prototype.modelSolved = false;

                /**
                 * LabeledMarker err.
                 * @member {number} err
                 * @memberof message.input.MotionCapture.LabeledMarker
                 * @instance
                 */
                LabeledMarker.prototype.err = 0;

                /**
                 * LabeledMarker hasModel.
                 * @member {boolean} hasModel
                 * @memberof message.input.MotionCapture.LabeledMarker
                 * @instance
                 */
                LabeledMarker.prototype.hasModel = false;

                /**
                 * LabeledMarker unlabeled.
                 * @member {boolean} unlabeled
                 * @memberof message.input.MotionCapture.LabeledMarker
                 * @instance
                 */
                LabeledMarker.prototype.unlabeled = false;

                /**
                 * LabeledMarker activeMarker.
                 * @member {boolean} activeMarker
                 * @memberof message.input.MotionCapture.LabeledMarker
                 * @instance
                 */
                LabeledMarker.prototype.activeMarker = false;

                /**
                 * Encodes the specified LabeledMarker message. Does not implicitly {@link message.input.MotionCapture.LabeledMarker.verify|verify} messages.
                 * @function encode
                 * @memberof message.input.MotionCapture.LabeledMarker
                 * @static
                 * @param {message.input.MotionCapture.ILabeledMarker} message LabeledMarker message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LabeledMarker.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.marker != null && Object.hasOwnProperty.call(message, "marker"))
                        $root.message.input.MotionCapture.Marker.encode(message.marker, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.occluded != null && Object.hasOwnProperty.call(message, "occluded"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.occluded);
                    if (message.pointCloudSolved != null && Object.hasOwnProperty.call(message, "pointCloudSolved"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.pointCloudSolved);
                    if (message.modelSolved != null && Object.hasOwnProperty.call(message, "modelSolved"))
                        writer.uint32(/* id 4, wireType 0 =*/32).bool(message.modelSolved);
                    if (message.err != null && Object.hasOwnProperty.call(message, "err"))
                        writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.err);
                    if (message.hasModel != null && Object.hasOwnProperty.call(message, "hasModel"))
                        writer.uint32(/* id 6, wireType 0 =*/48).bool(message.hasModel);
                    if (message.unlabeled != null && Object.hasOwnProperty.call(message, "unlabeled"))
                        writer.uint32(/* id 7, wireType 0 =*/56).bool(message.unlabeled);
                    if (message.activeMarker != null && Object.hasOwnProperty.call(message, "activeMarker"))
                        writer.uint32(/* id 8, wireType 0 =*/64).bool(message.activeMarker);
                    return writer;
                };

                /**
                 * Decodes a LabeledMarker message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.input.MotionCapture.LabeledMarker
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.MotionCapture.LabeledMarker} LabeledMarker
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LabeledMarker.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.MotionCapture.LabeledMarker();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.marker = $root.message.input.MotionCapture.Marker.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.occluded = reader.bool();
                            break;
                        case 3:
                            message.pointCloudSolved = reader.bool();
                            break;
                        case 4:
                            message.modelSolved = reader.bool();
                            break;
                        case 5:
                            message.err = reader.uint32();
                            break;
                        case 6:
                            message.hasModel = reader.bool();
                            break;
                        case 7:
                            message.unlabeled = reader.bool();
                            break;
                        case 8:
                            message.activeMarker = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return LabeledMarker;
            })();

            MotionCapture.Channel = (function() {

                /**
                 * Properties of a Channel.
                 * @memberof message.input.MotionCapture
                 * @interface IChannel
                 * @property {Array.<number>|null} [channel] The changes for this degree of freedom over a given timespan
                 */

                /**
                 * Constructs a new Channel.
                 * @memberof message.input.MotionCapture
                 * @classdesc (DOF)
                 * @implements IChannel
                 * @constructor
                 * @param {message.input.MotionCapture.IChannel=} [properties] Properties to set
                 */
                function Channel(properties) {
                    this.channel = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * The changes for this degree of freedom over a given timespan
                 * @member {Array.<number>} channel
                 * @memberof message.input.MotionCapture.Channel
                 * @instance
                 */
                Channel.prototype.channel = $util.emptyArray;

                /**
                 * Encodes the specified Channel message. Does not implicitly {@link message.input.MotionCapture.Channel.verify|verify} messages.
                 * @function encode
                 * @memberof message.input.MotionCapture.Channel
                 * @static
                 * @param {message.input.MotionCapture.IChannel} message Channel message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Channel.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.channel != null && message.channel.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (let i = 0; i < message.channel.length; ++i)
                            writer.float(message.channel[i]);
                        writer.ldelim();
                    }
                    return writer;
                };

                /**
                 * Decodes a Channel message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.input.MotionCapture.Channel
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.MotionCapture.Channel} Channel
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Channel.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.MotionCapture.Channel();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.channel && message.channel.length))
                                message.channel = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.channel.push(reader.float());
                            } else
                                message.channel.push(reader.float());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return Channel;
            })();

            MotionCapture.ForcePlate = (function() {

                /**
                 * Properties of a ForcePlate.
                 * @memberof message.input.MotionCapture
                 * @interface IForcePlate
                 * @property {number|null} [id] ForcePlate id
                 * @property {Array.<message.input.MotionCapture.IChannel>|null} [channels] change over time
                 */

                /**
                 * Constructs a new ForcePlate.
                 * @memberof message.input.MotionCapture
                 * @classdesc mocap footage
                 * @implements IForcePlate
                 * @constructor
                 * @param {message.input.MotionCapture.IForcePlate=} [properties] Properties to set
                 */
                function ForcePlate(properties) {
                    this.channels = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ForcePlate id.
                 * @member {number} id
                 * @memberof message.input.MotionCapture.ForcePlate
                 * @instance
                 */
                ForcePlate.prototype.id = 0;

                /**
                 * change over time
                 * @member {Array.<message.input.MotionCapture.IChannel>} channels
                 * @memberof message.input.MotionCapture.ForcePlate
                 * @instance
                 */
                ForcePlate.prototype.channels = $util.emptyArray;

                /**
                 * Encodes the specified ForcePlate message. Does not implicitly {@link message.input.MotionCapture.ForcePlate.verify|verify} messages.
                 * @function encode
                 * @memberof message.input.MotionCapture.ForcePlate
                 * @static
                 * @param {message.input.MotionCapture.IForcePlate} message ForcePlate message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ForcePlate.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                    if (message.channels != null && message.channels.length)
                        for (let i = 0; i < message.channels.length; ++i)
                            $root.message.input.MotionCapture.Channel.encode(message.channels[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Decodes a ForcePlate message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.input.MotionCapture.ForcePlate
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.MotionCapture.ForcePlate} ForcePlate
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ForcePlate.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.MotionCapture.ForcePlate();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = reader.uint32();
                            break;
                        case 2:
                            if (!(message.channels && message.channels.length))
                                message.channels = [];
                            message.channels.push($root.message.input.MotionCapture.Channel.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return ForcePlate;
            })();

            MotionCapture.Device = (function() {

                /**
                 * Properties of a Device.
                 * @memberof message.input.MotionCapture
                 * @interface IDevice
                 * @property {number|null} [id] Device id
                 * @property {Array.<message.input.MotionCapture.IChannel>|null} [channels] Device channels
                 */

                /**
                 * Constructs a new Device.
                 * @memberof message.input.MotionCapture
                 * @classdesc Represents a Device.
                 * @implements IDevice
                 * @constructor
                 * @param {message.input.MotionCapture.IDevice=} [properties] Properties to set
                 */
                function Device(properties) {
                    this.channels = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Device id.
                 * @member {number} id
                 * @memberof message.input.MotionCapture.Device
                 * @instance
                 */
                Device.prototype.id = 0;

                /**
                 * Device channels.
                 * @member {Array.<message.input.MotionCapture.IChannel>} channels
                 * @memberof message.input.MotionCapture.Device
                 * @instance
                 */
                Device.prototype.channels = $util.emptyArray;

                /**
                 * Encodes the specified Device message. Does not implicitly {@link message.input.MotionCapture.Device.verify|verify} messages.
                 * @function encode
                 * @memberof message.input.MotionCapture.Device
                 * @static
                 * @param {message.input.MotionCapture.IDevice} message Device message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Device.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                    if (message.channels != null && message.channels.length)
                        for (let i = 0; i < message.channels.length; ++i)
                            $root.message.input.MotionCapture.Channel.encode(message.channels[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Decodes a Device message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.input.MotionCapture.Device
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.MotionCapture.Device} Device
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Device.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.MotionCapture.Device();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = reader.uint32();
                            break;
                        case 2:
                            if (!(message.channels && message.channels.length))
                                message.channels = [];
                            message.channels.push($root.message.input.MotionCapture.Channel.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return Device;
            })();

            return MotionCapture;
        })();

        input.Sensors = (function() {

            /**
             * Properties of a Sensors.
             * @memberof message.input
             * @interface ISensors
             * @property {google.protobuf.ITimestamp|null} [timestamp] When the data were taken/captured
             * @property {Ivec3|null} [accelerometer] => 512 = 0g. Is {x, y, z} acceleration
             * @property {Ivec3|null} [gyroscope] => 512 = 0 degrees per second. Is {x, y, z} angular velocity
             * @property {Imat4|null} [Htw] It measures the world in robot space
             * @property {Array.<message.input.Sensors.IFoot>|null} [feet] Set of force sensitive resistors. Used to sense if a foot is on the ground
             * @property {Array.<message.input.Sensors.IServo>|null} [servo] Sensors servo
             * @property {Array.<message.input.Sensors.IButton>|null} [button] Sensors button
             * @property {Array.<message.input.Sensors.ILED>|null} [led] Sensors led
             * @property {number|null} [voltage] Voltage for the whole robot, from the main battery
             * @property {number|null} [battery] Sensors battery
             * @property {Array.<Imat4>|null} [Htx] A set of transforms; one for each servo
             * @property {Ivec4|null} [rMTt] Torso to Centre of Mass (CoM) in torso space
             * @property {Imat4|null} [Hgt] Sensors Hgt
             * @property {Imat3|null} [inertiaTensor] particle
             */

            /**
             * Constructs a new Sensors.
             * @memberof message.input
             * @classdesc Represents a Sensors.
             * @implements ISensors
             * @constructor
             * @param {message.input.ISensors=} [properties] Properties to set
             */
            function Sensors(properties) {
                this.feet = [];
                this.servo = [];
                this.button = [];
                this.led = [];
                this.Htx = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * When the data were taken/captured
             * @member {google.protobuf.ITimestamp|null|undefined} timestamp
             * @memberof message.input.Sensors
             * @instance
             */
            Sensors.prototype.timestamp = null;

            /**
             * => 512 = 0g. Is {x, y, z} acceleration
             * @member {Ivec3|null|undefined} accelerometer
             * @memberof message.input.Sensors
             * @instance
             */
            Sensors.prototype.accelerometer = null;

            /**
             * => 512 = 0 degrees per second. Is {x, y, z} angular velocity
             * @member {Ivec3|null|undefined} gyroscope
             * @memberof message.input.Sensors
             * @instance
             */
            Sensors.prototype.gyroscope = null;

            /**
             * It measures the world in robot space
             * @member {Imat4|null|undefined} Htw
             * @memberof message.input.Sensors
             * @instance
             */
            Sensors.prototype.Htw = null;

            /**
             * Set of force sensitive resistors. Used to sense if a foot is on the ground
             * @member {Array.<message.input.Sensors.IFoot>} feet
             * @memberof message.input.Sensors
             * @instance
             */
            Sensors.prototype.feet = $util.emptyArray;

            /**
             * Sensors servo.
             * @member {Array.<message.input.Sensors.IServo>} servo
             * @memberof message.input.Sensors
             * @instance
             */
            Sensors.prototype.servo = $util.emptyArray;

            /**
             * Sensors button.
             * @member {Array.<message.input.Sensors.IButton>} button
             * @memberof message.input.Sensors
             * @instance
             */
            Sensors.prototype.button = $util.emptyArray;

            /**
             * Sensors led.
             * @member {Array.<message.input.Sensors.ILED>} led
             * @memberof message.input.Sensors
             * @instance
             */
            Sensors.prototype.led = $util.emptyArray;

            /**
             * Voltage for the whole robot, from the main battery
             * @member {number} voltage
             * @memberof message.input.Sensors
             * @instance
             */
            Sensors.prototype.voltage = 0;

            /**
             * Sensors battery.
             * @member {number} battery
             * @memberof message.input.Sensors
             * @instance
             */
            Sensors.prototype.battery = 0;

            /**
             * A set of transforms; one for each servo
             * @member {Array.<Imat4>} Htx
             * @memberof message.input.Sensors
             * @instance
             */
            Sensors.prototype.Htx = $util.emptyArray;

            /**
             * Torso to Centre of Mass (CoM) in torso space
             * @member {Ivec4|null|undefined} rMTt
             * @memberof message.input.Sensors
             * @instance
             */
            Sensors.prototype.rMTt = null;

            /**
             * Sensors Hgt.
             * @member {Imat4|null|undefined} Hgt
             * @memberof message.input.Sensors
             * @instance
             */
            Sensors.prototype.Hgt = null;

            /**
             * particle
             * @member {Imat3|null|undefined} inertiaTensor
             * @memberof message.input.Sensors
             * @instance
             */
            Sensors.prototype.inertiaTensor = null;

            /**
             * Encodes the specified Sensors message. Does not implicitly {@link message.input.Sensors.verify|verify} messages.
             * @function encode
             * @memberof message.input.Sensors
             * @static
             * @param {message.input.ISensors} message Sensors message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Sensors.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    $root.google.protobuf.Timestamp.encode(message.timestamp, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.accelerometer != null && Object.hasOwnProperty.call(message, "accelerometer"))
                    $root.vec3.encode(message.accelerometer, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.gyroscope != null && Object.hasOwnProperty.call(message, "gyroscope"))
                    $root.vec3.encode(message.gyroscope, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.Htw != null && Object.hasOwnProperty.call(message, "Htw"))
                    $root.mat4.encode(message.Htw, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.feet != null && message.feet.length)
                    for (let i = 0; i < message.feet.length; ++i)
                        $root.message.input.Sensors.Foot.encode(message.feet[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.servo != null && message.servo.length)
                    for (let i = 0; i < message.servo.length; ++i)
                        $root.message.input.Sensors.Servo.encode(message.servo[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.button != null && message.button.length)
                    for (let i = 0; i < message.button.length; ++i)
                        $root.message.input.Sensors.Button.encode(message.button[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.led != null && message.led.length)
                    for (let i = 0; i < message.led.length; ++i)
                        $root.message.input.Sensors.LED.encode(message.led[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.voltage != null && Object.hasOwnProperty.call(message, "voltage"))
                    writer.uint32(/* id 9, wireType 5 =*/77).float(message.voltage);
                if (message.battery != null && Object.hasOwnProperty.call(message, "battery"))
                    writer.uint32(/* id 10, wireType 5 =*/85).float(message.battery);
                if (message.Htx != null && message.Htx.length)
                    for (let i = 0; i < message.Htx.length; ++i)
                        $root.mat4.encode(message.Htx[i], writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                if (message.rMTt != null && Object.hasOwnProperty.call(message, "rMTt"))
                    $root.vec4.encode(message.rMTt, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                if (message.Hgt != null && Object.hasOwnProperty.call(message, "Hgt"))
                    $root.mat4.encode(message.Hgt, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
                if (message.inertiaTensor != null && Object.hasOwnProperty.call(message, "inertiaTensor"))
                    $root.mat3.encode(message.inertiaTensor, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a Sensors message from the specified reader or buffer.
             * @function decode
             * @memberof message.input.Sensors
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.input.Sensors} Sensors
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Sensors.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.Sensors();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.timestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.accelerometer = $root.vec3.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.gyroscope = $root.vec3.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.Htw = $root.mat4.decode(reader, reader.uint32());
                        break;
                    case 5:
                        if (!(message.feet && message.feet.length))
                            message.feet = [];
                        message.feet.push($root.message.input.Sensors.Foot.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.servo && message.servo.length))
                            message.servo = [];
                        message.servo.push($root.message.input.Sensors.Servo.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        if (!(message.button && message.button.length))
                            message.button = [];
                        message.button.push($root.message.input.Sensors.Button.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        if (!(message.led && message.led.length))
                            message.led = [];
                        message.led.push($root.message.input.Sensors.LED.decode(reader, reader.uint32()));
                        break;
                    case 9:
                        message.voltage = reader.float();
                        break;
                    case 10:
                        message.battery = reader.float();
                        break;
                    case 15:
                        if (!(message.Htx && message.Htx.length))
                            message.Htx = [];
                        message.Htx.push($root.mat4.decode(reader, reader.uint32()));
                        break;
                    case 17:
                        message.rMTt = $root.vec4.decode(reader, reader.uint32());
                        break;
                    case 18:
                        message.Hgt = $root.mat4.decode(reader, reader.uint32());
                        break;
                    case 20:
                        message.inertiaTensor = $root.mat3.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            Sensors.Servo = (function() {

                /**
                 * Properties of a Servo.
                 * @memberof message.input.Sensors
                 * @interface IServo
                 * @property {number|null} [errorFlags] https://emanual.robotis.com/docs/en/dxl/mx/mx-106/#alarm-led17-shutdown18
                 * @property {number|null} [id] Servo id
                 * @property {boolean|null} [enabled] Whether the torque is on or off
                 * @property {number|null} [pGain] values are in range 0~254. K_p : p_gain / 8
                 * @property {number|null} [iGain] K_i : i_gain * 1000 / 2048
                 * @property {number|null} [dGain] derivatives. Gain values are in range 0~254. K_d : d_gain * 4 / 1000
                 * @property {number|null} [goalPosition] LED/Shutdown
                 * @property {number|null} [goalVelocity] Servo goalVelocity
                 * @property {number|null} [presentPosition] The range of the value is 0~4095 (0xFFF), and the unit is 0.088 []
                 * @property {number|null} [presentVelocity] direction
                 * @property {number|null} [load] maximum torque
                 * @property {number|null} [voltage] set the address 17 and set 1 to the Bit 0 of the address 18
                 * @property {number|null} [temperature] Data value is identical to the actual temperature in Celsius
                 */

                /**
                 * Constructs a new Servo.
                 * @memberof message.input.Sensors
                 * @classdesc https://emanual.robotis.com/docs/en/dxl/mx/mx-106/
                 * @implements IServo
                 * @constructor
                 * @param {message.input.Sensors.IServo=} [properties] Properties to set
                 */
                function Servo(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * https://emanual.robotis.com/docs/en/dxl/mx/mx-106/#alarm-led17-shutdown18
                 * @member {number} errorFlags
                 * @memberof message.input.Sensors.Servo
                 * @instance
                 */
                Servo.prototype.errorFlags = 0;

                /**
                 * Servo id.
                 * @member {number} id
                 * @memberof message.input.Sensors.Servo
                 * @instance
                 */
                Servo.prototype.id = 0;

                /**
                 * Whether the torque is on or off
                 * @member {boolean} enabled
                 * @memberof message.input.Sensors.Servo
                 * @instance
                 */
                Servo.prototype.enabled = false;

                /**
                 * values are in range 0~254. K_p : p_gain / 8
                 * @member {number} pGain
                 * @memberof message.input.Sensors.Servo
                 * @instance
                 */
                Servo.prototype.pGain = 0;

                /**
                 * K_i : i_gain * 1000 / 2048
                 * @member {number} iGain
                 * @memberof message.input.Sensors.Servo
                 * @instance
                 */
                Servo.prototype.iGain = 0;

                /**
                 * derivatives. Gain values are in range 0~254. K_d : d_gain * 4 / 1000
                 * @member {number} dGain
                 * @memberof message.input.Sensors.Servo
                 * @instance
                 */
                Servo.prototype.dGain = 0;

                /**
                 * LED/Shutdown
                 * @member {number} goalPosition
                 * @memberof message.input.Sensors.Servo
                 * @instance
                 */
                Servo.prototype.goalPosition = 0;

                /**
                 * Servo goalVelocity.
                 * @member {number} goalVelocity
                 * @memberof message.input.Sensors.Servo
                 * @instance
                 */
                Servo.prototype.goalVelocity = 0;

                /**
                 * The range of the value is 0~4095 (0xFFF), and the unit is 0.088 []
                 * @member {number} presentPosition
                 * @memberof message.input.Sensors.Servo
                 * @instance
                 */
                Servo.prototype.presentPosition = 0;

                /**
                 * direction
                 * @member {number} presentVelocity
                 * @memberof message.input.Sensors.Servo
                 * @instance
                 */
                Servo.prototype.presentVelocity = 0;

                /**
                 * maximum torque
                 * @member {number} load
                 * @memberof message.input.Sensors.Servo
                 * @instance
                 */
                Servo.prototype.load = 0;

                /**
                 * set the address 17 and set 1 to the Bit 0 of the address 18
                 * @member {number} voltage
                 * @memberof message.input.Sensors.Servo
                 * @instance
                 */
                Servo.prototype.voltage = 0;

                /**
                 * Data value is identical to the actual temperature in Celsius
                 * @member {number} temperature
                 * @memberof message.input.Sensors.Servo
                 * @instance
                 */
                Servo.prototype.temperature = 0;

                /**
                 * Encodes the specified Servo message. Does not implicitly {@link message.input.Sensors.Servo.verify|verify} messages.
                 * @function encode
                 * @memberof message.input.Sensors.Servo
                 * @static
                 * @param {message.input.Sensors.IServo} message Servo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Servo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.errorFlags != null && Object.hasOwnProperty.call(message, "errorFlags"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.errorFlags);
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.id);
                    if (message.enabled != null && Object.hasOwnProperty.call(message, "enabled"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.enabled);
                    if (message.pGain != null && Object.hasOwnProperty.call(message, "pGain"))
                        writer.uint32(/* id 4, wireType 5 =*/37).float(message.pGain);
                    if (message.iGain != null && Object.hasOwnProperty.call(message, "iGain"))
                        writer.uint32(/* id 5, wireType 5 =*/45).float(message.iGain);
                    if (message.dGain != null && Object.hasOwnProperty.call(message, "dGain"))
                        writer.uint32(/* id 6, wireType 5 =*/53).float(message.dGain);
                    if (message.goalPosition != null && Object.hasOwnProperty.call(message, "goalPosition"))
                        writer.uint32(/* id 7, wireType 5 =*/61).float(message.goalPosition);
                    if (message.goalVelocity != null && Object.hasOwnProperty.call(message, "goalVelocity"))
                        writer.uint32(/* id 8, wireType 5 =*/69).float(message.goalVelocity);
                    if (message.presentPosition != null && Object.hasOwnProperty.call(message, "presentPosition"))
                        writer.uint32(/* id 9, wireType 5 =*/77).float(message.presentPosition);
                    if (message.presentVelocity != null && Object.hasOwnProperty.call(message, "presentVelocity"))
                        writer.uint32(/* id 10, wireType 5 =*/85).float(message.presentVelocity);
                    if (message.load != null && Object.hasOwnProperty.call(message, "load"))
                        writer.uint32(/* id 11, wireType 5 =*/93).float(message.load);
                    if (message.voltage != null && Object.hasOwnProperty.call(message, "voltage"))
                        writer.uint32(/* id 12, wireType 5 =*/101).float(message.voltage);
                    if (message.temperature != null && Object.hasOwnProperty.call(message, "temperature"))
                        writer.uint32(/* id 13, wireType 5 =*/109).float(message.temperature);
                    return writer;
                };

                /**
                 * Decodes a Servo message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.input.Sensors.Servo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.Sensors.Servo} Servo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Servo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.Sensors.Servo();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.errorFlags = reader.uint32();
                            break;
                        case 2:
                            message.id = reader.uint32();
                            break;
                        case 3:
                            message.enabled = reader.bool();
                            break;
                        case 4:
                            message.pGain = reader.float();
                            break;
                        case 5:
                            message.iGain = reader.float();
                            break;
                        case 6:
                            message.dGain = reader.float();
                            break;
                        case 7:
                            message.goalPosition = reader.float();
                            break;
                        case 8:
                            message.goalVelocity = reader.float();
                            break;
                        case 9:
                            message.presentPosition = reader.float();
                            break;
                        case 10:
                            message.presentVelocity = reader.float();
                            break;
                        case 11:
                            message.load = reader.float();
                            break;
                        case 12:
                            message.voltage = reader.float();
                            break;
                        case 13:
                            message.temperature = reader.float();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return Servo;
            })();

            Sensors.Button = (function() {

                /**
                 * Properties of a Button.
                 * @memberof message.input.Sensors
                 * @interface IButton
                 * @property {number|null} [id] Button id
                 * @property {boolean|null} [value] True is pressed, false is unpressed
                 */

                /**
                 * Constructs a new Button.
                 * @memberof message.input.Sensors
                 * @classdesc Represents a Button.
                 * @implements IButton
                 * @constructor
                 * @param {message.input.Sensors.IButton=} [properties] Properties to set
                 */
                function Button(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Button id.
                 * @member {number} id
                 * @memberof message.input.Sensors.Button
                 * @instance
                 */
                Button.prototype.id = 0;

                /**
                 * True is pressed, false is unpressed
                 * @member {boolean} value
                 * @memberof message.input.Sensors.Button
                 * @instance
                 */
                Button.prototype.value = false;

                /**
                 * Encodes the specified Button message. Does not implicitly {@link message.input.Sensors.Button.verify|verify} messages.
                 * @function encode
                 * @memberof message.input.Sensors.Button
                 * @static
                 * @param {message.input.Sensors.IButton} message Button message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Button.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.value);
                    return writer;
                };

                /**
                 * Decodes a Button message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.input.Sensors.Button
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.Sensors.Button} Button
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Button.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.Sensors.Button();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = reader.uint32();
                            break;
                        case 2:
                            message.value = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return Button;
            })();

            Sensors.LED = (function() {

                /**
                 * Properties of a LED.
                 * @memberof message.input.Sensors
                 * @interface ILED
                 * @property {number|null} [id] LED id
                 * @property {number|null} [colour] LED colour
                 */

                /**
                 * Constructs a new LED.
                 * @memberof message.input.Sensors
                 * @classdesc Represents a LED.
                 * @implements ILED
                 * @constructor
                 * @param {message.input.Sensors.ILED=} [properties] Properties to set
                 */
                function LED(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * LED id.
                 * @member {number} id
                 * @memberof message.input.Sensors.LED
                 * @instance
                 */
                LED.prototype.id = 0;

                /**
                 * LED colour.
                 * @member {number} colour
                 * @memberof message.input.Sensors.LED
                 * @instance
                 */
                LED.prototype.colour = 0;

                /**
                 * Encodes the specified LED message. Does not implicitly {@link message.input.Sensors.LED.verify|verify} messages.
                 * @function encode
                 * @memberof message.input.Sensors.LED
                 * @static
                 * @param {message.input.Sensors.ILED} message LED message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LED.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                    if (message.colour != null && Object.hasOwnProperty.call(message, "colour"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.colour);
                    return writer;
                };

                /**
                 * Decodes a LED message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.input.Sensors.LED
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.Sensors.LED} LED
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LED.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.Sensors.LED();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = reader.uint32();
                            break;
                        case 2:
                            message.colour = reader.uint32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return LED;
            })();

            Sensors.Foot = (function() {

                /**
                 * Properties of a Foot.
                 * @memberof message.input.Sensors
                 * @interface IFoot
                 * @property {boolean|null} [down] Foot down
                 * @property {Imat4|null} [Hwf] Foot Hwf
                 */

                /**
                 * Constructs a new Foot.
                 * @memberof message.input.Sensors
                 * @classdesc Represents a Foot.
                 * @implements IFoot
                 * @constructor
                 * @param {message.input.Sensors.IFoot=} [properties] Properties to set
                 */
                function Foot(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Foot down.
                 * @member {boolean} down
                 * @memberof message.input.Sensors.Foot
                 * @instance
                 */
                Foot.prototype.down = false;

                /**
                 * Foot Hwf.
                 * @member {Imat4|null|undefined} Hwf
                 * @memberof message.input.Sensors.Foot
                 * @instance
                 */
                Foot.prototype.Hwf = null;

                /**
                 * Encodes the specified Foot message. Does not implicitly {@link message.input.Sensors.Foot.verify|verify} messages.
                 * @function encode
                 * @memberof message.input.Sensors.Foot
                 * @static
                 * @param {message.input.Sensors.IFoot} message Foot message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Foot.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.down != null && Object.hasOwnProperty.call(message, "down"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.down);
                    if (message.Hwf != null && Object.hasOwnProperty.call(message, "Hwf"))
                        $root.mat4.encode(message.Hwf, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Decodes a Foot message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.input.Sensors.Foot
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.Sensors.Foot} Foot
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Foot.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.Sensors.Foot();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.down = reader.bool();
                            break;
                        case 2:
                            message.Hwf = $root.mat4.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return Foot;
            })();

            return Sensors;
        })();

        return input;
    })();

    message.localisation = (function() {

        /**
         * Namespace localisation.
         * @memberof message
         * @namespace
         */
        const localisation = {};

        localisation.Ball = (function() {

            /**
             * Properties of a Ball.
             * @memberof message.localisation
             * @interface IBall
             * @property {Ivec2|null} [position] The ball's position measured in world space (rBWw)
             * @property {Imat2|null} [covariance] Ball covariance
             */

            /**
             * Constructs a new Ball.
             * @memberof message.localisation
             * @classdesc Represents a Ball.
             * @implements IBall
             * @constructor
             * @param {message.localisation.IBall=} [properties] Properties to set
             */
            function Ball(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * The ball's position measured in world space (rBWw)
             * @member {Ivec2|null|undefined} position
             * @memberof message.localisation.Ball
             * @instance
             */
            Ball.prototype.position = null;

            /**
             * Ball covariance.
             * @member {Imat2|null|undefined} covariance
             * @memberof message.localisation.Ball
             * @instance
             */
            Ball.prototype.covariance = null;

            /**
             * Encodes the specified Ball message. Does not implicitly {@link message.localisation.Ball.verify|verify} messages.
             * @function encode
             * @memberof message.localisation.Ball
             * @static
             * @param {message.localisation.IBall} message Ball message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Ball.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                    $root.vec2.encode(message.position, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.covariance != null && Object.hasOwnProperty.call(message, "covariance"))
                    $root.mat2.encode(message.covariance, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a Ball message from the specified reader or buffer.
             * @function decode
             * @memberof message.localisation.Ball
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.localisation.Ball} Ball
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Ball.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.localisation.Ball();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.position = $root.vec2.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.covariance = $root.mat2.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return Ball;
        })();

        localisation.Field = (function() {

            /**
             * Properties of a Field.
             * @memberof message.localisation
             * @interface IField
             * @property {Imat3|null} [position] Isometry2d position transform
             * @property {Imat3|null} [covariance] Covariance of (x, y, theta)
             */

            /**
             * Constructs a new Field.
             * @memberof message.localisation
             * @classdesc Represents a Field.
             * @implements IField
             * @constructor
             * @param {message.localisation.IField=} [properties] Properties to set
             */
            function Field(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Isometry2d position transform
             * @member {Imat3|null|undefined} position
             * @memberof message.localisation.Field
             * @instance
             */
            Field.prototype.position = null;

            /**
             * Covariance of (x, y, theta)
             * @member {Imat3|null|undefined} covariance
             * @memberof message.localisation.Field
             * @instance
             */
            Field.prototype.covariance = null;

            /**
             * Encodes the specified Field message. Does not implicitly {@link message.localisation.Field.verify|verify} messages.
             * @function encode
             * @memberof message.localisation.Field
             * @static
             * @param {message.localisation.IField} message Field message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Field.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                    $root.mat3.encode(message.position, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.covariance != null && Object.hasOwnProperty.call(message, "covariance"))
                    $root.mat3.encode(message.covariance, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a Field message from the specified reader or buffer.
             * @function decode
             * @memberof message.localisation.Field
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.localisation.Field} Field
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Field.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.localisation.Field();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.position = $root.mat3.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.covariance = $root.mat3.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return Field;
        })();

        localisation.FilteredBall = (function() {

            /**
             * Properties of a FilteredBall.
             * @memberof message.localisation
             * @interface IFilteredBall
             * @property {Ifvec3|null} [rBTt] Ball's filtered cartesian position measured in torso space {t} from the torso {T}
             * @property {Ifvec3|null} [rBCc] Ball's filtered cartesian position measured in camera space {c} from the camera {C}
             * @property {Ifvec3|null} [rBCt] Ball's filtered cartesian position measured in torso space {t} from the camera {C}
             * @property {google.protobuf.ITimestamp|null} [timeOfMeasurement] Time the ball measurement was taken
             */

            /**
             * Constructs a new FilteredBall.
             * @memberof message.localisation
             * @classdesc Represents a FilteredBall.
             * @implements IFilteredBall
             * @constructor
             * @param {message.localisation.IFilteredBall=} [properties] Properties to set
             */
            function FilteredBall(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Ball's filtered cartesian position measured in torso space {t} from the torso {T}
             * @member {Ifvec3|null|undefined} rBTt
             * @memberof message.localisation.FilteredBall
             * @instance
             */
            FilteredBall.prototype.rBTt = null;

            /**
             * Ball's filtered cartesian position measured in camera space {c} from the camera {C}
             * @member {Ifvec3|null|undefined} rBCc
             * @memberof message.localisation.FilteredBall
             * @instance
             */
            FilteredBall.prototype.rBCc = null;

            /**
             * Ball's filtered cartesian position measured in torso space {t} from the camera {C}
             * @member {Ifvec3|null|undefined} rBCt
             * @memberof message.localisation.FilteredBall
             * @instance
             */
            FilteredBall.prototype.rBCt = null;

            /**
             * Time the ball measurement was taken
             * @member {google.protobuf.ITimestamp|null|undefined} timeOfMeasurement
             * @memberof message.localisation.FilteredBall
             * @instance
             */
            FilteredBall.prototype.timeOfMeasurement = null;

            /**
             * Encodes the specified FilteredBall message. Does not implicitly {@link message.localisation.FilteredBall.verify|verify} messages.
             * @function encode
             * @memberof message.localisation.FilteredBall
             * @static
             * @param {message.localisation.IFilteredBall} message FilteredBall message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FilteredBall.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.rBTt != null && Object.hasOwnProperty.call(message, "rBTt"))
                    $root.fvec3.encode(message.rBTt, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.rBCc != null && Object.hasOwnProperty.call(message, "rBCc"))
                    $root.fvec3.encode(message.rBCc, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.rBCt != null && Object.hasOwnProperty.call(message, "rBCt"))
                    $root.fvec3.encode(message.rBCt, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.timeOfMeasurement != null && Object.hasOwnProperty.call(message, "timeOfMeasurement"))
                    $root.google.protobuf.Timestamp.encode(message.timeOfMeasurement, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a FilteredBall message from the specified reader or buffer.
             * @function decode
             * @memberof message.localisation.FilteredBall
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.localisation.FilteredBall} FilteredBall
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FilteredBall.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.localisation.FilteredBall();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.rBTt = $root.fvec3.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.rBCc = $root.fvec3.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.rBCt = $root.fvec3.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.timeOfMeasurement = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return FilteredBall;
        })();

        localisation.ResetBallHypotheses = (function() {

            /**
             * Properties of a ResetBallHypotheses.
             * @memberof message.localisation
             * @interface IResetBallHypotheses
             * @property {Array.<message.localisation.ResetBallHypotheses.IBall>|null} [hypotheses] ResetBallHypotheses hypotheses
             * @property {boolean|null} [selfReset] ResetBallHypotheses selfReset
             */

            /**
             * Constructs a new ResetBallHypotheses.
             * @memberof message.localisation
             * @classdesc Represents a ResetBallHypotheses.
             * @implements IResetBallHypotheses
             * @constructor
             * @param {message.localisation.IResetBallHypotheses=} [properties] Properties to set
             */
            function ResetBallHypotheses(properties) {
                this.hypotheses = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ResetBallHypotheses hypotheses.
             * @member {Array.<message.localisation.ResetBallHypotheses.IBall>} hypotheses
             * @memberof message.localisation.ResetBallHypotheses
             * @instance
             */
            ResetBallHypotheses.prototype.hypotheses = $util.emptyArray;

            /**
             * ResetBallHypotheses selfReset.
             * @member {boolean} selfReset
             * @memberof message.localisation.ResetBallHypotheses
             * @instance
             */
            ResetBallHypotheses.prototype.selfReset = false;

            /**
             * Encodes the specified ResetBallHypotheses message. Does not implicitly {@link message.localisation.ResetBallHypotheses.verify|verify} messages.
             * @function encode
             * @memberof message.localisation.ResetBallHypotheses
             * @static
             * @param {message.localisation.IResetBallHypotheses} message ResetBallHypotheses message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ResetBallHypotheses.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.hypotheses != null && message.hypotheses.length)
                    for (let i = 0; i < message.hypotheses.length; ++i)
                        $root.message.localisation.ResetBallHypotheses.Ball.encode(message.hypotheses[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.selfReset != null && Object.hasOwnProperty.call(message, "selfReset"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.selfReset);
                return writer;
            };

            /**
             * Decodes a ResetBallHypotheses message from the specified reader or buffer.
             * @function decode
             * @memberof message.localisation.ResetBallHypotheses
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.localisation.ResetBallHypotheses} ResetBallHypotheses
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ResetBallHypotheses.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.localisation.ResetBallHypotheses();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.hypotheses && message.hypotheses.length))
                            message.hypotheses = [];
                        message.hypotheses.push($root.message.localisation.ResetBallHypotheses.Ball.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        message.selfReset = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            ResetBallHypotheses.Ball = (function() {

                /**
                 * Properties of a Ball.
                 * @memberof message.localisation.ResetBallHypotheses
                 * @interface IBall
                 * @property {Ivec2|null} [rBWw] Estimate of the balls position in world space
                 * @property {Imat2|null} [covariance] Ball covariance
                 */

                /**
                 * Constructs a new Ball.
                 * @memberof message.localisation.ResetBallHypotheses
                 * @classdesc Represents a Ball.
                 * @implements IBall
                 * @constructor
                 * @param {message.localisation.ResetBallHypotheses.IBall=} [properties] Properties to set
                 */
                function Ball(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Estimate of the balls position in world space
                 * @member {Ivec2|null|undefined} rBWw
                 * @memberof message.localisation.ResetBallHypotheses.Ball
                 * @instance
                 */
                Ball.prototype.rBWw = null;

                /**
                 * Ball covariance.
                 * @member {Imat2|null|undefined} covariance
                 * @memberof message.localisation.ResetBallHypotheses.Ball
                 * @instance
                 */
                Ball.prototype.covariance = null;

                /**
                 * Encodes the specified Ball message. Does not implicitly {@link message.localisation.ResetBallHypotheses.Ball.verify|verify} messages.
                 * @function encode
                 * @memberof message.localisation.ResetBallHypotheses.Ball
                 * @static
                 * @param {message.localisation.ResetBallHypotheses.IBall} message Ball message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Ball.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.rBWw != null && Object.hasOwnProperty.call(message, "rBWw"))
                        $root.vec2.encode(message.rBWw, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.covariance != null && Object.hasOwnProperty.call(message, "covariance"))
                        $root.mat2.encode(message.covariance, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Decodes a Ball message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.localisation.ResetBallHypotheses.Ball
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.localisation.ResetBallHypotheses.Ball} Ball
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Ball.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.localisation.ResetBallHypotheses.Ball();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.rBWw = $root.vec2.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.covariance = $root.mat2.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return Ball;
            })();

            return ResetBallHypotheses;
        })();

        localisation.ResetRobotHypotheses = (function() {

            /**
             * Properties of a ResetRobotHypotheses.
             * @memberof message.localisation
             * @interface IResetRobotHypotheses
             * @property {Array.<message.localisation.ResetRobotHypotheses.ISelf>|null} [hypotheses] ResetRobotHypotheses hypotheses
             */

            /**
             * Constructs a new ResetRobotHypotheses.
             * @memberof message.localisation
             * @classdesc Represents a ResetRobotHypotheses.
             * @implements IResetRobotHypotheses
             * @constructor
             * @param {message.localisation.IResetRobotHypotheses=} [properties] Properties to set
             */
            function ResetRobotHypotheses(properties) {
                this.hypotheses = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ResetRobotHypotheses hypotheses.
             * @member {Array.<message.localisation.ResetRobotHypotheses.ISelf>} hypotheses
             * @memberof message.localisation.ResetRobotHypotheses
             * @instance
             */
            ResetRobotHypotheses.prototype.hypotheses = $util.emptyArray;

            /**
             * Encodes the specified ResetRobotHypotheses message. Does not implicitly {@link message.localisation.ResetRobotHypotheses.verify|verify} messages.
             * @function encode
             * @memberof message.localisation.ResetRobotHypotheses
             * @static
             * @param {message.localisation.IResetRobotHypotheses} message ResetRobotHypotheses message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ResetRobotHypotheses.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.hypotheses != null && message.hypotheses.length)
                    for (let i = 0; i < message.hypotheses.length; ++i)
                        $root.message.localisation.ResetRobotHypotheses.Self.encode(message.hypotheses[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a ResetRobotHypotheses message from the specified reader or buffer.
             * @function decode
             * @memberof message.localisation.ResetRobotHypotheses
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.localisation.ResetRobotHypotheses} ResetRobotHypotheses
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ResetRobotHypotheses.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.localisation.ResetRobotHypotheses();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.hypotheses && message.hypotheses.length))
                            message.hypotheses = [];
                        message.hypotheses.push($root.message.localisation.ResetRobotHypotheses.Self.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            ResetRobotHypotheses.Self = (function() {

                /**
                 * Properties of a Self.
                 * @memberof message.localisation.ResetRobotHypotheses
                 * @interface ISelf
                 * @property {Ivec2|null} [rTFf] Estimate of the robot's {x, y} position in field space
                 * @property {Imat2|null} [covariance] Self covariance
                 * @property {number|null} [heading] Self heading
                 * @property {number|null} [headingVar] Self headingVar
                 * @property {boolean|null} [absoluteYaw] Self absoluteYaw
                 */

                /**
                 * Constructs a new Self.
                 * @memberof message.localisation.ResetRobotHypotheses
                 * @classdesc Represents a Self.
                 * @implements ISelf
                 * @constructor
                 * @param {message.localisation.ResetRobotHypotheses.ISelf=} [properties] Properties to set
                 */
                function Self(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Estimate of the robot's {x, y} position in field space
                 * @member {Ivec2|null|undefined} rTFf
                 * @memberof message.localisation.ResetRobotHypotheses.Self
                 * @instance
                 */
                Self.prototype.rTFf = null;

                /**
                 * Self covariance.
                 * @member {Imat2|null|undefined} covariance
                 * @memberof message.localisation.ResetRobotHypotheses.Self
                 * @instance
                 */
                Self.prototype.covariance = null;

                /**
                 * Self heading.
                 * @member {number} heading
                 * @memberof message.localisation.ResetRobotHypotheses.Self
                 * @instance
                 */
                Self.prototype.heading = 0;

                /**
                 * Self headingVar.
                 * @member {number} headingVar
                 * @memberof message.localisation.ResetRobotHypotheses.Self
                 * @instance
                 */
                Self.prototype.headingVar = 0;

                /**
                 * Self absoluteYaw.
                 * @member {boolean} absoluteYaw
                 * @memberof message.localisation.ResetRobotHypotheses.Self
                 * @instance
                 */
                Self.prototype.absoluteYaw = false;

                /**
                 * Encodes the specified Self message. Does not implicitly {@link message.localisation.ResetRobotHypotheses.Self.verify|verify} messages.
                 * @function encode
                 * @memberof message.localisation.ResetRobotHypotheses.Self
                 * @static
                 * @param {message.localisation.ResetRobotHypotheses.ISelf} message Self message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Self.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.rTFf != null && Object.hasOwnProperty.call(message, "rTFf"))
                        $root.vec2.encode(message.rTFf, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.covariance != null && Object.hasOwnProperty.call(message, "covariance"))
                        $root.mat2.encode(message.covariance, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.heading != null && Object.hasOwnProperty.call(message, "heading"))
                        writer.uint32(/* id 3, wireType 1 =*/25).double(message.heading);
                    if (message.headingVar != null && Object.hasOwnProperty.call(message, "headingVar"))
                        writer.uint32(/* id 4, wireType 1 =*/33).double(message.headingVar);
                    if (message.absoluteYaw != null && Object.hasOwnProperty.call(message, "absoluteYaw"))
                        writer.uint32(/* id 5, wireType 0 =*/40).bool(message.absoluteYaw);
                    return writer;
                };

                /**
                 * Decodes a Self message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.localisation.ResetRobotHypotheses.Self
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.localisation.ResetRobotHypotheses.Self} Self
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Self.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.localisation.ResetRobotHypotheses.Self();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.rTFf = $root.vec2.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.covariance = $root.mat2.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.heading = reader.double();
                            break;
                        case 4:
                            message.headingVar = reader.double();
                            break;
                        case 5:
                            message.absoluteYaw = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return Self;
            })();

            return ResetRobotHypotheses;
        })();

        return localisation;
    })();

    message.motion = (function() {

        /**
         * Namespace motion.
         * @memberof message
         * @namespace
         */
        const motion = {};

        motion.ExecuteGetup = (function() {

            /**
             * Properties of an ExecuteGetup.
             * @memberof message.motion
             * @interface IExecuteGetup
             */

            /**
             * Constructs a new ExecuteGetup.
             * @memberof message.motion
             * @classdesc Represents an ExecuteGetup.
             * @implements IExecuteGetup
             * @constructor
             * @param {message.motion.IExecuteGetup=} [properties] Properties to set
             */
            function ExecuteGetup(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Encodes the specified ExecuteGetup message. Does not implicitly {@link message.motion.ExecuteGetup.verify|verify} messages.
             * @function encode
             * @memberof message.motion.ExecuteGetup
             * @static
             * @param {message.motion.IExecuteGetup} message ExecuteGetup message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecuteGetup.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Decodes an ExecuteGetup message from the specified reader or buffer.
             * @function decode
             * @memberof message.motion.ExecuteGetup
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.ExecuteGetup} ExecuteGetup
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecuteGetup.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.motion.ExecuteGetup();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return ExecuteGetup;
        })();

        motion.KillGetup = (function() {

            /**
             * Properties of a KillGetup.
             * @memberof message.motion
             * @interface IKillGetup
             */

            /**
             * Constructs a new KillGetup.
             * @memberof message.motion
             * @classdesc Represents a KillGetup.
             * @implements IKillGetup
             * @constructor
             * @param {message.motion.IKillGetup=} [properties] Properties to set
             */
            function KillGetup(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Encodes the specified KillGetup message. Does not implicitly {@link message.motion.KillGetup.verify|verify} messages.
             * @function encode
             * @memberof message.motion.KillGetup
             * @static
             * @param {message.motion.IKillGetup} message KillGetup message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KillGetup.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Decodes a KillGetup message from the specified reader or buffer.
             * @function decode
             * @memberof message.motion.KillGetup
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.KillGetup} KillGetup
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KillGetup.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.motion.KillGetup();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return KillGetup;
        })();

        motion.HeadCommand = (function() {

            /**
             * Properties of a HeadCommand.
             * @memberof message.motion
             * @interface IHeadCommand
             * @property {number|null} [yaw] Target head yaw in radians
             * @property {number|null} [pitch] Target head pitch in radians
             * @property {boolean|null} [robotSpace] If true, the yaw and pitch are interpreted in robot space, instead of IMU space
             * @property {boolean|null} [smooth] If true, smooth the goal angle using expoential smoothing
             */

            /**
             * Constructs a new HeadCommand.
             * @memberof message.motion
             * @classdesc Tell the head where to look in world space.
             * This command is interpreted such that the robot will use IMU data to fixate
             * at these angles in the world even when rotating.
             * 
             * @author Jade Fountain
             * @implements IHeadCommand
             * @constructor
             * @param {message.motion.IHeadCommand=} [properties] Properties to set
             */
            function HeadCommand(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Target head yaw in radians
             * @member {number} yaw
             * @memberof message.motion.HeadCommand
             * @instance
             */
            HeadCommand.prototype.yaw = 0;

            /**
             * Target head pitch in radians
             * @member {number} pitch
             * @memberof message.motion.HeadCommand
             * @instance
             */
            HeadCommand.prototype.pitch = 0;

            /**
             * If true, the yaw and pitch are interpreted in robot space, instead of IMU space
             * @member {boolean} robotSpace
             * @memberof message.motion.HeadCommand
             * @instance
             */
            HeadCommand.prototype.robotSpace = false;

            /**
             * If true, smooth the goal angle using expoential smoothing
             * @member {boolean} smooth
             * @memberof message.motion.HeadCommand
             * @instance
             */
            HeadCommand.prototype.smooth = false;

            /**
             * Encodes the specified HeadCommand message. Does not implicitly {@link message.motion.HeadCommand.verify|verify} messages.
             * @function encode
             * @memberof message.motion.HeadCommand
             * @static
             * @param {message.motion.IHeadCommand} message HeadCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HeadCommand.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.yaw != null && Object.hasOwnProperty.call(message, "yaw"))
                    writer.uint32(/* id 1, wireType 5 =*/13).float(message.yaw);
                if (message.pitch != null && Object.hasOwnProperty.call(message, "pitch"))
                    writer.uint32(/* id 2, wireType 5 =*/21).float(message.pitch);
                if (message.robotSpace != null && Object.hasOwnProperty.call(message, "robotSpace"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.robotSpace);
                if (message.smooth != null && Object.hasOwnProperty.call(message, "smooth"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.smooth);
                return writer;
            };

            /**
             * Decodes a HeadCommand message from the specified reader or buffer.
             * @function decode
             * @memberof message.motion.HeadCommand
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.HeadCommand} HeadCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HeadCommand.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.motion.HeadCommand();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.yaw = reader.float();
                        break;
                    case 2:
                        message.pitch = reader.float();
                        break;
                    case 3:
                        message.robotSpace = reader.bool();
                        break;
                    case 4:
                        message.smooth = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return HeadCommand;
        })();

        /**
         * @author Trent Houliston
         * @author Brendan Annable
         * @name message.motion.KickCommandType
         * @enum {number}
         * @property {number} NORMAL=0 NORMAL value
         * @property {number} PENALTY=1 PENALTY value
         */
        motion.KickCommandType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "NORMAL"] = 0;
            values[valuesById[1] = "PENALTY"] = 1;
            return values;
        })();

        motion.KickCommand = (function() {

            /**
             * Properties of a KickCommand.
             * @memberof message.motion
             * @interface IKickCommand
             * @property {Ivec3|null} [target] The point to kick
             * @property {Ivec3|null} [direction] corresponding to the force of the kick
             * @property {message.motion.KickCommandType|null} [kickCommandType] KickCommand kickCommandType
             */

            /**
             * Constructs a new KickCommand.
             * @memberof message.motion
             * @classdesc Represents a KickCommand.
             * @implements IKickCommand
             * @constructor
             * @param {message.motion.IKickCommand=} [properties] Properties to set
             */
            function KickCommand(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * The point to kick
             * @member {Ivec3|null|undefined} target
             * @memberof message.motion.KickCommand
             * @instance
             */
            KickCommand.prototype.target = null;

            /**
             * corresponding to the force of the kick
             * @member {Ivec3|null|undefined} direction
             * @memberof message.motion.KickCommand
             * @instance
             */
            KickCommand.prototype.direction = null;

            /**
             * KickCommand kickCommandType.
             * @member {message.motion.KickCommandType} kickCommandType
             * @memberof message.motion.KickCommand
             * @instance
             */
            KickCommand.prototype.kickCommandType = 0;

            /**
             * Encodes the specified KickCommand message. Does not implicitly {@link message.motion.KickCommand.verify|verify} messages.
             * @function encode
             * @memberof message.motion.KickCommand
             * @static
             * @param {message.motion.IKickCommand} message KickCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KickCommand.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                    $root.vec3.encode(message.target, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.direction != null && Object.hasOwnProperty.call(message, "direction"))
                    $root.vec3.encode(message.direction, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.kickCommandType != null && Object.hasOwnProperty.call(message, "kickCommandType"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.kickCommandType);
                return writer;
            };

            /**
             * Decodes a KickCommand message from the specified reader or buffer.
             * @function decode
             * @memberof message.motion.KickCommand
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.KickCommand} KickCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KickCommand.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.motion.KickCommand();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.target = $root.vec3.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.direction = $root.vec3.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.kickCommandType = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return KickCommand;
        })();

        motion.KickScriptCommand = (function() {

            /**
             * Properties of a KickScriptCommand.
             * @memberof message.motion
             * @interface IKickScriptCommand
             * @property {number|null} [leg] Leg to kick with
             * @property {message.motion.KickCommandType|null} [type] KickScriptCommand type
             */

            /**
             * Constructs a new KickScriptCommand.
             * @memberof message.motion
             * @classdesc @author Trent Houliston
             * @author Brendan Annable
             * @implements IKickScriptCommand
             * @constructor
             * @param {message.motion.IKickScriptCommand=} [properties] Properties to set
             */
            function KickScriptCommand(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Leg to kick with
             * @member {number} leg
             * @memberof message.motion.KickScriptCommand
             * @instance
             */
            KickScriptCommand.prototype.leg = 0;

            /**
             * KickScriptCommand type.
             * @member {message.motion.KickCommandType} type
             * @memberof message.motion.KickScriptCommand
             * @instance
             */
            KickScriptCommand.prototype.type = 0;

            /**
             * Encodes the specified KickScriptCommand message. Does not implicitly {@link message.motion.KickScriptCommand.verify|verify} messages.
             * @function encode
             * @memberof message.motion.KickScriptCommand
             * @static
             * @param {message.motion.IKickScriptCommand} message KickScriptCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KickScriptCommand.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.leg != null && Object.hasOwnProperty.call(message, "leg"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.leg);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
                return writer;
            };

            /**
             * Decodes a KickScriptCommand message from the specified reader or buffer.
             * @function decode
             * @memberof message.motion.KickScriptCommand
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.KickScriptCommand} KickScriptCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KickScriptCommand.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.motion.KickScriptCommand();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.leg = reader.uint32();
                        break;
                    case 2:
                        message.type = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return KickScriptCommand;
        })();

        motion.KickFinished = (function() {

            /**
             * Properties of a KickFinished.
             * @memberof message.motion
             * @interface IKickFinished
             */

            /**
             * Constructs a new KickFinished.
             * @memberof message.motion
             * @classdesc Represents a KickFinished.
             * @implements IKickFinished
             * @constructor
             * @param {message.motion.IKickFinished=} [properties] Properties to set
             */
            function KickFinished(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Encodes the specified KickFinished message. Does not implicitly {@link message.motion.KickFinished.verify|verify} messages.
             * @function encode
             * @memberof message.motion.KickFinished
             * @static
             * @param {message.motion.IKickFinished} message KickFinished message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KickFinished.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Decodes a KickFinished message from the specified reader or buffer.
             * @function decode
             * @memberof message.motion.KickFinished
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.KickFinished} KickFinished
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KickFinished.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.motion.KickFinished();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return KickFinished;
        })();

        motion.IKKickParams = (function() {

            /**
             * Properties of a IKKickParams.
             * @memberof message.motion
             * @interface IIKKickParams
             * @property {number|null} [standHeight] IKKickParams standHeight
             */

            /**
             * Constructs a new IKKickParams.
             * @memberof message.motion
             * @classdesc Represents a IKKickParams.
             * @implements IIKKickParams
             * @constructor
             * @param {message.motion.IIKKickParams=} [properties] Properties to set
             */
            function IKKickParams(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * IKKickParams standHeight.
             * @member {number} standHeight
             * @memberof message.motion.IKKickParams
             * @instance
             */
            IKKickParams.prototype.standHeight = 0;

            /**
             * Encodes the specified IKKickParams message. Does not implicitly {@link message.motion.IKKickParams.verify|verify} messages.
             * @function encode
             * @memberof message.motion.IKKickParams
             * @static
             * @param {message.motion.IIKKickParams} message IKKickParams message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IKKickParams.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.standHeight != null && Object.hasOwnProperty.call(message, "standHeight"))
                    writer.uint32(/* id 1, wireType 5 =*/13).float(message.standHeight);
                return writer;
            };

            /**
             * Decodes a IKKickParams message from the specified reader or buffer.
             * @function decode
             * @memberof message.motion.IKKickParams
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.IKKickParams} IKKickParams
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IKKickParams.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.motion.IKKickParams();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.standHeight = reader.float();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return IKKickParams;
        })();

        motion.WalkStarted = (function() {

            /**
             * Properties of a WalkStarted.
             * @memberof message.motion
             * @interface IWalkStarted
             */

            /**
             * Constructs a new WalkStarted.
             * @memberof message.motion
             * @classdesc Represents a WalkStarted.
             * @implements IWalkStarted
             * @constructor
             * @param {message.motion.IWalkStarted=} [properties] Properties to set
             */
            function WalkStarted(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Encodes the specified WalkStarted message. Does not implicitly {@link message.motion.WalkStarted.verify|verify} messages.
             * @function encode
             * @memberof message.motion.WalkStarted
             * @static
             * @param {message.motion.IWalkStarted} message WalkStarted message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WalkStarted.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Decodes a WalkStarted message from the specified reader or buffer.
             * @function decode
             * @memberof message.motion.WalkStarted
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.WalkStarted} WalkStarted
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WalkStarted.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.motion.WalkStarted();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return WalkStarted;
        })();

        motion.WalkStopped = (function() {

            /**
             * Properties of a WalkStopped.
             * @memberof message.motion
             * @interface IWalkStopped
             */

            /**
             * Constructs a new WalkStopped.
             * @memberof message.motion
             * @classdesc Represents a WalkStopped.
             * @implements IWalkStopped
             * @constructor
             * @param {message.motion.IWalkStopped=} [properties] Properties to set
             */
            function WalkStopped(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Encodes the specified WalkStopped message. Does not implicitly {@link message.motion.WalkStopped.verify|verify} messages.
             * @function encode
             * @memberof message.motion.WalkStopped
             * @static
             * @param {message.motion.IWalkStopped} message WalkStopped message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WalkStopped.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Decodes a WalkStopped message from the specified reader or buffer.
             * @function decode
             * @memberof message.motion.WalkStopped
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.WalkStopped} WalkStopped
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WalkStopped.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.motion.WalkStopped();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return WalkStopped;
        })();

        motion.WalkCommand = (function() {

            /**
             * Properties of a WalkCommand.
             * @memberof message.motion
             * @interface IWalkCommand
             * @property {number|Long|null} [subsumptionId] Reservation identifier for servo control
             * @property {Ivec3|null} [command] required rotational velocity about the z axis. In torso space
             */

            /**
             * Constructs a new WalkCommand.
             * @memberof message.motion
             * @classdesc Represents a WalkCommand.
             * @implements IWalkCommand
             * @constructor
             * @param {message.motion.IWalkCommand=} [properties] Properties to set
             */
            function WalkCommand(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Reservation identifier for servo control
             * @member {number|Long} subsumptionId
             * @memberof message.motion.WalkCommand
             * @instance
             */
            WalkCommand.prototype.subsumptionId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * required rotational velocity about the z axis. In torso space
             * @member {Ivec3|null|undefined} command
             * @memberof message.motion.WalkCommand
             * @instance
             */
            WalkCommand.prototype.command = null;

            /**
             * Encodes the specified WalkCommand message. Does not implicitly {@link message.motion.WalkCommand.verify|verify} messages.
             * @function encode
             * @memberof message.motion.WalkCommand
             * @static
             * @param {message.motion.IWalkCommand} message WalkCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WalkCommand.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.subsumptionId != null && Object.hasOwnProperty.call(message, "subsumptionId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.subsumptionId);
                if (message.command != null && Object.hasOwnProperty.call(message, "command"))
                    $root.vec3.encode(message.command, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a WalkCommand message from the specified reader or buffer.
             * @function decode
             * @memberof message.motion.WalkCommand
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.WalkCommand} WalkCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WalkCommand.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.motion.WalkCommand();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.subsumptionId = reader.uint64();
                        break;
                    case 2:
                        message.command = $root.vec3.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return WalkCommand;
        })();

        motion.StopCommand = (function() {

            /**
             * Properties of a StopCommand.
             * @memberof message.motion
             * @interface IStopCommand
             * @property {number|Long|null} [subsumptionId] Reservation identifier for servo control
             */

            /**
             * Constructs a new StopCommand.
             * @memberof message.motion
             * @classdesc Represents a StopCommand.
             * @implements IStopCommand
             * @constructor
             * @param {message.motion.IStopCommand=} [properties] Properties to set
             */
            function StopCommand(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Reservation identifier for servo control
             * @member {number|Long} subsumptionId
             * @memberof message.motion.StopCommand
             * @instance
             */
            StopCommand.prototype.subsumptionId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Encodes the specified StopCommand message. Does not implicitly {@link message.motion.StopCommand.verify|verify} messages.
             * @function encode
             * @memberof message.motion.StopCommand
             * @static
             * @param {message.motion.IStopCommand} message StopCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StopCommand.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.subsumptionId != null && Object.hasOwnProperty.call(message, "subsumptionId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.subsumptionId);
                return writer;
            };

            /**
             * Decodes a StopCommand message from the specified reader or buffer.
             * @function decode
             * @memberof message.motion.StopCommand
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.StopCommand} StopCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StopCommand.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.motion.StopCommand();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.subsumptionId = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return StopCommand;
        })();

        motion.NewWalkCommand = (function() {

            /**
             * Properties of a NewWalkCommand.
             * @memberof message.motion
             * @interface INewWalkCommand
             * @property {Ivec3|null} [velocityTarget] NewWalkCommand velocityTarget
             */

            /**
             * Constructs a new NewWalkCommand.
             * @memberof message.motion
             * @classdesc Represents a NewWalkCommand.
             * @implements INewWalkCommand
             * @constructor
             * @param {message.motion.INewWalkCommand=} [properties] Properties to set
             */
            function NewWalkCommand(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NewWalkCommand velocityTarget.
             * @member {Ivec3|null|undefined} velocityTarget
             * @memberof message.motion.NewWalkCommand
             * @instance
             */
            NewWalkCommand.prototype.velocityTarget = null;

            /**
             * Encodes the specified NewWalkCommand message. Does not implicitly {@link message.motion.NewWalkCommand.verify|verify} messages.
             * @function encode
             * @memberof message.motion.NewWalkCommand
             * @static
             * @param {message.motion.INewWalkCommand} message NewWalkCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NewWalkCommand.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.velocityTarget != null && Object.hasOwnProperty.call(message, "velocityTarget"))
                    $root.vec3.encode(message.velocityTarget, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a NewWalkCommand message from the specified reader or buffer.
             * @function decode
             * @memberof message.motion.NewWalkCommand
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.NewWalkCommand} NewWalkCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NewWalkCommand.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.motion.NewWalkCommand();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.velocityTarget = $root.vec3.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return NewWalkCommand;
        })();

        motion.EnableWalkEngineCommand = (function() {

            /**
             * Properties of an EnableWalkEngineCommand.
             * @memberof message.motion
             * @interface IEnableWalkEngineCommand
             * @property {number|Long|null} [subsumptionId] Reservation identifier for servo control
             */

            /**
             * Constructs a new EnableWalkEngineCommand.
             * @memberof message.motion
             * @classdesc Represents an EnableWalkEngineCommand.
             * @implements IEnableWalkEngineCommand
             * @constructor
             * @param {message.motion.IEnableWalkEngineCommand=} [properties] Properties to set
             */
            function EnableWalkEngineCommand(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Reservation identifier for servo control
             * @member {number|Long} subsumptionId
             * @memberof message.motion.EnableWalkEngineCommand
             * @instance
             */
            EnableWalkEngineCommand.prototype.subsumptionId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Encodes the specified EnableWalkEngineCommand message. Does not implicitly {@link message.motion.EnableWalkEngineCommand.verify|verify} messages.
             * @function encode
             * @memberof message.motion.EnableWalkEngineCommand
             * @static
             * @param {message.motion.IEnableWalkEngineCommand} message EnableWalkEngineCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnableWalkEngineCommand.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.subsumptionId != null && Object.hasOwnProperty.call(message, "subsumptionId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.subsumptionId);
                return writer;
            };

            /**
             * Decodes an EnableWalkEngineCommand message from the specified reader or buffer.
             * @function decode
             * @memberof message.motion.EnableWalkEngineCommand
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.EnableWalkEngineCommand} EnableWalkEngineCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnableWalkEngineCommand.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.motion.EnableWalkEngineCommand();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.subsumptionId = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return EnableWalkEngineCommand;
        })();

        motion.DisableWalkEngineCommand = (function() {

            /**
             * Properties of a DisableWalkEngineCommand.
             * @memberof message.motion
             * @interface IDisableWalkEngineCommand
             * @property {number|Long|null} [subsumptionId] Reservation identifier for servo control
             */

            /**
             * Constructs a new DisableWalkEngineCommand.
             * @memberof message.motion
             * @classdesc Represents a DisableWalkEngineCommand.
             * @implements IDisableWalkEngineCommand
             * @constructor
             * @param {message.motion.IDisableWalkEngineCommand=} [properties] Properties to set
             */
            function DisableWalkEngineCommand(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Reservation identifier for servo control
             * @member {number|Long} subsumptionId
             * @memberof message.motion.DisableWalkEngineCommand
             * @instance
             */
            DisableWalkEngineCommand.prototype.subsumptionId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Encodes the specified DisableWalkEngineCommand message. Does not implicitly {@link message.motion.DisableWalkEngineCommand.verify|verify} messages.
             * @function encode
             * @memberof message.motion.DisableWalkEngineCommand
             * @static
             * @param {message.motion.IDisableWalkEngineCommand} message DisableWalkEngineCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DisableWalkEngineCommand.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.subsumptionId != null && Object.hasOwnProperty.call(message, "subsumptionId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.subsumptionId);
                return writer;
            };

            /**
             * Decodes a DisableWalkEngineCommand message from the specified reader or buffer.
             * @function decode
             * @memberof message.motion.DisableWalkEngineCommand
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.DisableWalkEngineCommand} DisableWalkEngineCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DisableWalkEngineCommand.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.motion.DisableWalkEngineCommand();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.subsumptionId = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return DisableWalkEngineCommand;
        })();

        return motion;
    })();

    message.output = (function() {

        /**
         * Namespace output.
         * @memberof message
         * @namespace
         */
        const output = {};

        output.CompressedImage = (function() {

            /**
             * Properties of a CompressedImage.
             * @memberof message.output
             * @interface ICompressedImage
             * @property {number|null} [format] see module::output::compressor::turbojpeg::Compressor::compress for full list we use
             * @property {Iuvec2|null} [dimensions] Number of pixels of {x, y} of the image
             * @property {Uint8Array|null} [data] CompressedImage data
             * @property {number|null} [id] CompressedImage id
             * @property {string|null} [name] Name of the camera that took the image
             * @property {google.protobuf.ITimestamp|null} [timestamp] Time when the image was taken
             * @property {Imat4|null} [Hcw] World to camera Isometry3d transform
             * @property {message.output.CompressedImage.ILens|null} [lens] Lens information of the camera that took the image
             */

            /**
             * Constructs a new CompressedImage.
             * @memberof message.output
             * @classdesc Represents a CompressedImage.
             * @implements ICompressedImage
             * @constructor
             * @param {message.output.ICompressedImage=} [properties] Properties to set
             */
            function CompressedImage(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * see module::output::compressor::turbojpeg::Compressor::compress for full list we use
             * @member {number} format
             * @memberof message.output.CompressedImage
             * @instance
             */
            CompressedImage.prototype.format = 0;

            /**
             * Number of pixels of {x, y} of the image
             * @member {Iuvec2|null|undefined} dimensions
             * @memberof message.output.CompressedImage
             * @instance
             */
            CompressedImage.prototype.dimensions = null;

            /**
             * CompressedImage data.
             * @member {Uint8Array} data
             * @memberof message.output.CompressedImage
             * @instance
             */
            CompressedImage.prototype.data = $util.newBuffer([]);

            /**
             * CompressedImage id.
             * @member {number} id
             * @memberof message.output.CompressedImage
             * @instance
             */
            CompressedImage.prototype.id = 0;

            /**
             * Name of the camera that took the image
             * @member {string} name
             * @memberof message.output.CompressedImage
             * @instance
             */
            CompressedImage.prototype.name = "";

            /**
             * Time when the image was taken
             * @member {google.protobuf.ITimestamp|null|undefined} timestamp
             * @memberof message.output.CompressedImage
             * @instance
             */
            CompressedImage.prototype.timestamp = null;

            /**
             * World to camera Isometry3d transform
             * @member {Imat4|null|undefined} Hcw
             * @memberof message.output.CompressedImage
             * @instance
             */
            CompressedImage.prototype.Hcw = null;

            /**
             * Lens information of the camera that took the image
             * @member {message.output.CompressedImage.ILens|null|undefined} lens
             * @memberof message.output.CompressedImage
             * @instance
             */
            CompressedImage.prototype.lens = null;

            /**
             * Encodes the specified CompressedImage message. Does not implicitly {@link message.output.CompressedImage.verify|verify} messages.
             * @function encode
             * @memberof message.output.CompressedImage
             * @static
             * @param {message.output.ICompressedImage} message CompressedImage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CompressedImage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.format != null && Object.hasOwnProperty.call(message, "format"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.format);
                if (message.dimensions != null && Object.hasOwnProperty.call(message, "dimensions"))
                    $root.uvec2.encode(message.dimensions, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.data);
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.id);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.name);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    $root.google.protobuf.Timestamp.encode(message.timestamp, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.Hcw != null && Object.hasOwnProperty.call(message, "Hcw"))
                    $root.mat4.encode(message.Hcw, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.lens != null && Object.hasOwnProperty.call(message, "lens"))
                    $root.message.output.CompressedImage.Lens.encode(message.lens, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a CompressedImage message from the specified reader or buffer.
             * @function decode
             * @memberof message.output.CompressedImage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.output.CompressedImage} CompressedImage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CompressedImage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.output.CompressedImage();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.format = reader.uint32();
                        break;
                    case 2:
                        message.dimensions = $root.uvec2.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.data = reader.bytes();
                        break;
                    case 4:
                        message.id = reader.uint32();
                        break;
                    case 5:
                        message.name = reader.string();
                        break;
                    case 6:
                        message.timestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.Hcw = $root.mat4.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.lens = $root.message.output.CompressedImage.Lens.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            CompressedImage.Lens = (function() {

                /**
                 * Properties of a Lens.
                 * @memberof message.output.CompressedImage
                 * @interface ILens
                 * @property {message.output.CompressedImage.Lens.Projection|null} [projection] Lens projection
                 * @property {number|null} [focalLength] Normalised focal length, in pixels / image width
                 * @property {number|null} [fov] Angular diameter that the lens covers (the area that light hits on the sensor), in radians
                 * @property {Ifvec2|null} [centre] Normalised image centre offset - the number of pixels from centre to optical axis / image width
                 * @property {Ifvec2|null} [k] Lens k
                 */

                /**
                 * Constructs a new Lens.
                 * @memberof message.output.CompressedImage
                 * @classdesc Represents a Lens.
                 * @implements ILens
                 * @constructor
                 * @param {message.output.CompressedImage.ILens=} [properties] Properties to set
                 */
                function Lens(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Lens projection.
                 * @member {message.output.CompressedImage.Lens.Projection} projection
                 * @memberof message.output.CompressedImage.Lens
                 * @instance
                 */
                Lens.prototype.projection = 0;

                /**
                 * Normalised focal length, in pixels / image width
                 * @member {number} focalLength
                 * @memberof message.output.CompressedImage.Lens
                 * @instance
                 */
                Lens.prototype.focalLength = 0;

                /**
                 * Angular diameter that the lens covers (the area that light hits on the sensor), in radians
                 * @member {number} fov
                 * @memberof message.output.CompressedImage.Lens
                 * @instance
                 */
                Lens.prototype.fov = 0;

                /**
                 * Normalised image centre offset - the number of pixels from centre to optical axis / image width
                 * @member {Ifvec2|null|undefined} centre
                 * @memberof message.output.CompressedImage.Lens
                 * @instance
                 */
                Lens.prototype.centre = null;

                /**
                 * Lens k.
                 * @member {Ifvec2|null|undefined} k
                 * @memberof message.output.CompressedImage.Lens
                 * @instance
                 */
                Lens.prototype.k = null;

                /**
                 * Encodes the specified Lens message. Does not implicitly {@link message.output.CompressedImage.Lens.verify|verify} messages.
                 * @function encode
                 * @memberof message.output.CompressedImage.Lens
                 * @static
                 * @param {message.output.CompressedImage.ILens} message Lens message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Lens.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.projection != null && Object.hasOwnProperty.call(message, "projection"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.projection);
                    if (message.focalLength != null && Object.hasOwnProperty.call(message, "focalLength"))
                        writer.uint32(/* id 2, wireType 5 =*/21).float(message.focalLength);
                    if (message.fov != null && Object.hasOwnProperty.call(message, "fov"))
                        writer.uint32(/* id 3, wireType 5 =*/29).float(message.fov);
                    if (message.centre != null && Object.hasOwnProperty.call(message, "centre"))
                        $root.fvec2.encode(message.centre, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.k != null && Object.hasOwnProperty.call(message, "k"))
                        $root.fvec2.encode(message.k, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    return writer;
                };

                /**
                 * Decodes a Lens message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.output.CompressedImage.Lens
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.output.CompressedImage.Lens} Lens
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Lens.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.output.CompressedImage.Lens();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.projection = reader.int32();
                            break;
                        case 2:
                            message.focalLength = reader.float();
                            break;
                        case 3:
                            message.fov = reader.float();
                            break;
                        case 4:
                            message.centre = $root.fvec2.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.k = $root.fvec2.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Projection enum.
                 * @name message.output.CompressedImage.Lens.Projection
                 * @enum {number}
                 * @property {number} UNKNOWN=0 UNKNOWN value
                 * @property {number} RECTILINEAR=1 RECTILINEAR value
                 * @property {number} EQUIDISTANT=2 EQUIDISTANT value
                 * @property {number} EQUISOLID=3 EQUISOLID value
                 */
                Lens.Projection = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "UNKNOWN"] = 0;
                    values[valuesById[1] = "RECTILINEAR"] = 1;
                    values[valuesById[2] = "EQUIDISTANT"] = 2;
                    values[valuesById[3] = "EQUISOLID"] = 3;
                    return values;
                })();

                return Lens;
            })();

            return CompressedImage;
        })();

        output.Say = (function() {

            /**
             * Properties of a Say.
             * @memberof message.output
             * @interface ISay
             * @property {string|null} [message] Say message
             */

            /**
             * Constructs a new Say.
             * @memberof message.output
             * @classdesc Represents a Say.
             * @implements ISay
             * @constructor
             * @param {message.output.ISay=} [properties] Properties to set
             */
            function Say(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Say message.
             * @member {string} message
             * @memberof message.output.Say
             * @instance
             */
            Say.prototype.message = "";

            /**
             * Encodes the specified Say message. Does not implicitly {@link message.output.Say.verify|verify} messages.
             * @function encode
             * @memberof message.output.Say
             * @static
             * @param {message.output.ISay} message Say message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Say.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.message);
                return writer;
            };

            /**
             * Decodes a Say message from the specified reader or buffer.
             * @function decode
             * @memberof message.output.Say
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.output.Say} Say
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Say.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.output.Say();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.message = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return Say;
        })();

        return output;
    })();

    message.planning = (function() {

        /**
         * Namespace planning.
         * @memberof message
         * @namespace
         */
        const planning = {};

        planning.GetUpWhenFallen = (function() {

            /**
             * Properties of a GetUpWhenFallen.
             * @memberof message.planning
             * @interface IGetUpWhenFallen
             */

            /**
             * Constructs a new GetUpWhenFallen.
             * @memberof message.planning
             * @classdesc Emit a GetUpWhenFallen Task in order to tell the GetUpPlanner to start monitoring the robot's state and get it up if
             * it falls.
             * @implements IGetUpWhenFallen
             * @constructor
             * @param {message.planning.IGetUpWhenFallen=} [properties] Properties to set
             */
            function GetUpWhenFallen(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Encodes the specified GetUpWhenFallen message. Does not implicitly {@link message.planning.GetUpWhenFallen.verify|verify} messages.
             * @function encode
             * @memberof message.planning.GetUpWhenFallen
             * @static
             * @param {message.planning.IGetUpWhenFallen} message GetUpWhenFallen message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetUpWhenFallen.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Decodes a GetUpWhenFallen message from the specified reader or buffer.
             * @function decode
             * @memberof message.planning.GetUpWhenFallen
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.planning.GetUpWhenFallen} GetUpWhenFallen
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetUpWhenFallen.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.planning.GetUpWhenFallen();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return GetUpWhenFallen;
        })();

        planning.KickTo = (function() {

            /**
             * Properties of a KickTo.
             * @memberof message.planning
             * @interface IKickTo
             * @property {Ifvec3|null} [rPTt] Torso to point to kick to in torso space
             */

            /**
             * Constructs a new KickTo.
             * @memberof message.planning
             * @classdesc Represents a KickTo.
             * @implements IKickTo
             * @constructor
             * @param {message.planning.IKickTo=} [properties] Properties to set
             */
            function KickTo(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Torso to point to kick to in torso space
             * @member {Ifvec3|null|undefined} rPTt
             * @memberof message.planning.KickTo
             * @instance
             */
            KickTo.prototype.rPTt = null;

            /**
             * Encodes the specified KickTo message. Does not implicitly {@link message.planning.KickTo.verify|verify} messages.
             * @function encode
             * @memberof message.planning.KickTo
             * @static
             * @param {message.planning.IKickTo} message KickTo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KickTo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.rPTt != null && Object.hasOwnProperty.call(message, "rPTt"))
                    $root.fvec3.encode(message.rPTt, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a KickTo message from the specified reader or buffer.
             * @function decode
             * @memberof message.planning.KickTo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.planning.KickTo} KickTo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KickTo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.planning.KickTo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.rPTt = $root.fvec3.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return KickTo;
        })();

        planning.LookAround = (function() {

            /**
             * Properties of a LookAround.
             * @memberof message.planning
             * @interface ILookAround
             */

            /**
             * Constructs a new LookAround.
             * @memberof message.planning
             * @classdesc Task requesting to look around the environment
             * @implements ILookAround
             * @constructor
             * @param {message.planning.ILookAround=} [properties] Properties to set
             */
            function LookAround(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Encodes the specified LookAround message. Does not implicitly {@link message.planning.LookAround.verify|verify} messages.
             * @function encode
             * @memberof message.planning.LookAround
             * @static
             * @param {message.planning.ILookAround} message LookAround message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LookAround.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Decodes a LookAround message from the specified reader or buffer.
             * @function decode
             * @memberof message.planning.LookAround
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.planning.LookAround} LookAround
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LookAround.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.planning.LookAround();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return LookAround;
        })();

        planning.RelaxWhenFalling = (function() {

            /**
             * Properties of a RelaxWhenFalling.
             * @memberof message.planning
             * @interface IRelaxWhenFalling
             */

            /**
             * Constructs a new RelaxWhenFalling.
             * @memberof message.planning
             * @classdesc Emit a RelaxWhenFalling Task in order to tell the planner to start monitoring the robot's state and if it decides
             * that the robot is falling over, relax all the servos to prevent damage.
             * @implements IRelaxWhenFalling
             * @constructor
             * @param {message.planning.IRelaxWhenFalling=} [properties] Properties to set
             */
            function RelaxWhenFalling(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Encodes the specified RelaxWhenFalling message. Does not implicitly {@link message.planning.RelaxWhenFalling.verify|verify} messages.
             * @function encode
             * @memberof message.planning.RelaxWhenFalling
             * @static
             * @param {message.planning.IRelaxWhenFalling} message RelaxWhenFalling message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RelaxWhenFalling.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Decodes a RelaxWhenFalling message from the specified reader or buffer.
             * @function decode
             * @memberof message.planning.RelaxWhenFalling
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.planning.RelaxWhenFalling} RelaxWhenFalling
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RelaxWhenFalling.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.planning.RelaxWhenFalling();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return RelaxWhenFalling;
        })();

        planning.WalkTo = (function() {

            /**
             * Properties of a WalkTo.
             * @memberof message.planning
             * @interface IWalkTo
             * @property {Ifvec3|null} [rPTt] The point to walk to, relative to the torso
             */

            /**
             * Constructs a new WalkTo.
             * @memberof message.planning
             * @classdesc Plan a path to walk to the specified point
             * @implements IWalkTo
             * @constructor
             * @param {message.planning.IWalkTo=} [properties] Properties to set
             */
            function WalkTo(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * The point to walk to, relative to the torso
             * @member {Ifvec3|null|undefined} rPTt
             * @memberof message.planning.WalkTo
             * @instance
             */
            WalkTo.prototype.rPTt = null;

            /**
             * Encodes the specified WalkTo message. Does not implicitly {@link message.planning.WalkTo.verify|verify} messages.
             * @function encode
             * @memberof message.planning.WalkTo
             * @static
             * @param {message.planning.IWalkTo} message WalkTo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WalkTo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.rPTt != null && Object.hasOwnProperty.call(message, "rPTt"))
                    $root.fvec3.encode(message.rPTt, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a WalkTo message from the specified reader or buffer.
             * @function decode
             * @memberof message.planning.WalkTo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.planning.WalkTo} WalkTo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WalkTo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.planning.WalkTo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.rPTt = $root.fvec3.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return WalkTo;
        })();

        planning.TurnOnSpot = (function() {

            /**
             * Properties of a TurnOnSpot.
             * @memberof message.planning
             * @interface ITurnOnSpot
             * @property {boolean|null} [clockwise] Direction to turn
             */

            /**
             * Constructs a new TurnOnSpot.
             * @memberof message.planning
             * @classdesc Turn on the spot in the given direction
             * @implements ITurnOnSpot
             * @constructor
             * @param {message.planning.ITurnOnSpot=} [properties] Properties to set
             */
            function TurnOnSpot(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Direction to turn
             * @member {boolean} clockwise
             * @memberof message.planning.TurnOnSpot
             * @instance
             */
            TurnOnSpot.prototype.clockwise = false;

            /**
             * Encodes the specified TurnOnSpot message. Does not implicitly {@link message.planning.TurnOnSpot.verify|verify} messages.
             * @function encode
             * @memberof message.planning.TurnOnSpot
             * @static
             * @param {message.planning.ITurnOnSpot} message TurnOnSpot message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TurnOnSpot.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.clockwise != null && Object.hasOwnProperty.call(message, "clockwise"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.clockwise);
                return writer;
            };

            /**
             * Decodes a TurnOnSpot message from the specified reader or buffer.
             * @function decode
             * @memberof message.planning.TurnOnSpot
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.planning.TurnOnSpot} TurnOnSpot
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TurnOnSpot.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.planning.TurnOnSpot();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.clockwise = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return TurnOnSpot;
        })();

        planning.TurnAroundBall = (function() {

            /**
             * Properties of a TurnAroundBall.
             * @memberof message.planning
             * @interface ITurnAroundBall
             * @property {boolean|null} [clockwise] Direction to turn
             */

            /**
             * Constructs a new TurnAroundBall.
             * @memberof message.planning
             * @classdesc Turn around the ball in the given direction
             * @implements ITurnAroundBall
             * @constructor
             * @param {message.planning.ITurnAroundBall=} [properties] Properties to set
             */
            function TurnAroundBall(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Direction to turn
             * @member {boolean} clockwise
             * @memberof message.planning.TurnAroundBall
             * @instance
             */
            TurnAroundBall.prototype.clockwise = false;

            /**
             * Encodes the specified TurnAroundBall message. Does not implicitly {@link message.planning.TurnAroundBall.verify|verify} messages.
             * @function encode
             * @memberof message.planning.TurnAroundBall
             * @static
             * @param {message.planning.ITurnAroundBall} message TurnAroundBall message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TurnAroundBall.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.clockwise != null && Object.hasOwnProperty.call(message, "clockwise"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.clockwise);
                return writer;
            };

            /**
             * Decodes a TurnAroundBall message from the specified reader or buffer.
             * @function decode
             * @memberof message.planning.TurnAroundBall
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.planning.TurnAroundBall} TurnAroundBall
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TurnAroundBall.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.planning.TurnAroundBall();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.clockwise = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return TurnAroundBall;
        })();

        return planning;
    })();

    message.platform = (function() {

        /**
         * Namespace platform.
         * @memberof message
         * @namespace
         */
        const platform = {};

        platform.RawSensors = (function() {

            /**
             * Properties of a RawSensors.
             * @memberof message.platform
             * @interface IRawSensors
             * @property {google.protobuf.ITimestamp|null} [timestamp] Timestamp when our data were taken
             * @property {number|null} [platformErrorFlags] The list of errors is here: https://emanual.robotis.com/docs/en/dxl/protocol1/#status-packetreturn-packet
             * @property {message.platform.RawSensors.ILEDPanel|null} [ledPanel] RawSensors ledPanel
             * @property {message.platform.RawSensors.IHeadLED|null} [headLed] RawSensors headLed
             * @property {message.platform.RawSensors.IEyeLED|null} [eyeLed] RawSensors eyeLed
             * @property {message.platform.RawSensors.IButtons|null} [buttons] RawSensors buttons
             * @property {number|null} [voltage] Voltage for the whole robot, from the main battery, in Volts
             * @property {Ifvec3|null} [accelerometer] here https://emanual.robotis.com/docs/en/platform/op2/getting_started/#acc_x-acc_y-acc_z
             * @property {Ifvec3|null} [gyroscope] here https://emanual.robotis.com/docs/en/platform/op2/getting_started/#gyro_x-gyro_y-gyro_z
             * @property {message.platform.RawSensors.IFSRs|null} [fsr] RawSensors fsr
             * @property {message.platform.RawSensors.IServos|null} [servo] RawSensors servo
             * @property {message.platform.webots.IOdometryGroundTruth|null} [odometryGroundTruth] Ground truth from a simulator
             */

            /**
             * Constructs a new RawSensors.
             * @memberof message.platform
             * @classdesc @author Trent Houliston
             * @implements IRawSensors
             * @constructor
             * @param {message.platform.IRawSensors=} [properties] Properties to set
             */
            function RawSensors(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Timestamp when our data were taken
             * @member {google.protobuf.ITimestamp|null|undefined} timestamp
             * @memberof message.platform.RawSensors
             * @instance
             */
            RawSensors.prototype.timestamp = null;

            /**
             * The list of errors is here: https://emanual.robotis.com/docs/en/dxl/protocol1/#status-packetreturn-packet
             * @member {number} platformErrorFlags
             * @memberof message.platform.RawSensors
             * @instance
             */
            RawSensors.prototype.platformErrorFlags = 0;

            /**
             * RawSensors ledPanel.
             * @member {message.platform.RawSensors.ILEDPanel|null|undefined} ledPanel
             * @memberof message.platform.RawSensors
             * @instance
             */
            RawSensors.prototype.ledPanel = null;

            /**
             * RawSensors headLed.
             * @member {message.platform.RawSensors.IHeadLED|null|undefined} headLed
             * @memberof message.platform.RawSensors
             * @instance
             */
            RawSensors.prototype.headLed = null;

            /**
             * RawSensors eyeLed.
             * @member {message.platform.RawSensors.IEyeLED|null|undefined} eyeLed
             * @memberof message.platform.RawSensors
             * @instance
             */
            RawSensors.prototype.eyeLed = null;

            /**
             * RawSensors buttons.
             * @member {message.platform.RawSensors.IButtons|null|undefined} buttons
             * @memberof message.platform.RawSensors
             * @instance
             */
            RawSensors.prototype.buttons = null;

            /**
             * Voltage for the whole robot, from the main battery, in Volts
             * @member {number} voltage
             * @memberof message.platform.RawSensors
             * @instance
             */
            RawSensors.prototype.voltage = 0;

            /**
             * here https://emanual.robotis.com/docs/en/platform/op2/getting_started/#acc_x-acc_y-acc_z
             * @member {Ifvec3|null|undefined} accelerometer
             * @memberof message.platform.RawSensors
             * @instance
             */
            RawSensors.prototype.accelerometer = null;

            /**
             * here https://emanual.robotis.com/docs/en/platform/op2/getting_started/#gyro_x-gyro_y-gyro_z
             * @member {Ifvec3|null|undefined} gyroscope
             * @memberof message.platform.RawSensors
             * @instance
             */
            RawSensors.prototype.gyroscope = null;

            /**
             * RawSensors fsr.
             * @member {message.platform.RawSensors.IFSRs|null|undefined} fsr
             * @memberof message.platform.RawSensors
             * @instance
             */
            RawSensors.prototype.fsr = null;

            /**
             * RawSensors servo.
             * @member {message.platform.RawSensors.IServos|null|undefined} servo
             * @memberof message.platform.RawSensors
             * @instance
             */
            RawSensors.prototype.servo = null;

            /**
             * Ground truth from a simulator
             * @member {message.platform.webots.IOdometryGroundTruth|null|undefined} odometryGroundTruth
             * @memberof message.platform.RawSensors
             * @instance
             */
            RawSensors.prototype.odometryGroundTruth = null;

            /**
             * Encodes the specified RawSensors message. Does not implicitly {@link message.platform.RawSensors.verify|verify} messages.
             * @function encode
             * @memberof message.platform.RawSensors
             * @static
             * @param {message.platform.IRawSensors} message RawSensors message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RawSensors.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    $root.google.protobuf.Timestamp.encode(message.timestamp, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.platformErrorFlags != null && Object.hasOwnProperty.call(message, "platformErrorFlags"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.platformErrorFlags);
                if (message.ledPanel != null && Object.hasOwnProperty.call(message, "ledPanel"))
                    $root.message.platform.RawSensors.LEDPanel.encode(message.ledPanel, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.headLed != null && Object.hasOwnProperty.call(message, "headLed"))
                    $root.message.platform.RawSensors.HeadLED.encode(message.headLed, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.eyeLed != null && Object.hasOwnProperty.call(message, "eyeLed"))
                    $root.message.platform.RawSensors.EyeLED.encode(message.eyeLed, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.buttons != null && Object.hasOwnProperty.call(message, "buttons"))
                    $root.message.platform.RawSensors.Buttons.encode(message.buttons, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.voltage != null && Object.hasOwnProperty.call(message, "voltage"))
                    writer.uint32(/* id 7, wireType 5 =*/61).float(message.voltage);
                if (message.accelerometer != null && Object.hasOwnProperty.call(message, "accelerometer"))
                    $root.fvec3.encode(message.accelerometer, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.gyroscope != null && Object.hasOwnProperty.call(message, "gyroscope"))
                    $root.fvec3.encode(message.gyroscope, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.fsr != null && Object.hasOwnProperty.call(message, "fsr"))
                    $root.message.platform.RawSensors.FSRs.encode(message.fsr, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                if (message.servo != null && Object.hasOwnProperty.call(message, "servo"))
                    $root.message.platform.RawSensors.Servos.encode(message.servo, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.odometryGroundTruth != null && Object.hasOwnProperty.call(message, "odometryGroundTruth"))
                    $root.message.platform.webots.OdometryGroundTruth.encode(message.odometryGroundTruth, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a RawSensors message from the specified reader or buffer.
             * @function decode
             * @memberof message.platform.RawSensors
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.platform.RawSensors} RawSensors
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RawSensors.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.platform.RawSensors();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.timestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.platformErrorFlags = reader.uint32();
                        break;
                    case 3:
                        message.ledPanel = $root.message.platform.RawSensors.LEDPanel.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.headLed = $root.message.platform.RawSensors.HeadLED.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.eyeLed = $root.message.platform.RawSensors.EyeLED.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.buttons = $root.message.platform.RawSensors.Buttons.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.voltage = reader.float();
                        break;
                    case 8:
                        message.accelerometer = $root.fvec3.decode(reader, reader.uint32());
                        break;
                    case 9:
                        message.gyroscope = $root.fvec3.decode(reader, reader.uint32());
                        break;
                    case 10:
                        message.fsr = $root.message.platform.RawSensors.FSRs.decode(reader, reader.uint32());
                        break;
                    case 11:
                        message.servo = $root.message.platform.RawSensors.Servos.decode(reader, reader.uint32());
                        break;
                    case 12:
                        message.odometryGroundTruth = $root.message.platform.webots.OdometryGroundTruth.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * See https://emanual.robotis.com/docs/en/dxl/protocol1/#protocol
             * @name message.platform.RawSensors.Error
             * @enum {number}
             * @property {number} OK=0 OK value
             * @property {number} INPUT_VOLTAGE=1 INPUT_VOLTAGE value
             * @property {number} ANGLE_LIMIT=2 ANGLE_LIMIT value
             * @property {number} OVERHEATING=4 OVERHEATING value
             * @property {number} RANGE=8 RANGE value
             * @property {number} CHECKSUM=16 CHECKSUM value
             * @property {number} OVERLOAD=32 OVERLOAD value
             * @property {number} INSTRUCTION=64 INSTRUCTION value
             * @property {number} CORRUPT_DATA=128 CORRUPT_DATA value
             * @property {number} TIMEOUT=256 TIMEOUT value
             */
            RawSensors.Error = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "OK"] = 0;
                values[valuesById[1] = "INPUT_VOLTAGE"] = 1;
                values[valuesById[2] = "ANGLE_LIMIT"] = 2;
                values[valuesById[4] = "OVERHEATING"] = 4;
                values[valuesById[8] = "RANGE"] = 8;
                values[valuesById[16] = "CHECKSUM"] = 16;
                values[valuesById[32] = "OVERLOAD"] = 32;
                values[valuesById[64] = "INSTRUCTION"] = 64;
                values[valuesById[128] = "CORRUPT_DATA"] = 128;
                values[valuesById[256] = "TIMEOUT"] = 256;
                return values;
            })();

            RawSensors.LEDPanel = (function() {

                /**
                 * Properties of a LEDPanel.
                 * @memberof message.platform.RawSensors
                 * @interface ILEDPanel
                 * @property {boolean|null} [led2] LEDPanel led2
                 * @property {boolean|null} [led3] LEDPanel led3
                 * @property {boolean|null} [led4] LEDPanel led4
                 */

                /**
                 * Constructs a new LEDPanel.
                 * @memberof message.platform.RawSensors
                 * @classdesc Represents a LEDPanel.
                 * @implements ILEDPanel
                 * @constructor
                 * @param {message.platform.RawSensors.ILEDPanel=} [properties] Properties to set
                 */
                function LEDPanel(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * LEDPanel led2.
                 * @member {boolean} led2
                 * @memberof message.platform.RawSensors.LEDPanel
                 * @instance
                 */
                LEDPanel.prototype.led2 = false;

                /**
                 * LEDPanel led3.
                 * @member {boolean} led3
                 * @memberof message.platform.RawSensors.LEDPanel
                 * @instance
                 */
                LEDPanel.prototype.led3 = false;

                /**
                 * LEDPanel led4.
                 * @member {boolean} led4
                 * @memberof message.platform.RawSensors.LEDPanel
                 * @instance
                 */
                LEDPanel.prototype.led4 = false;

                /**
                 * Encodes the specified LEDPanel message. Does not implicitly {@link message.platform.RawSensors.LEDPanel.verify|verify} messages.
                 * @function encode
                 * @memberof message.platform.RawSensors.LEDPanel
                 * @static
                 * @param {message.platform.RawSensors.ILEDPanel} message LEDPanel message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LEDPanel.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.led2 != null && Object.hasOwnProperty.call(message, "led2"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.led2);
                    if (message.led3 != null && Object.hasOwnProperty.call(message, "led3"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.led3);
                    if (message.led4 != null && Object.hasOwnProperty.call(message, "led4"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.led4);
                    return writer;
                };

                /**
                 * Decodes a LEDPanel message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.platform.RawSensors.LEDPanel
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.platform.RawSensors.LEDPanel} LEDPanel
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LEDPanel.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.platform.RawSensors.LEDPanel();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.led2 = reader.bool();
                            break;
                        case 2:
                            message.led3 = reader.bool();
                            break;
                        case 3:
                            message.led4 = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return LEDPanel;
            })();

            RawSensors.HeadLED = (function() {

                /**
                 * Properties of a HeadLED.
                 * @memberof message.platform.RawSensors
                 * @interface IHeadLED
                 * @property {number|null} [RGB] Encode as 0x00 0xRR 0xGG 0xBB
                 */

                /**
                 * Constructs a new HeadLED.
                 * @memberof message.platform.RawSensors
                 * @classdesc Represents a HeadLED.
                 * @implements IHeadLED
                 * @constructor
                 * @param {message.platform.RawSensors.IHeadLED=} [properties] Properties to set
                 */
                function HeadLED(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Encode as 0x00 0xRR 0xGG 0xBB
                 * @member {number} RGB
                 * @memberof message.platform.RawSensors.HeadLED
                 * @instance
                 */
                HeadLED.prototype.RGB = 0;

                /**
                 * Encodes the specified HeadLED message. Does not implicitly {@link message.platform.RawSensors.HeadLED.verify|verify} messages.
                 * @function encode
                 * @memberof message.platform.RawSensors.HeadLED
                 * @static
                 * @param {message.platform.RawSensors.IHeadLED} message HeadLED message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                HeadLED.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.RGB != null && Object.hasOwnProperty.call(message, "RGB"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.RGB);
                    return writer;
                };

                /**
                 * Decodes a HeadLED message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.platform.RawSensors.HeadLED
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.platform.RawSensors.HeadLED} HeadLED
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                HeadLED.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.platform.RawSensors.HeadLED();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.RGB = reader.uint32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return HeadLED;
            })();

            RawSensors.EyeLED = (function() {

                /**
                 * Properties of an EyeLED.
                 * @memberof message.platform.RawSensors
                 * @interface IEyeLED
                 * @property {number|null} [RGB] Encode as 0x00 0xRR 0xGG 0xBB
                 */

                /**
                 * Constructs a new EyeLED.
                 * @memberof message.platform.RawSensors
                 * @classdesc Represents an EyeLED.
                 * @implements IEyeLED
                 * @constructor
                 * @param {message.platform.RawSensors.IEyeLED=} [properties] Properties to set
                 */
                function EyeLED(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Encode as 0x00 0xRR 0xGG 0xBB
                 * @member {number} RGB
                 * @memberof message.platform.RawSensors.EyeLED
                 * @instance
                 */
                EyeLED.prototype.RGB = 0;

                /**
                 * Encodes the specified EyeLED message. Does not implicitly {@link message.platform.RawSensors.EyeLED.verify|verify} messages.
                 * @function encode
                 * @memberof message.platform.RawSensors.EyeLED
                 * @static
                 * @param {message.platform.RawSensors.IEyeLED} message EyeLED message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EyeLED.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.RGB != null && Object.hasOwnProperty.call(message, "RGB"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.RGB);
                    return writer;
                };

                /**
                 * Decodes an EyeLED message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.platform.RawSensors.EyeLED
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.platform.RawSensors.EyeLED} EyeLED
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EyeLED.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.platform.RawSensors.EyeLED();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.RGB = reader.uint32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return EyeLED;
            })();

            RawSensors.Buttons = (function() {

                /**
                 * Properties of a Buttons.
                 * @memberof message.platform.RawSensors
                 * @interface IButtons
                 * @property {boolean|null} [left] Buttons left
                 * @property {boolean|null} [middle] Buttons middle
                 */

                /**
                 * Constructs a new Buttons.
                 * @memberof message.platform.RawSensors
                 * @classdesc Represents a Buttons.
                 * @implements IButtons
                 * @constructor
                 * @param {message.platform.RawSensors.IButtons=} [properties] Properties to set
                 */
                function Buttons(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Buttons left.
                 * @member {boolean} left
                 * @memberof message.platform.RawSensors.Buttons
                 * @instance
                 */
                Buttons.prototype.left = false;

                /**
                 * Buttons middle.
                 * @member {boolean} middle
                 * @memberof message.platform.RawSensors.Buttons
                 * @instance
                 */
                Buttons.prototype.middle = false;

                /**
                 * Encodes the specified Buttons message. Does not implicitly {@link message.platform.RawSensors.Buttons.verify|verify} messages.
                 * @function encode
                 * @memberof message.platform.RawSensors.Buttons
                 * @static
                 * @param {message.platform.RawSensors.IButtons} message Buttons message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Buttons.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.left != null && Object.hasOwnProperty.call(message, "left"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.left);
                    if (message.middle != null && Object.hasOwnProperty.call(message, "middle"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.middle);
                    return writer;
                };

                /**
                 * Decodes a Buttons message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.platform.RawSensors.Buttons
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.platform.RawSensors.Buttons} Buttons
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Buttons.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.platform.RawSensors.Buttons();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.left = reader.bool();
                            break;
                        case 2:
                            message.middle = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return Buttons;
            })();

            RawSensors.FSR = (function() {

                /**
                 * Properties of a FSR.
                 * @memberof message.platform.RawSensors
                 * @interface IFSR
                 * @property {number|null} [fsr1] FSR fsr1
                 * @property {number|null} [fsr2] FSR fsr2
                 * @property {number|null} [fsr3] FSR fsr3
                 * @property {number|null} [fsr4] FSR fsr4
                 * @property {number|null} [centreX] FSR centreX
                 * @property {number|null} [centreY] FSR centreY
                 * @property {number|null} [errorFlags] FSR errorFlags
                 */

                /**
                 * Constructs a new FSR.
                 * @memberof message.platform.RawSensors
                 * @classdesc There are four FSRs per foot, so this message is for one foot
                 * @implements IFSR
                 * @constructor
                 * @param {message.platform.RawSensors.IFSR=} [properties] Properties to set
                 */
                function FSR(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * FSR fsr1.
                 * @member {number} fsr1
                 * @memberof message.platform.RawSensors.FSR
                 * @instance
                 */
                FSR.prototype.fsr1 = 0;

                /**
                 * FSR fsr2.
                 * @member {number} fsr2
                 * @memberof message.platform.RawSensors.FSR
                 * @instance
                 */
                FSR.prototype.fsr2 = 0;

                /**
                 * FSR fsr3.
                 * @member {number} fsr3
                 * @memberof message.platform.RawSensors.FSR
                 * @instance
                 */
                FSR.prototype.fsr3 = 0;

                /**
                 * FSR fsr4.
                 * @member {number} fsr4
                 * @memberof message.platform.RawSensors.FSR
                 * @instance
                 */
                FSR.prototype.fsr4 = 0;

                /**
                 * FSR centreX.
                 * @member {number} centreX
                 * @memberof message.platform.RawSensors.FSR
                 * @instance
                 */
                FSR.prototype.centreX = 0;

                /**
                 * FSR centreY.
                 * @member {number} centreY
                 * @memberof message.platform.RawSensors.FSR
                 * @instance
                 */
                FSR.prototype.centreY = 0;

                /**
                 * FSR errorFlags.
                 * @member {number} errorFlags
                 * @memberof message.platform.RawSensors.FSR
                 * @instance
                 */
                FSR.prototype.errorFlags = 0;

                /**
                 * Encodes the specified FSR message. Does not implicitly {@link message.platform.RawSensors.FSR.verify|verify} messages.
                 * @function encode
                 * @memberof message.platform.RawSensors.FSR
                 * @static
                 * @param {message.platform.RawSensors.IFSR} message FSR message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FSR.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.fsr1 != null && Object.hasOwnProperty.call(message, "fsr1"))
                        writer.uint32(/* id 1, wireType 5 =*/13).float(message.fsr1);
                    if (message.fsr2 != null && Object.hasOwnProperty.call(message, "fsr2"))
                        writer.uint32(/* id 2, wireType 5 =*/21).float(message.fsr2);
                    if (message.fsr3 != null && Object.hasOwnProperty.call(message, "fsr3"))
                        writer.uint32(/* id 3, wireType 5 =*/29).float(message.fsr3);
                    if (message.fsr4 != null && Object.hasOwnProperty.call(message, "fsr4"))
                        writer.uint32(/* id 4, wireType 5 =*/37).float(message.fsr4);
                    if (message.centreX != null && Object.hasOwnProperty.call(message, "centreX"))
                        writer.uint32(/* id 5, wireType 5 =*/45).float(message.centreX);
                    if (message.centreY != null && Object.hasOwnProperty.call(message, "centreY"))
                        writer.uint32(/* id 6, wireType 5 =*/53).float(message.centreY);
                    if (message.errorFlags != null && Object.hasOwnProperty.call(message, "errorFlags"))
                        writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.errorFlags);
                    return writer;
                };

                /**
                 * Decodes a FSR message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.platform.RawSensors.FSR
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.platform.RawSensors.FSR} FSR
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FSR.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.platform.RawSensors.FSR();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.fsr1 = reader.float();
                            break;
                        case 2:
                            message.fsr2 = reader.float();
                            break;
                        case 3:
                            message.fsr3 = reader.float();
                            break;
                        case 4:
                            message.fsr4 = reader.float();
                            break;
                        case 5:
                            message.centreX = reader.float();
                            break;
                        case 6:
                            message.centreY = reader.float();
                            break;
                        case 7:
                            message.errorFlags = reader.uint32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return FSR;
            })();

            RawSensors.FSRs = (function() {

                /**
                 * Properties of a FSRs.
                 * @memberof message.platform.RawSensors
                 * @interface IFSRs
                 * @property {message.platform.RawSensors.IFSR|null} [left] Left foot
                 * @property {message.platform.RawSensors.IFSR|null} [right] Right foot
                 */

                /**
                 * Constructs a new FSRs.
                 * @memberof message.platform.RawSensors
                 * @classdesc Represents a FSRs.
                 * @implements IFSRs
                 * @constructor
                 * @param {message.platform.RawSensors.IFSRs=} [properties] Properties to set
                 */
                function FSRs(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Left foot
                 * @member {message.platform.RawSensors.IFSR|null|undefined} left
                 * @memberof message.platform.RawSensors.FSRs
                 * @instance
                 */
                FSRs.prototype.left = null;

                /**
                 * Right foot
                 * @member {message.platform.RawSensors.IFSR|null|undefined} right
                 * @memberof message.platform.RawSensors.FSRs
                 * @instance
                 */
                FSRs.prototype.right = null;

                /**
                 * Encodes the specified FSRs message. Does not implicitly {@link message.platform.RawSensors.FSRs.verify|verify} messages.
                 * @function encode
                 * @memberof message.platform.RawSensors.FSRs
                 * @static
                 * @param {message.platform.RawSensors.IFSRs} message FSRs message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FSRs.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.left != null && Object.hasOwnProperty.call(message, "left"))
                        $root.message.platform.RawSensors.FSR.encode(message.left, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.right != null && Object.hasOwnProperty.call(message, "right"))
                        $root.message.platform.RawSensors.FSR.encode(message.right, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Decodes a FSRs message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.platform.RawSensors.FSRs
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.platform.RawSensors.FSRs} FSRs
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FSRs.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.platform.RawSensors.FSRs();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.left = $root.message.platform.RawSensors.FSR.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.right = $root.message.platform.RawSensors.FSR.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return FSRs;
            })();

            RawSensors.Servo = (function() {

                /**
                 * Properties of a Servo.
                 * @memberof message.platform.RawSensors
                 * @interface IServo
                 * @property {number|null} [errorFlags] https://emanual.robotis.com/docs/en/dxl/mx/mx-106/#alarm-led17-shutdown18
                 * @property {boolean|null} [torqueEnabled] Servo torqueEnabled
                 * @property {number|null} [pGain] Proportional gain. In proportion to the servo's position error. Gain values are in range 0~100
                 * @property {number|null} [iGain] range 0~100
                 * @property {number|null} [dGain] range 0~100
                 * @property {number|null} [goalPosition] Alarm is triggered as set in Alarm LED/Shutdown
                 * @property {number|null} [movingSpeed] What dynamixel servos call velocity. In radians per second
                 * @property {number|null} [torque] Used to set the servo on or off. Typically either 0 (off) or 100 (on). Not really in any unit
                 * @property {number|null} [presentPosition] In radians
                 * @property {number|null} [presentSpeed] In radians per second
                 * @property {number|null} [load] is clockwise
                 * @property {number|null} [voltage] returned as 1 and Alarm is triggered and set the address 17 and set 1 to the Bit 0 of the address 18
                 * @property {number|null} [temperature] In degrees Celsius
                 */

                /**
                 * Constructs a new Servo.
                 * @memberof message.platform.RawSensors
                 * @classdesc Ref: https://emanual.robotis.com/docs/en/dxl/mx/mx-64/ ; https://emanual.robotis.com/docs/en/dxl/mx/mx-106/
                 * @implements IServo
                 * @constructor
                 * @param {message.platform.RawSensors.IServo=} [properties] Properties to set
                 */
                function Servo(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * https://emanual.robotis.com/docs/en/dxl/mx/mx-106/#alarm-led17-shutdown18
                 * @member {number} errorFlags
                 * @memberof message.platform.RawSensors.Servo
                 * @instance
                 */
                Servo.prototype.errorFlags = 0;

                /**
                 * Servo torqueEnabled.
                 * @member {boolean} torqueEnabled
                 * @memberof message.platform.RawSensors.Servo
                 * @instance
                 */
                Servo.prototype.torqueEnabled = false;

                /**
                 * Proportional gain. In proportion to the servo's position error. Gain values are in range 0~100
                 * @member {number} pGain
                 * @memberof message.platform.RawSensors.Servo
                 * @instance
                 */
                Servo.prototype.pGain = 0;

                /**
                 * range 0~100
                 * @member {number} iGain
                 * @memberof message.platform.RawSensors.Servo
                 * @instance
                 */
                Servo.prototype.iGain = 0;

                /**
                 * range 0~100
                 * @member {number} dGain
                 * @memberof message.platform.RawSensors.Servo
                 * @instance
                 */
                Servo.prototype.dGain = 0;

                /**
                 * Alarm is triggered as set in Alarm LED/Shutdown
                 * @member {number} goalPosition
                 * @memberof message.platform.RawSensors.Servo
                 * @instance
                 */
                Servo.prototype.goalPosition = 0;

                /**
                 * What dynamixel servos call velocity. In radians per second
                 * @member {number} movingSpeed
                 * @memberof message.platform.RawSensors.Servo
                 * @instance
                 */
                Servo.prototype.movingSpeed = 0;

                /**
                 * Used to set the servo on or off. Typically either 0 (off) or 100 (on). Not really in any unit
                 * @member {number} torque
                 * @memberof message.platform.RawSensors.Servo
                 * @instance
                 */
                Servo.prototype.torque = 0;

                /**
                 * In radians
                 * @member {number} presentPosition
                 * @memberof message.platform.RawSensors.Servo
                 * @instance
                 */
                Servo.prototype.presentPosition = 0;

                /**
                 * In radians per second
                 * @member {number} presentSpeed
                 * @memberof message.platform.RawSensors.Servo
                 * @instance
                 */
                Servo.prototype.presentSpeed = 0;

                /**
                 * is clockwise
                 * @member {number} load
                 * @memberof message.platform.RawSensors.Servo
                 * @instance
                 */
                Servo.prototype.load = 0;

                /**
                 * returned as 1 and Alarm is triggered and set the address 17 and set 1 to the Bit 0 of the address 18
                 * @member {number} voltage
                 * @memberof message.platform.RawSensors.Servo
                 * @instance
                 */
                Servo.prototype.voltage = 0;

                /**
                 * In degrees Celsius
                 * @member {number} temperature
                 * @memberof message.platform.RawSensors.Servo
                 * @instance
                 */
                Servo.prototype.temperature = 0;

                /**
                 * Encodes the specified Servo message. Does not implicitly {@link message.platform.RawSensors.Servo.verify|verify} messages.
                 * @function encode
                 * @memberof message.platform.RawSensors.Servo
                 * @static
                 * @param {message.platform.RawSensors.IServo} message Servo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Servo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.errorFlags != null && Object.hasOwnProperty.call(message, "errorFlags"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.errorFlags);
                    if (message.torqueEnabled != null && Object.hasOwnProperty.call(message, "torqueEnabled"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.torqueEnabled);
                    if (message.pGain != null && Object.hasOwnProperty.call(message, "pGain"))
                        writer.uint32(/* id 3, wireType 5 =*/29).float(message.pGain);
                    if (message.iGain != null && Object.hasOwnProperty.call(message, "iGain"))
                        writer.uint32(/* id 4, wireType 5 =*/37).float(message.iGain);
                    if (message.dGain != null && Object.hasOwnProperty.call(message, "dGain"))
                        writer.uint32(/* id 5, wireType 5 =*/45).float(message.dGain);
                    if (message.goalPosition != null && Object.hasOwnProperty.call(message, "goalPosition"))
                        writer.uint32(/* id 6, wireType 5 =*/53).float(message.goalPosition);
                    if (message.movingSpeed != null && Object.hasOwnProperty.call(message, "movingSpeed"))
                        writer.uint32(/* id 7, wireType 5 =*/61).float(message.movingSpeed);
                    if (message.torque != null && Object.hasOwnProperty.call(message, "torque"))
                        writer.uint32(/* id 8, wireType 5 =*/69).float(message.torque);
                    if (message.presentPosition != null && Object.hasOwnProperty.call(message, "presentPosition"))
                        writer.uint32(/* id 9, wireType 5 =*/77).float(message.presentPosition);
                    if (message.presentSpeed != null && Object.hasOwnProperty.call(message, "presentSpeed"))
                        writer.uint32(/* id 10, wireType 5 =*/85).float(message.presentSpeed);
                    if (message.load != null && Object.hasOwnProperty.call(message, "load"))
                        writer.uint32(/* id 11, wireType 5 =*/93).float(message.load);
                    if (message.voltage != null && Object.hasOwnProperty.call(message, "voltage"))
                        writer.uint32(/* id 12, wireType 5 =*/101).float(message.voltage);
                    if (message.temperature != null && Object.hasOwnProperty.call(message, "temperature"))
                        writer.uint32(/* id 13, wireType 5 =*/109).float(message.temperature);
                    return writer;
                };

                /**
                 * Decodes a Servo message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.platform.RawSensors.Servo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.platform.RawSensors.Servo} Servo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Servo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.platform.RawSensors.Servo();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.errorFlags = reader.uint32();
                            break;
                        case 2:
                            message.torqueEnabled = reader.bool();
                            break;
                        case 3:
                            message.pGain = reader.float();
                            break;
                        case 4:
                            message.iGain = reader.float();
                            break;
                        case 5:
                            message.dGain = reader.float();
                            break;
                        case 6:
                            message.goalPosition = reader.float();
                            break;
                        case 7:
                            message.movingSpeed = reader.float();
                            break;
                        case 8:
                            message.torque = reader.float();
                            break;
                        case 9:
                            message.presentPosition = reader.float();
                            break;
                        case 10:
                            message.presentSpeed = reader.float();
                            break;
                        case 11:
                            message.load = reader.float();
                            break;
                        case 12:
                            message.voltage = reader.float();
                            break;
                        case 13:
                            message.temperature = reader.float();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return Servo;
            })();

            RawSensors.Servos = (function() {

                /**
                 * Properties of a Servos.
                 * @memberof message.platform.RawSensors
                 * @interface IServos
                 * @property {message.platform.RawSensors.IServo|null} [rShoulderPitch] Servos rShoulderPitch
                 * @property {message.platform.RawSensors.IServo|null} [lShoulderPitch] Servos lShoulderPitch
                 * @property {message.platform.RawSensors.IServo|null} [rShoulderRoll] Servos rShoulderRoll
                 * @property {message.platform.RawSensors.IServo|null} [lShoulderRoll] Servos lShoulderRoll
                 * @property {message.platform.RawSensors.IServo|null} [rElbow] Servos rElbow
                 * @property {message.platform.RawSensors.IServo|null} [lElbow] Servos lElbow
                 * @property {message.platform.RawSensors.IServo|null} [rHipYaw] Servos rHipYaw
                 * @property {message.platform.RawSensors.IServo|null} [lHipYaw] Servos lHipYaw
                 * @property {message.platform.RawSensors.IServo|null} [rHipRoll] Servos rHipRoll
                 * @property {message.platform.RawSensors.IServo|null} [lHipRoll] Servos lHipRoll
                 * @property {message.platform.RawSensors.IServo|null} [rHipPitch] Servos rHipPitch
                 * @property {message.platform.RawSensors.IServo|null} [lHipPitch] Servos lHipPitch
                 * @property {message.platform.RawSensors.IServo|null} [rKnee] Servos rKnee
                 * @property {message.platform.RawSensors.IServo|null} [lKnee] Servos lKnee
                 * @property {message.platform.RawSensors.IServo|null} [rAnklePitch] Servos rAnklePitch
                 * @property {message.platform.RawSensors.IServo|null} [lAnklePitch] Servos lAnklePitch
                 * @property {message.platform.RawSensors.IServo|null} [rAnkleRoll] Servos rAnkleRoll
                 * @property {message.platform.RawSensors.IServo|null} [lAnkleRoll] Servos lAnkleRoll
                 * @property {message.platform.RawSensors.IServo|null} [headPan] Servos headPan
                 * @property {message.platform.RawSensors.IServo|null} [headTilt] Servos headTilt
                 */

                /**
                 * Constructs a new Servos.
                 * @memberof message.platform.RawSensors
                 * @classdesc Set of all the servos on the robot
                 * @implements IServos
                 * @constructor
                 * @param {message.platform.RawSensors.IServos=} [properties] Properties to set
                 */
                function Servos(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Servos rShoulderPitch.
                 * @member {message.platform.RawSensors.IServo|null|undefined} rShoulderPitch
                 * @memberof message.platform.RawSensors.Servos
                 * @instance
                 */
                Servos.prototype.rShoulderPitch = null;

                /**
                 * Servos lShoulderPitch.
                 * @member {message.platform.RawSensors.IServo|null|undefined} lShoulderPitch
                 * @memberof message.platform.RawSensors.Servos
                 * @instance
                 */
                Servos.prototype.lShoulderPitch = null;

                /**
                 * Servos rShoulderRoll.
                 * @member {message.platform.RawSensors.IServo|null|undefined} rShoulderRoll
                 * @memberof message.platform.RawSensors.Servos
                 * @instance
                 */
                Servos.prototype.rShoulderRoll = null;

                /**
                 * Servos lShoulderRoll.
                 * @member {message.platform.RawSensors.IServo|null|undefined} lShoulderRoll
                 * @memberof message.platform.RawSensors.Servos
                 * @instance
                 */
                Servos.prototype.lShoulderRoll = null;

                /**
                 * Servos rElbow.
                 * @member {message.platform.RawSensors.IServo|null|undefined} rElbow
                 * @memberof message.platform.RawSensors.Servos
                 * @instance
                 */
                Servos.prototype.rElbow = null;

                /**
                 * Servos lElbow.
                 * @member {message.platform.RawSensors.IServo|null|undefined} lElbow
                 * @memberof message.platform.RawSensors.Servos
                 * @instance
                 */
                Servos.prototype.lElbow = null;

                /**
                 * Servos rHipYaw.
                 * @member {message.platform.RawSensors.IServo|null|undefined} rHipYaw
                 * @memberof message.platform.RawSensors.Servos
                 * @instance
                 */
                Servos.prototype.rHipYaw = null;

                /**
                 * Servos lHipYaw.
                 * @member {message.platform.RawSensors.IServo|null|undefined} lHipYaw
                 * @memberof message.platform.RawSensors.Servos
                 * @instance
                 */
                Servos.prototype.lHipYaw = null;

                /**
                 * Servos rHipRoll.
                 * @member {message.platform.RawSensors.IServo|null|undefined} rHipRoll
                 * @memberof message.platform.RawSensors.Servos
                 * @instance
                 */
                Servos.prototype.rHipRoll = null;

                /**
                 * Servos lHipRoll.
                 * @member {message.platform.RawSensors.IServo|null|undefined} lHipRoll
                 * @memberof message.platform.RawSensors.Servos
                 * @instance
                 */
                Servos.prototype.lHipRoll = null;

                /**
                 * Servos rHipPitch.
                 * @member {message.platform.RawSensors.IServo|null|undefined} rHipPitch
                 * @memberof message.platform.RawSensors.Servos
                 * @instance
                 */
                Servos.prototype.rHipPitch = null;

                /**
                 * Servos lHipPitch.
                 * @member {message.platform.RawSensors.IServo|null|undefined} lHipPitch
                 * @memberof message.platform.RawSensors.Servos
                 * @instance
                 */
                Servos.prototype.lHipPitch = null;

                /**
                 * Servos rKnee.
                 * @member {message.platform.RawSensors.IServo|null|undefined} rKnee
                 * @memberof message.platform.RawSensors.Servos
                 * @instance
                 */
                Servos.prototype.rKnee = null;

                /**
                 * Servos lKnee.
                 * @member {message.platform.RawSensors.IServo|null|undefined} lKnee
                 * @memberof message.platform.RawSensors.Servos
                 * @instance
                 */
                Servos.prototype.lKnee = null;

                /**
                 * Servos rAnklePitch.
                 * @member {message.platform.RawSensors.IServo|null|undefined} rAnklePitch
                 * @memberof message.platform.RawSensors.Servos
                 * @instance
                 */
                Servos.prototype.rAnklePitch = null;

                /**
                 * Servos lAnklePitch.
                 * @member {message.platform.RawSensors.IServo|null|undefined} lAnklePitch
                 * @memberof message.platform.RawSensors.Servos
                 * @instance
                 */
                Servos.prototype.lAnklePitch = null;

                /**
                 * Servos rAnkleRoll.
                 * @member {message.platform.RawSensors.IServo|null|undefined} rAnkleRoll
                 * @memberof message.platform.RawSensors.Servos
                 * @instance
                 */
                Servos.prototype.rAnkleRoll = null;

                /**
                 * Servos lAnkleRoll.
                 * @member {message.platform.RawSensors.IServo|null|undefined} lAnkleRoll
                 * @memberof message.platform.RawSensors.Servos
                 * @instance
                 */
                Servos.prototype.lAnkleRoll = null;

                /**
                 * Servos headPan.
                 * @member {message.platform.RawSensors.IServo|null|undefined} headPan
                 * @memberof message.platform.RawSensors.Servos
                 * @instance
                 */
                Servos.prototype.headPan = null;

                /**
                 * Servos headTilt.
                 * @member {message.platform.RawSensors.IServo|null|undefined} headTilt
                 * @memberof message.platform.RawSensors.Servos
                 * @instance
                 */
                Servos.prototype.headTilt = null;

                /**
                 * Encodes the specified Servos message. Does not implicitly {@link message.platform.RawSensors.Servos.verify|verify} messages.
                 * @function encode
                 * @memberof message.platform.RawSensors.Servos
                 * @static
                 * @param {message.platform.RawSensors.IServos} message Servos message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Servos.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.rShoulderPitch != null && Object.hasOwnProperty.call(message, "rShoulderPitch"))
                        $root.message.platform.RawSensors.Servo.encode(message.rShoulderPitch, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.lShoulderPitch != null && Object.hasOwnProperty.call(message, "lShoulderPitch"))
                        $root.message.platform.RawSensors.Servo.encode(message.lShoulderPitch, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.rShoulderRoll != null && Object.hasOwnProperty.call(message, "rShoulderRoll"))
                        $root.message.platform.RawSensors.Servo.encode(message.rShoulderRoll, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.lShoulderRoll != null && Object.hasOwnProperty.call(message, "lShoulderRoll"))
                        $root.message.platform.RawSensors.Servo.encode(message.lShoulderRoll, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.rElbow != null && Object.hasOwnProperty.call(message, "rElbow"))
                        $root.message.platform.RawSensors.Servo.encode(message.rElbow, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.lElbow != null && Object.hasOwnProperty.call(message, "lElbow"))
                        $root.message.platform.RawSensors.Servo.encode(message.lElbow, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.rHipYaw != null && Object.hasOwnProperty.call(message, "rHipYaw"))
                        $root.message.platform.RawSensors.Servo.encode(message.rHipYaw, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.lHipYaw != null && Object.hasOwnProperty.call(message, "lHipYaw"))
                        $root.message.platform.RawSensors.Servo.encode(message.lHipYaw, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.rHipRoll != null && Object.hasOwnProperty.call(message, "rHipRoll"))
                        $root.message.platform.RawSensors.Servo.encode(message.rHipRoll, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    if (message.lHipRoll != null && Object.hasOwnProperty.call(message, "lHipRoll"))
                        $root.message.platform.RawSensors.Servo.encode(message.lHipRoll, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                    if (message.rHipPitch != null && Object.hasOwnProperty.call(message, "rHipPitch"))
                        $root.message.platform.RawSensors.Servo.encode(message.rHipPitch, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                    if (message.lHipPitch != null && Object.hasOwnProperty.call(message, "lHipPitch"))
                        $root.message.platform.RawSensors.Servo.encode(message.lHipPitch, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                    if (message.rKnee != null && Object.hasOwnProperty.call(message, "rKnee"))
                        $root.message.platform.RawSensors.Servo.encode(message.rKnee, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                    if (message.lKnee != null && Object.hasOwnProperty.call(message, "lKnee"))
                        $root.message.platform.RawSensors.Servo.encode(message.lKnee, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                    if (message.rAnklePitch != null && Object.hasOwnProperty.call(message, "rAnklePitch"))
                        $root.message.platform.RawSensors.Servo.encode(message.rAnklePitch, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                    if (message.lAnklePitch != null && Object.hasOwnProperty.call(message, "lAnklePitch"))
                        $root.message.platform.RawSensors.Servo.encode(message.lAnklePitch, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
                    if (message.rAnkleRoll != null && Object.hasOwnProperty.call(message, "rAnkleRoll"))
                        $root.message.platform.RawSensors.Servo.encode(message.rAnkleRoll, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                    if (message.lAnkleRoll != null && Object.hasOwnProperty.call(message, "lAnkleRoll"))
                        $root.message.platform.RawSensors.Servo.encode(message.lAnkleRoll, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
                    if (message.headPan != null && Object.hasOwnProperty.call(message, "headPan"))
                        $root.message.platform.RawSensors.Servo.encode(message.headPan, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
                    if (message.headTilt != null && Object.hasOwnProperty.call(message, "headTilt"))
                        $root.message.platform.RawSensors.Servo.encode(message.headTilt, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
                    return writer;
                };

                /**
                 * Decodes a Servos message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.platform.RawSensors.Servos
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.platform.RawSensors.Servos} Servos
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Servos.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.platform.RawSensors.Servos();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.rShoulderPitch = $root.message.platform.RawSensors.Servo.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.lShoulderPitch = $root.message.platform.RawSensors.Servo.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.rShoulderRoll = $root.message.platform.RawSensors.Servo.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.lShoulderRoll = $root.message.platform.RawSensors.Servo.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.rElbow = $root.message.platform.RawSensors.Servo.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.lElbow = $root.message.platform.RawSensors.Servo.decode(reader, reader.uint32());
                            break;
                        case 7:
                            message.rHipYaw = $root.message.platform.RawSensors.Servo.decode(reader, reader.uint32());
                            break;
                        case 8:
                            message.lHipYaw = $root.message.platform.RawSensors.Servo.decode(reader, reader.uint32());
                            break;
                        case 9:
                            message.rHipRoll = $root.message.platform.RawSensors.Servo.decode(reader, reader.uint32());
                            break;
                        case 10:
                            message.lHipRoll = $root.message.platform.RawSensors.Servo.decode(reader, reader.uint32());
                            break;
                        case 11:
                            message.rHipPitch = $root.message.platform.RawSensors.Servo.decode(reader, reader.uint32());
                            break;
                        case 12:
                            message.lHipPitch = $root.message.platform.RawSensors.Servo.decode(reader, reader.uint32());
                            break;
                        case 13:
                            message.rKnee = $root.message.platform.RawSensors.Servo.decode(reader, reader.uint32());
                            break;
                        case 14:
                            message.lKnee = $root.message.platform.RawSensors.Servo.decode(reader, reader.uint32());
                            break;
                        case 15:
                            message.rAnklePitch = $root.message.platform.RawSensors.Servo.decode(reader, reader.uint32());
                            break;
                        case 16:
                            message.lAnklePitch = $root.message.platform.RawSensors.Servo.decode(reader, reader.uint32());
                            break;
                        case 17:
                            message.rAnkleRoll = $root.message.platform.RawSensors.Servo.decode(reader, reader.uint32());
                            break;
                        case 18:
                            message.lAnkleRoll = $root.message.platform.RawSensors.Servo.decode(reader, reader.uint32());
                            break;
                        case 19:
                            message.headPan = $root.message.platform.RawSensors.Servo.decode(reader, reader.uint32());
                            break;
                        case 20:
                            message.headTilt = $root.message.platform.RawSensors.Servo.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return Servos;
            })();

            return RawSensors;
        })();

        platform.ButtonLeftDown = (function() {

            /**
             * Properties of a ButtonLeftDown.
             * @memberof message.platform
             * @interface IButtonLeftDown
             */

            /**
             * Constructs a new ButtonLeftDown.
             * @memberof message.platform
             * @classdesc Represents a ButtonLeftDown.
             * @implements IButtonLeftDown
             * @constructor
             * @param {message.platform.IButtonLeftDown=} [properties] Properties to set
             */
            function ButtonLeftDown(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Encodes the specified ButtonLeftDown message. Does not implicitly {@link message.platform.ButtonLeftDown.verify|verify} messages.
             * @function encode
             * @memberof message.platform.ButtonLeftDown
             * @static
             * @param {message.platform.IButtonLeftDown} message ButtonLeftDown message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ButtonLeftDown.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Decodes a ButtonLeftDown message from the specified reader or buffer.
             * @function decode
             * @memberof message.platform.ButtonLeftDown
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.platform.ButtonLeftDown} ButtonLeftDown
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ButtonLeftDown.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.platform.ButtonLeftDown();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return ButtonLeftDown;
        })();

        platform.ButtonLeftUp = (function() {

            /**
             * Properties of a ButtonLeftUp.
             * @memberof message.platform
             * @interface IButtonLeftUp
             */

            /**
             * Constructs a new ButtonLeftUp.
             * @memberof message.platform
             * @classdesc Represents a ButtonLeftUp.
             * @implements IButtonLeftUp
             * @constructor
             * @param {message.platform.IButtonLeftUp=} [properties] Properties to set
             */
            function ButtonLeftUp(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Encodes the specified ButtonLeftUp message. Does not implicitly {@link message.platform.ButtonLeftUp.verify|verify} messages.
             * @function encode
             * @memberof message.platform.ButtonLeftUp
             * @static
             * @param {message.platform.IButtonLeftUp} message ButtonLeftUp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ButtonLeftUp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Decodes a ButtonLeftUp message from the specified reader or buffer.
             * @function decode
             * @memberof message.platform.ButtonLeftUp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.platform.ButtonLeftUp} ButtonLeftUp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ButtonLeftUp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.platform.ButtonLeftUp();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return ButtonLeftUp;
        })();

        platform.ButtonMiddleDown = (function() {

            /**
             * Properties of a ButtonMiddleDown.
             * @memberof message.platform
             * @interface IButtonMiddleDown
             */

            /**
             * Constructs a new ButtonMiddleDown.
             * @memberof message.platform
             * @classdesc Represents a ButtonMiddleDown.
             * @implements IButtonMiddleDown
             * @constructor
             * @param {message.platform.IButtonMiddleDown=} [properties] Properties to set
             */
            function ButtonMiddleDown(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Encodes the specified ButtonMiddleDown message. Does not implicitly {@link message.platform.ButtonMiddleDown.verify|verify} messages.
             * @function encode
             * @memberof message.platform.ButtonMiddleDown
             * @static
             * @param {message.platform.IButtonMiddleDown} message ButtonMiddleDown message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ButtonMiddleDown.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Decodes a ButtonMiddleDown message from the specified reader or buffer.
             * @function decode
             * @memberof message.platform.ButtonMiddleDown
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.platform.ButtonMiddleDown} ButtonMiddleDown
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ButtonMiddleDown.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.platform.ButtonMiddleDown();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return ButtonMiddleDown;
        })();

        platform.ButtonMiddleUp = (function() {

            /**
             * Properties of a ButtonMiddleUp.
             * @memberof message.platform
             * @interface IButtonMiddleUp
             */

            /**
             * Constructs a new ButtonMiddleUp.
             * @memberof message.platform
             * @classdesc Represents a ButtonMiddleUp.
             * @implements IButtonMiddleUp
             * @constructor
             * @param {message.platform.IButtonMiddleUp=} [properties] Properties to set
             */
            function ButtonMiddleUp(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Encodes the specified ButtonMiddleUp message. Does not implicitly {@link message.platform.ButtonMiddleUp.verify|verify} messages.
             * @function encode
             * @memberof message.platform.ButtonMiddleUp
             * @static
             * @param {message.platform.IButtonMiddleUp} message ButtonMiddleUp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ButtonMiddleUp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Decodes a ButtonMiddleUp message from the specified reader or buffer.
             * @function decode
             * @memberof message.platform.ButtonMiddleUp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.platform.ButtonMiddleUp} ButtonMiddleUp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ButtonMiddleUp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.platform.ButtonMiddleUp();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return ButtonMiddleUp;
        })();

        platform.ResetWebotsServos = (function() {

            /**
             * Properties of a ResetWebotsServos.
             * @memberof message.platform
             * @interface IResetWebotsServos
             */

            /**
             * Constructs a new ResetWebotsServos.
             * @memberof message.platform
             * @classdesc Represents a ResetWebotsServos.
             * @implements IResetWebotsServos
             * @constructor
             * @param {message.platform.IResetWebotsServos=} [properties] Properties to set
             */
            function ResetWebotsServos(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Encodes the specified ResetWebotsServos message. Does not implicitly {@link message.platform.ResetWebotsServos.verify|verify} messages.
             * @function encode
             * @memberof message.platform.ResetWebotsServos
             * @static
             * @param {message.platform.IResetWebotsServos} message ResetWebotsServos message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ResetWebotsServos.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Decodes a ResetWebotsServos message from the specified reader or buffer.
             * @function decode
             * @memberof message.platform.ResetWebotsServos
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.platform.ResetWebotsServos} ResetWebotsServos
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ResetWebotsServos.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.platform.ResetWebotsServos();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return ResetWebotsServos;
        })();

        platform.webots = (function() {

            /**
             * Namespace webots.
             * @memberof message.platform
             * @namespace
             */
            const webots = {};

            webots.Vector3 = (function() {

                /**
                 * Properties of a Vector3.
                 * @memberof message.platform.webots
                 * @interface IVector3
                 * @property {number|null} [X] Vector3 X
                 * @property {number|null} [Y] Vector3 Y
                 * @property {number|null} [Z] Vector3 Z
                 */

                /**
                 * Constructs a new Vector3.
                 * @memberof message.platform.webots
                 * @classdesc Represents a Vector3.
                 * @implements IVector3
                 * @constructor
                 * @param {message.platform.webots.IVector3=} [properties] Properties to set
                 */
                function Vector3(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Vector3 X.
                 * @member {number} X
                 * @memberof message.platform.webots.Vector3
                 * @instance
                 */
                Vector3.prototype.X = 0;

                /**
                 * Vector3 Y.
                 * @member {number} Y
                 * @memberof message.platform.webots.Vector3
                 * @instance
                 */
                Vector3.prototype.Y = 0;

                /**
                 * Vector3 Z.
                 * @member {number} Z
                 * @memberof message.platform.webots.Vector3
                 * @instance
                 */
                Vector3.prototype.Z = 0;

                /**
                 * Encodes the specified Vector3 message. Does not implicitly {@link message.platform.webots.Vector3.verify|verify} messages.
                 * @function encode
                 * @memberof message.platform.webots.Vector3
                 * @static
                 * @param {message.platform.webots.IVector3} message Vector3 message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Vector3.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.X != null && Object.hasOwnProperty.call(message, "X"))
                        writer.uint32(/* id 1, wireType 1 =*/9).double(message.X);
                    if (message.Y != null && Object.hasOwnProperty.call(message, "Y"))
                        writer.uint32(/* id 2, wireType 1 =*/17).double(message.Y);
                    if (message.Z != null && Object.hasOwnProperty.call(message, "Z"))
                        writer.uint32(/* id 3, wireType 1 =*/25).double(message.Z);
                    return writer;
                };

                /**
                 * Decodes a Vector3 message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.platform.webots.Vector3
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.platform.webots.Vector3} Vector3
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Vector3.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.platform.webots.Vector3();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.X = reader.double();
                            break;
                        case 2:
                            message.Y = reader.double();
                            break;
                        case 3:
                            message.Z = reader.double();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return Vector3;
            })();

            webots.PositionSensorMeasurement = (function() {

                /**
                 * Properties of a PositionSensorMeasurement.
                 * @memberof message.platform.webots
                 * @interface IPositionSensorMeasurement
                 * @property {string|null} [name] PositionSensorMeasurement name
                 * @property {number|null} [value] PositionSensorMeasurement value
                 */

                /**
                 * Constructs a new PositionSensorMeasurement.
                 * @memberof message.platform.webots
                 * @classdesc Represents a PositionSensorMeasurement.
                 * @implements IPositionSensorMeasurement
                 * @constructor
                 * @param {message.platform.webots.IPositionSensorMeasurement=} [properties] Properties to set
                 */
                function PositionSensorMeasurement(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * PositionSensorMeasurement name.
                 * @member {string} name
                 * @memberof message.platform.webots.PositionSensorMeasurement
                 * @instance
                 */
                PositionSensorMeasurement.prototype.name = "";

                /**
                 * PositionSensorMeasurement value.
                 * @member {number} value
                 * @memberof message.platform.webots.PositionSensorMeasurement
                 * @instance
                 */
                PositionSensorMeasurement.prototype.value = 0;

                /**
                 * Encodes the specified PositionSensorMeasurement message. Does not implicitly {@link message.platform.webots.PositionSensorMeasurement.verify|verify} messages.
                 * @function encode
                 * @memberof message.platform.webots.PositionSensorMeasurement
                 * @static
                 * @param {message.platform.webots.IPositionSensorMeasurement} message PositionSensorMeasurement message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PositionSensorMeasurement.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        writer.uint32(/* id 2, wireType 1 =*/17).double(message.value);
                    return writer;
                };

                /**
                 * Decodes a PositionSensorMeasurement message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.platform.webots.PositionSensorMeasurement
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.platform.webots.PositionSensorMeasurement} PositionSensorMeasurement
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PositionSensorMeasurement.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.platform.webots.PositionSensorMeasurement();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.value = reader.double();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return PositionSensorMeasurement;
            })();

            webots.AccelerometerMeasurement = (function() {

                /**
                 * Properties of an AccelerometerMeasurement.
                 * @memberof message.platform.webots
                 * @interface IAccelerometerMeasurement
                 * @property {string|null} [name] AccelerometerMeasurement name
                 * @property {message.platform.webots.IVector3|null} [value] AccelerometerMeasurement value
                 */

                /**
                 * Constructs a new AccelerometerMeasurement.
                 * @memberof message.platform.webots
                 * @classdesc Represents an AccelerometerMeasurement.
                 * @implements IAccelerometerMeasurement
                 * @constructor
                 * @param {message.platform.webots.IAccelerometerMeasurement=} [properties] Properties to set
                 */
                function AccelerometerMeasurement(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * AccelerometerMeasurement name.
                 * @member {string} name
                 * @memberof message.platform.webots.AccelerometerMeasurement
                 * @instance
                 */
                AccelerometerMeasurement.prototype.name = "";

                /**
                 * AccelerometerMeasurement value.
                 * @member {message.platform.webots.IVector3|null|undefined} value
                 * @memberof message.platform.webots.AccelerometerMeasurement
                 * @instance
                 */
                AccelerometerMeasurement.prototype.value = null;

                /**
                 * Encodes the specified AccelerometerMeasurement message. Does not implicitly {@link message.platform.webots.AccelerometerMeasurement.verify|verify} messages.
                 * @function encode
                 * @memberof message.platform.webots.AccelerometerMeasurement
                 * @static
                 * @param {message.platform.webots.IAccelerometerMeasurement} message AccelerometerMeasurement message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AccelerometerMeasurement.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        $root.message.platform.webots.Vector3.encode(message.value, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Decodes an AccelerometerMeasurement message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.platform.webots.AccelerometerMeasurement
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.platform.webots.AccelerometerMeasurement} AccelerometerMeasurement
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AccelerometerMeasurement.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.platform.webots.AccelerometerMeasurement();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.value = $root.message.platform.webots.Vector3.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return AccelerometerMeasurement;
            })();

            webots.GyroMeasurement = (function() {

                /**
                 * Properties of a GyroMeasurement.
                 * @memberof message.platform.webots
                 * @interface IGyroMeasurement
                 * @property {string|null} [name] GyroMeasurement name
                 * @property {message.platform.webots.IVector3|null} [value] GyroMeasurement value
                 */

                /**
                 * Constructs a new GyroMeasurement.
                 * @memberof message.platform.webots
                 * @classdesc Represents a GyroMeasurement.
                 * @implements IGyroMeasurement
                 * @constructor
                 * @param {message.platform.webots.IGyroMeasurement=} [properties] Properties to set
                 */
                function GyroMeasurement(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * GyroMeasurement name.
                 * @member {string} name
                 * @memberof message.platform.webots.GyroMeasurement
                 * @instance
                 */
                GyroMeasurement.prototype.name = "";

                /**
                 * GyroMeasurement value.
                 * @member {message.platform.webots.IVector3|null|undefined} value
                 * @memberof message.platform.webots.GyroMeasurement
                 * @instance
                 */
                GyroMeasurement.prototype.value = null;

                /**
                 * Encodes the specified GyroMeasurement message. Does not implicitly {@link message.platform.webots.GyroMeasurement.verify|verify} messages.
                 * @function encode
                 * @memberof message.platform.webots.GyroMeasurement
                 * @static
                 * @param {message.platform.webots.IGyroMeasurement} message GyroMeasurement message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GyroMeasurement.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        $root.message.platform.webots.Vector3.encode(message.value, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Decodes a GyroMeasurement message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.platform.webots.GyroMeasurement
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.platform.webots.GyroMeasurement} GyroMeasurement
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GyroMeasurement.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.platform.webots.GyroMeasurement();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.value = $root.message.platform.webots.Vector3.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return GyroMeasurement;
            })();

            webots.BumperMeasurement = (function() {

                /**
                 * Properties of a BumperMeasurement.
                 * @memberof message.platform.webots
                 * @interface IBumperMeasurement
                 * @property {string|null} [name] BumperMeasurement name
                 * @property {boolean|null} [value] BumperMeasurement value
                 */

                /**
                 * Constructs a new BumperMeasurement.
                 * @memberof message.platform.webots
                 * @classdesc Represents a BumperMeasurement.
                 * @implements IBumperMeasurement
                 * @constructor
                 * @param {message.platform.webots.IBumperMeasurement=} [properties] Properties to set
                 */
                function BumperMeasurement(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * BumperMeasurement name.
                 * @member {string} name
                 * @memberof message.platform.webots.BumperMeasurement
                 * @instance
                 */
                BumperMeasurement.prototype.name = "";

                /**
                 * BumperMeasurement value.
                 * @member {boolean} value
                 * @memberof message.platform.webots.BumperMeasurement
                 * @instance
                 */
                BumperMeasurement.prototype.value = false;

                /**
                 * Encodes the specified BumperMeasurement message. Does not implicitly {@link message.platform.webots.BumperMeasurement.verify|verify} messages.
                 * @function encode
                 * @memberof message.platform.webots.BumperMeasurement
                 * @static
                 * @param {message.platform.webots.IBumperMeasurement} message BumperMeasurement message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BumperMeasurement.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.value);
                    return writer;
                };

                /**
                 * Decodes a BumperMeasurement message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.platform.webots.BumperMeasurement
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.platform.webots.BumperMeasurement} BumperMeasurement
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BumperMeasurement.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.platform.webots.BumperMeasurement();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.value = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return BumperMeasurement;
            })();

            webots.ForceMeasurement = (function() {

                /**
                 * Properties of a ForceMeasurement.
                 * @memberof message.platform.webots
                 * @interface IForceMeasurement
                 * @property {string|null} [name] ForceMeasurement name
                 * @property {number|null} [value] ForceMeasurement value
                 */

                /**
                 * Constructs a new ForceMeasurement.
                 * @memberof message.platform.webots
                 * @classdesc Represents a ForceMeasurement.
                 * @implements IForceMeasurement
                 * @constructor
                 * @param {message.platform.webots.IForceMeasurement=} [properties] Properties to set
                 */
                function ForceMeasurement(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ForceMeasurement name.
                 * @member {string} name
                 * @memberof message.platform.webots.ForceMeasurement
                 * @instance
                 */
                ForceMeasurement.prototype.name = "";

                /**
                 * ForceMeasurement value.
                 * @member {number} value
                 * @memberof message.platform.webots.ForceMeasurement
                 * @instance
                 */
                ForceMeasurement.prototype.value = 0;

                /**
                 * Encodes the specified ForceMeasurement message. Does not implicitly {@link message.platform.webots.ForceMeasurement.verify|verify} messages.
                 * @function encode
                 * @memberof message.platform.webots.ForceMeasurement
                 * @static
                 * @param {message.platform.webots.IForceMeasurement} message ForceMeasurement message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ForceMeasurement.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        writer.uint32(/* id 2, wireType 1 =*/17).double(message.value);
                    return writer;
                };

                /**
                 * Decodes a ForceMeasurement message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.platform.webots.ForceMeasurement
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.platform.webots.ForceMeasurement} ForceMeasurement
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ForceMeasurement.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.platform.webots.ForceMeasurement();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.value = reader.double();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return ForceMeasurement;
            })();

            webots.Force3DMeasurement = (function() {

                /**
                 * Properties of a Force3DMeasurement.
                 * @memberof message.platform.webots
                 * @interface IForce3DMeasurement
                 * @property {string|null} [name] Force3DMeasurement name
                 * @property {message.platform.webots.IVector3|null} [value] Force3DMeasurement value
                 */

                /**
                 * Constructs a new Force3DMeasurement.
                 * @memberof message.platform.webots
                 * @classdesc Represents a Force3DMeasurement.
                 * @implements IForce3DMeasurement
                 * @constructor
                 * @param {message.platform.webots.IForce3DMeasurement=} [properties] Properties to set
                 */
                function Force3DMeasurement(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Force3DMeasurement name.
                 * @member {string} name
                 * @memberof message.platform.webots.Force3DMeasurement
                 * @instance
                 */
                Force3DMeasurement.prototype.name = "";

                /**
                 * Force3DMeasurement value.
                 * @member {message.platform.webots.IVector3|null|undefined} value
                 * @memberof message.platform.webots.Force3DMeasurement
                 * @instance
                 */
                Force3DMeasurement.prototype.value = null;

                /**
                 * Encodes the specified Force3DMeasurement message. Does not implicitly {@link message.platform.webots.Force3DMeasurement.verify|verify} messages.
                 * @function encode
                 * @memberof message.platform.webots.Force3DMeasurement
                 * @static
                 * @param {message.platform.webots.IForce3DMeasurement} message Force3DMeasurement message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Force3DMeasurement.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        $root.message.platform.webots.Vector3.encode(message.value, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Decodes a Force3DMeasurement message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.platform.webots.Force3DMeasurement
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.platform.webots.Force3DMeasurement} Force3DMeasurement
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Force3DMeasurement.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.platform.webots.Force3DMeasurement();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.value = $root.message.platform.webots.Vector3.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return Force3DMeasurement;
            })();

            webots.Force6DMeasurement = (function() {

                /**
                 * Properties of a Force6DMeasurement.
                 * @memberof message.platform.webots
                 * @interface IForce6DMeasurement
                 * @property {string|null} [name] Force6DMeasurement name
                 * @property {message.platform.webots.IVector3|null} [force] Force6DMeasurement force
                 * @property {message.platform.webots.IVector3|null} [torque] Force6DMeasurement torque
                 */

                /**
                 * Constructs a new Force6DMeasurement.
                 * @memberof message.platform.webots
                 * @classdesc Represents a Force6DMeasurement.
                 * @implements IForce6DMeasurement
                 * @constructor
                 * @param {message.platform.webots.IForce6DMeasurement=} [properties] Properties to set
                 */
                function Force6DMeasurement(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Force6DMeasurement name.
                 * @member {string} name
                 * @memberof message.platform.webots.Force6DMeasurement
                 * @instance
                 */
                Force6DMeasurement.prototype.name = "";

                /**
                 * Force6DMeasurement force.
                 * @member {message.platform.webots.IVector3|null|undefined} force
                 * @memberof message.platform.webots.Force6DMeasurement
                 * @instance
                 */
                Force6DMeasurement.prototype.force = null;

                /**
                 * Force6DMeasurement torque.
                 * @member {message.platform.webots.IVector3|null|undefined} torque
                 * @memberof message.platform.webots.Force6DMeasurement
                 * @instance
                 */
                Force6DMeasurement.prototype.torque = null;

                /**
                 * Encodes the specified Force6DMeasurement message. Does not implicitly {@link message.platform.webots.Force6DMeasurement.verify|verify} messages.
                 * @function encode
                 * @memberof message.platform.webots.Force6DMeasurement
                 * @static
                 * @param {message.platform.webots.IForce6DMeasurement} message Force6DMeasurement message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Force6DMeasurement.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.force != null && Object.hasOwnProperty.call(message, "force"))
                        $root.message.platform.webots.Vector3.encode(message.force, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.torque != null && Object.hasOwnProperty.call(message, "torque"))
                        $root.message.platform.webots.Vector3.encode(message.torque, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Decodes a Force6DMeasurement message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.platform.webots.Force6DMeasurement
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.platform.webots.Force6DMeasurement} Force6DMeasurement
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Force6DMeasurement.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.platform.webots.Force6DMeasurement();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.force = $root.message.platform.webots.Vector3.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.torque = $root.message.platform.webots.Vector3.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return Force6DMeasurement;
            })();

            webots.CameraMeasurement = (function() {

                /**
                 * Properties of a CameraMeasurement.
                 * @memberof message.platform.webots
                 * @interface ICameraMeasurement
                 * @property {string|null} [name] CameraMeasurement name
                 * @property {number|null} [width] CameraMeasurement width
                 * @property {number|null} [height] CameraMeasurement height
                 * @property {number|null} [quality] CameraMeasurement quality
                 * @property {Uint8Array|null} [image] CameraMeasurement image
                 */

                /**
                 * Constructs a new CameraMeasurement.
                 * @memberof message.platform.webots
                 * @classdesc Represents a CameraMeasurement.
                 * @implements ICameraMeasurement
                 * @constructor
                 * @param {message.platform.webots.ICameraMeasurement=} [properties] Properties to set
                 */
                function CameraMeasurement(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CameraMeasurement name.
                 * @member {string} name
                 * @memberof message.platform.webots.CameraMeasurement
                 * @instance
                 */
                CameraMeasurement.prototype.name = "";

                /**
                 * CameraMeasurement width.
                 * @member {number} width
                 * @memberof message.platform.webots.CameraMeasurement
                 * @instance
                 */
                CameraMeasurement.prototype.width = 0;

                /**
                 * CameraMeasurement height.
                 * @member {number} height
                 * @memberof message.platform.webots.CameraMeasurement
                 * @instance
                 */
                CameraMeasurement.prototype.height = 0;

                /**
                 * CameraMeasurement quality.
                 * @member {number} quality
                 * @memberof message.platform.webots.CameraMeasurement
                 * @instance
                 */
                CameraMeasurement.prototype.quality = 0;

                /**
                 * CameraMeasurement image.
                 * @member {Uint8Array} image
                 * @memberof message.platform.webots.CameraMeasurement
                 * @instance
                 */
                CameraMeasurement.prototype.image = $util.newBuffer([]);

                /**
                 * Encodes the specified CameraMeasurement message. Does not implicitly {@link message.platform.webots.CameraMeasurement.verify|verify} messages.
                 * @function encode
                 * @memberof message.platform.webots.CameraMeasurement
                 * @static
                 * @param {message.platform.webots.ICameraMeasurement} message CameraMeasurement message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CameraMeasurement.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.width != null && Object.hasOwnProperty.call(message, "width"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.width);
                    if (message.height != null && Object.hasOwnProperty.call(message, "height"))
                        writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.height);
                    if (message.quality != null && Object.hasOwnProperty.call(message, "quality"))
                        writer.uint32(/* id 4, wireType 0 =*/32).sint32(message.quality);
                    if (message.image != null && Object.hasOwnProperty.call(message, "image"))
                        writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.image);
                    return writer;
                };

                /**
                 * Decodes a CameraMeasurement message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.platform.webots.CameraMeasurement
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.platform.webots.CameraMeasurement} CameraMeasurement
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CameraMeasurement.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.platform.webots.CameraMeasurement();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.width = reader.uint32();
                            break;
                        case 3:
                            message.height = reader.uint32();
                            break;
                        case 4:
                            message.quality = reader.sint32();
                            break;
                        case 5:
                            message.image = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return CameraMeasurement;
            })();

            webots.Message = (function() {

                /**
                 * Properties of a Message.
                 * @memberof message.platform.webots
                 * @interface IMessage
                 * @property {message.platform.webots.Message.MessageType|null} [messageType] Message messageType
                 * @property {string|null} [text] Message text
                 */

                /**
                 * Constructs a new Message.
                 * @memberof message.platform.webots
                 * @classdesc Represents a Message.
                 * @implements IMessage
                 * @constructor
                 * @param {message.platform.webots.IMessage=} [properties] Properties to set
                 */
                function Message(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Message messageType.
                 * @member {message.platform.webots.Message.MessageType} messageType
                 * @memberof message.platform.webots.Message
                 * @instance
                 */
                Message.prototype.messageType = 0;

                /**
                 * Message text.
                 * @member {string} text
                 * @memberof message.platform.webots.Message
                 * @instance
                 */
                Message.prototype.text = "";

                /**
                 * Encodes the specified Message message. Does not implicitly {@link message.platform.webots.Message.verify|verify} messages.
                 * @function encode
                 * @memberof message.platform.webots.Message
                 * @static
                 * @param {message.platform.webots.IMessage} message Message message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Message.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.messageType != null && Object.hasOwnProperty.call(message, "messageType"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.messageType);
                    if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.text);
                    return writer;
                };

                /**
                 * Decodes a Message message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.platform.webots.Message
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.platform.webots.Message} Message
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Message.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.platform.webots.Message();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.messageType = reader.int32();
                            break;
                        case 2:
                            message.text = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * MessageType enum.
                 * @name message.platform.webots.Message.MessageType
                 * @enum {number}
                 * @property {number} ERROR_MESSAGE=0 ERROR_MESSAGE value
                 * @property {number} WARNING_MESSAGE=1 WARNING_MESSAGE value
                 */
                Message.MessageType = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "ERROR_MESSAGE"] = 0;
                    values[valuesById[1] = "WARNING_MESSAGE"] = 1;
                    return values;
                })();

                return Message;
            })();

            webots.OdometryGroundTruth = (function() {

                /**
                 * Properties of an OdometryGroundTruth.
                 * @memberof message.platform.webots
                 * @interface IOdometryGroundTruth
                 * @property {boolean|null} [exists] Indicates if this message exists
                 * @property {Imat4|null} [Htw] It measures the world in robot space
                 */

                /**
                 * Constructs a new OdometryGroundTruth.
                 * @memberof message.platform.webots
                 * @classdesc NUbots specific data sent from our own controllers rather than the official RoboCup Webots controller
                 * @implements IOdometryGroundTruth
                 * @constructor
                 * @param {message.platform.webots.IOdometryGroundTruth=} [properties] Properties to set
                 */
                function OdometryGroundTruth(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Indicates if this message exists
                 * @member {boolean} exists
                 * @memberof message.platform.webots.OdometryGroundTruth
                 * @instance
                 */
                OdometryGroundTruth.prototype.exists = false;

                /**
                 * It measures the world in robot space
                 * @member {Imat4|null|undefined} Htw
                 * @memberof message.platform.webots.OdometryGroundTruth
                 * @instance
                 */
                OdometryGroundTruth.prototype.Htw = null;

                /**
                 * Encodes the specified OdometryGroundTruth message. Does not implicitly {@link message.platform.webots.OdometryGroundTruth.verify|verify} messages.
                 * @function encode
                 * @memberof message.platform.webots.OdometryGroundTruth
                 * @static
                 * @param {message.platform.webots.IOdometryGroundTruth} message OdometryGroundTruth message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                OdometryGroundTruth.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.exists != null && Object.hasOwnProperty.call(message, "exists"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.exists);
                    if (message.Htw != null && Object.hasOwnProperty.call(message, "Htw"))
                        $root.mat4.encode(message.Htw, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Decodes an OdometryGroundTruth message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.platform.webots.OdometryGroundTruth
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.platform.webots.OdometryGroundTruth} OdometryGroundTruth
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                OdometryGroundTruth.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.platform.webots.OdometryGroundTruth();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.exists = reader.bool();
                            break;
                        case 2:
                            message.Htw = $root.mat4.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return OdometryGroundTruth;
            })();

            webots.VisionGroundTruth = (function() {

                /**
                 * Properties of a VisionGroundTruth.
                 * @memberof message.platform.webots
                 * @interface IVisionGroundTruth
                 * @property {boolean|null} [exists] Indicates if this message exists
                 * @property {Ifvec3|null} [rBWw] Vector from the world to the ball in world space.
                 */

                /**
                 * Constructs a new VisionGroundTruth.
                 * @memberof message.platform.webots
                 * @classdesc Represents a VisionGroundTruth.
                 * @implements IVisionGroundTruth
                 * @constructor
                 * @param {message.platform.webots.IVisionGroundTruth=} [properties] Properties to set
                 */
                function VisionGroundTruth(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Indicates if this message exists
                 * @member {boolean} exists
                 * @memberof message.platform.webots.VisionGroundTruth
                 * @instance
                 */
                VisionGroundTruth.prototype.exists = false;

                /**
                 * Vector from the world to the ball in world space.
                 * @member {Ifvec3|null|undefined} rBWw
                 * @memberof message.platform.webots.VisionGroundTruth
                 * @instance
                 */
                VisionGroundTruth.prototype.rBWw = null;

                /**
                 * Encodes the specified VisionGroundTruth message. Does not implicitly {@link message.platform.webots.VisionGroundTruth.verify|verify} messages.
                 * @function encode
                 * @memberof message.platform.webots.VisionGroundTruth
                 * @static
                 * @param {message.platform.webots.IVisionGroundTruth} message VisionGroundTruth message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                VisionGroundTruth.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.exists != null && Object.hasOwnProperty.call(message, "exists"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.exists);
                    if (message.rBWw != null && Object.hasOwnProperty.call(message, "rBWw"))
                        $root.fvec3.encode(message.rBWw, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Decodes a VisionGroundTruth message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.platform.webots.VisionGroundTruth
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.platform.webots.VisionGroundTruth} VisionGroundTruth
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                VisionGroundTruth.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.platform.webots.VisionGroundTruth();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.exists = reader.bool();
                            break;
                        case 2:
                            message.rBWw = $root.fvec3.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return VisionGroundTruth;
            })();

            webots.SensorMeasurements = (function() {

                /**
                 * Properties of a SensorMeasurements.
                 * @memberof message.platform.webots
                 * @interface ISensorMeasurements
                 * @property {number|null} [time] SensorMeasurements time
                 * @property {number|Long|null} [realTime] SensorMeasurements realTime
                 * @property {Array.<message.platform.webots.IMessage>|null} [messages] SensorMeasurements messages
                 * @property {Array.<message.platform.webots.IAccelerometerMeasurement>|null} [accelerometers] SensorMeasurements accelerometers
                 * @property {Array.<message.platform.webots.IBumperMeasurement>|null} [bumpers] SensorMeasurements bumpers
                 * @property {Array.<message.platform.webots.ICameraMeasurement>|null} [cameras] SensorMeasurements cameras
                 * @property {Array.<message.platform.webots.IForceMeasurement>|null} [forces] SensorMeasurements forces
                 * @property {Array.<message.platform.webots.IForce3DMeasurement>|null} [force3ds] SensorMeasurements force3ds
                 * @property {Array.<message.platform.webots.IForce6DMeasurement>|null} [force6ds] SensorMeasurements force6ds
                 * @property {Array.<message.platform.webots.IGyroMeasurement>|null} [gyros] SensorMeasurements gyros
                 * @property {Array.<message.platform.webots.IPositionSensorMeasurement>|null} [positionSensors] SensorMeasurements positionSensors
                 * @property {message.platform.webots.IOdometryGroundTruth|null} [odometryGroundTruth] SensorMeasurements odometryGroundTruth
                 * @property {message.platform.webots.IVisionGroundTruth|null} [visionGroundTruth] SensorMeasurements visionGroundTruth
                 */

                /**
                 * Constructs a new SensorMeasurements.
                 * @memberof message.platform.webots
                 * @classdesc Represents a SensorMeasurements.
                 * @implements ISensorMeasurements
                 * @constructor
                 * @param {message.platform.webots.ISensorMeasurements=} [properties] Properties to set
                 */
                function SensorMeasurements(properties) {
                    this.messages = [];
                    this.accelerometers = [];
                    this.bumpers = [];
                    this.cameras = [];
                    this.forces = [];
                    this.force3ds = [];
                    this.force6ds = [];
                    this.gyros = [];
                    this.positionSensors = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SensorMeasurements time.
                 * @member {number} time
                 * @memberof message.platform.webots.SensorMeasurements
                 * @instance
                 */
                SensorMeasurements.prototype.time = 0;

                /**
                 * SensorMeasurements realTime.
                 * @member {number|Long} realTime
                 * @memberof message.platform.webots.SensorMeasurements
                 * @instance
                 */
                SensorMeasurements.prototype.realTime = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * SensorMeasurements messages.
                 * @member {Array.<message.platform.webots.IMessage>} messages
                 * @memberof message.platform.webots.SensorMeasurements
                 * @instance
                 */
                SensorMeasurements.prototype.messages = $util.emptyArray;

                /**
                 * SensorMeasurements accelerometers.
                 * @member {Array.<message.platform.webots.IAccelerometerMeasurement>} accelerometers
                 * @memberof message.platform.webots.SensorMeasurements
                 * @instance
                 */
                SensorMeasurements.prototype.accelerometers = $util.emptyArray;

                /**
                 * SensorMeasurements bumpers.
                 * @member {Array.<message.platform.webots.IBumperMeasurement>} bumpers
                 * @memberof message.platform.webots.SensorMeasurements
                 * @instance
                 */
                SensorMeasurements.prototype.bumpers = $util.emptyArray;

                /**
                 * SensorMeasurements cameras.
                 * @member {Array.<message.platform.webots.ICameraMeasurement>} cameras
                 * @memberof message.platform.webots.SensorMeasurements
                 * @instance
                 */
                SensorMeasurements.prototype.cameras = $util.emptyArray;

                /**
                 * SensorMeasurements forces.
                 * @member {Array.<message.platform.webots.IForceMeasurement>} forces
                 * @memberof message.platform.webots.SensorMeasurements
                 * @instance
                 */
                SensorMeasurements.prototype.forces = $util.emptyArray;

                /**
                 * SensorMeasurements force3ds.
                 * @member {Array.<message.platform.webots.IForce3DMeasurement>} force3ds
                 * @memberof message.platform.webots.SensorMeasurements
                 * @instance
                 */
                SensorMeasurements.prototype.force3ds = $util.emptyArray;

                /**
                 * SensorMeasurements force6ds.
                 * @member {Array.<message.platform.webots.IForce6DMeasurement>} force6ds
                 * @memberof message.platform.webots.SensorMeasurements
                 * @instance
                 */
                SensorMeasurements.prototype.force6ds = $util.emptyArray;

                /**
                 * SensorMeasurements gyros.
                 * @member {Array.<message.platform.webots.IGyroMeasurement>} gyros
                 * @memberof message.platform.webots.SensorMeasurements
                 * @instance
                 */
                SensorMeasurements.prototype.gyros = $util.emptyArray;

                /**
                 * SensorMeasurements positionSensors.
                 * @member {Array.<message.platform.webots.IPositionSensorMeasurement>} positionSensors
                 * @memberof message.platform.webots.SensorMeasurements
                 * @instance
                 */
                SensorMeasurements.prototype.positionSensors = $util.emptyArray;

                /**
                 * SensorMeasurements odometryGroundTruth.
                 * @member {message.platform.webots.IOdometryGroundTruth|null|undefined} odometryGroundTruth
                 * @memberof message.platform.webots.SensorMeasurements
                 * @instance
                 */
                SensorMeasurements.prototype.odometryGroundTruth = null;

                /**
                 * SensorMeasurements visionGroundTruth.
                 * @member {message.platform.webots.IVisionGroundTruth|null|undefined} visionGroundTruth
                 * @memberof message.platform.webots.SensorMeasurements
                 * @instance
                 */
                SensorMeasurements.prototype.visionGroundTruth = null;

                /**
                 * Encodes the specified SensorMeasurements message. Does not implicitly {@link message.platform.webots.SensorMeasurements.verify|verify} messages.
                 * @function encode
                 * @memberof message.platform.webots.SensorMeasurements
                 * @static
                 * @param {message.platform.webots.ISensorMeasurements} message SensorMeasurements message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SensorMeasurements.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.time);
                    if (message.realTime != null && Object.hasOwnProperty.call(message, "realTime"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.realTime);
                    if (message.messages != null && message.messages.length)
                        for (let i = 0; i < message.messages.length; ++i)
                            $root.message.platform.webots.Message.encode(message.messages[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.accelerometers != null && message.accelerometers.length)
                        for (let i = 0; i < message.accelerometers.length; ++i)
                            $root.message.platform.webots.AccelerometerMeasurement.encode(message.accelerometers[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.bumpers != null && message.bumpers.length)
                        for (let i = 0; i < message.bumpers.length; ++i)
                            $root.message.platform.webots.BumperMeasurement.encode(message.bumpers[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.cameras != null && message.cameras.length)
                        for (let i = 0; i < message.cameras.length; ++i)
                            $root.message.platform.webots.CameraMeasurement.encode(message.cameras[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.forces != null && message.forces.length)
                        for (let i = 0; i < message.forces.length; ++i)
                            $root.message.platform.webots.ForceMeasurement.encode(message.forces[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.force3ds != null && message.force3ds.length)
                        for (let i = 0; i < message.force3ds.length; ++i)
                            $root.message.platform.webots.Force3DMeasurement.encode(message.force3ds[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.force6ds != null && message.force6ds.length)
                        for (let i = 0; i < message.force6ds.length; ++i)
                            $root.message.platform.webots.Force6DMeasurement.encode(message.force6ds[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    if (message.gyros != null && message.gyros.length)
                        for (let i = 0; i < message.gyros.length; ++i)
                            $root.message.platform.webots.GyroMeasurement.encode(message.gyros[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                    if (message.positionSensors != null && message.positionSensors.length)
                        for (let i = 0; i < message.positionSensors.length; ++i)
                            $root.message.platform.webots.PositionSensorMeasurement.encode(message.positionSensors[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                    if (message.odometryGroundTruth != null && Object.hasOwnProperty.call(message, "odometryGroundTruth"))
                        $root.message.platform.webots.OdometryGroundTruth.encode(message.odometryGroundTruth, writer.uint32(/* id 100, wireType 2 =*/802).fork()).ldelim();
                    if (message.visionGroundTruth != null && Object.hasOwnProperty.call(message, "visionGroundTruth"))
                        $root.message.platform.webots.VisionGroundTruth.encode(message.visionGroundTruth, writer.uint32(/* id 101, wireType 2 =*/810).fork()).ldelim();
                    return writer;
                };

                /**
                 * Decodes a SensorMeasurements message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.platform.webots.SensorMeasurements
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.platform.webots.SensorMeasurements} SensorMeasurements
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SensorMeasurements.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.platform.webots.SensorMeasurements();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.time = reader.uint32();
                            break;
                        case 2:
                            message.realTime = reader.uint64();
                            break;
                        case 3:
                            if (!(message.messages && message.messages.length))
                                message.messages = [];
                            message.messages.push($root.message.platform.webots.Message.decode(reader, reader.uint32()));
                            break;
                        case 4:
                            if (!(message.accelerometers && message.accelerometers.length))
                                message.accelerometers = [];
                            message.accelerometers.push($root.message.platform.webots.AccelerometerMeasurement.decode(reader, reader.uint32()));
                            break;
                        case 5:
                            if (!(message.bumpers && message.bumpers.length))
                                message.bumpers = [];
                            message.bumpers.push($root.message.platform.webots.BumperMeasurement.decode(reader, reader.uint32()));
                            break;
                        case 6:
                            if (!(message.cameras && message.cameras.length))
                                message.cameras = [];
                            message.cameras.push($root.message.platform.webots.CameraMeasurement.decode(reader, reader.uint32()));
                            break;
                        case 7:
                            if (!(message.forces && message.forces.length))
                                message.forces = [];
                            message.forces.push($root.message.platform.webots.ForceMeasurement.decode(reader, reader.uint32()));
                            break;
                        case 8:
                            if (!(message.force3ds && message.force3ds.length))
                                message.force3ds = [];
                            message.force3ds.push($root.message.platform.webots.Force3DMeasurement.decode(reader, reader.uint32()));
                            break;
                        case 9:
                            if (!(message.force6ds && message.force6ds.length))
                                message.force6ds = [];
                            message.force6ds.push($root.message.platform.webots.Force6DMeasurement.decode(reader, reader.uint32()));
                            break;
                        case 10:
                            if (!(message.gyros && message.gyros.length))
                                message.gyros = [];
                            message.gyros.push($root.message.platform.webots.GyroMeasurement.decode(reader, reader.uint32()));
                            break;
                        case 11:
                            if (!(message.positionSensors && message.positionSensors.length))
                                message.positionSensors = [];
                            message.positionSensors.push($root.message.platform.webots.PositionSensorMeasurement.decode(reader, reader.uint32()));
                            break;
                        case 100:
                            message.odometryGroundTruth = $root.message.platform.webots.OdometryGroundTruth.decode(reader, reader.uint32());
                            break;
                        case 101:
                            message.visionGroundTruth = $root.message.platform.webots.VisionGroundTruth.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return SensorMeasurements;
            })();

            webots.MotorPosition = (function() {

                /**
                 * Properties of a MotorPosition.
                 * @memberof message.platform.webots
                 * @interface IMotorPosition
                 * @property {string|null} [name] MotorPosition name
                 * @property {number|null} [position] MotorPosition position
                 */

                /**
                 * Constructs a new MotorPosition.
                 * @memberof message.platform.webots
                 * @classdesc Represents a MotorPosition.
                 * @implements IMotorPosition
                 * @constructor
                 * @param {message.platform.webots.IMotorPosition=} [properties] Properties to set
                 */
                function MotorPosition(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MotorPosition name.
                 * @member {string} name
                 * @memberof message.platform.webots.MotorPosition
                 * @instance
                 */
                MotorPosition.prototype.name = "";

                /**
                 * MotorPosition position.
                 * @member {number} position
                 * @memberof message.platform.webots.MotorPosition
                 * @instance
                 */
                MotorPosition.prototype.position = 0;

                /**
                 * Encodes the specified MotorPosition message. Does not implicitly {@link message.platform.webots.MotorPosition.verify|verify} messages.
                 * @function encode
                 * @memberof message.platform.webots.MotorPosition
                 * @static
                 * @param {message.platform.webots.IMotorPosition} message MotorPosition message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MotorPosition.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                        writer.uint32(/* id 2, wireType 1 =*/17).double(message.position);
                    return writer;
                };

                /**
                 * Decodes a MotorPosition message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.platform.webots.MotorPosition
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.platform.webots.MotorPosition} MotorPosition
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MotorPosition.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.platform.webots.MotorPosition();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.position = reader.double();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return MotorPosition;
            })();

            webots.MotorVelocity = (function() {

                /**
                 * Properties of a MotorVelocity.
                 * @memberof message.platform.webots
                 * @interface IMotorVelocity
                 * @property {string|null} [name] MotorVelocity name
                 * @property {number|null} [velocity] MotorVelocity velocity
                 */

                /**
                 * Constructs a new MotorVelocity.
                 * @memberof message.platform.webots
                 * @classdesc Represents a MotorVelocity.
                 * @implements IMotorVelocity
                 * @constructor
                 * @param {message.platform.webots.IMotorVelocity=} [properties] Properties to set
                 */
                function MotorVelocity(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MotorVelocity name.
                 * @member {string} name
                 * @memberof message.platform.webots.MotorVelocity
                 * @instance
                 */
                MotorVelocity.prototype.name = "";

                /**
                 * MotorVelocity velocity.
                 * @member {number} velocity
                 * @memberof message.platform.webots.MotorVelocity
                 * @instance
                 */
                MotorVelocity.prototype.velocity = 0;

                /**
                 * Encodes the specified MotorVelocity message. Does not implicitly {@link message.platform.webots.MotorVelocity.verify|verify} messages.
                 * @function encode
                 * @memberof message.platform.webots.MotorVelocity
                 * @static
                 * @param {message.platform.webots.IMotorVelocity} message MotorVelocity message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MotorVelocity.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.velocity != null && Object.hasOwnProperty.call(message, "velocity"))
                        writer.uint32(/* id 2, wireType 1 =*/17).double(message.velocity);
                    return writer;
                };

                /**
                 * Decodes a MotorVelocity message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.platform.webots.MotorVelocity
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.platform.webots.MotorVelocity} MotorVelocity
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MotorVelocity.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.platform.webots.MotorVelocity();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.velocity = reader.double();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return MotorVelocity;
            })();

            webots.MotorForce = (function() {

                /**
                 * Properties of a MotorForce.
                 * @memberof message.platform.webots
                 * @interface IMotorForce
                 * @property {string|null} [name] MotorForce name
                 * @property {number|null} [force] MotorForce force
                 */

                /**
                 * Constructs a new MotorForce.
                 * @memberof message.platform.webots
                 * @classdesc Represents a MotorForce.
                 * @implements IMotorForce
                 * @constructor
                 * @param {message.platform.webots.IMotorForce=} [properties] Properties to set
                 */
                function MotorForce(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MotorForce name.
                 * @member {string} name
                 * @memberof message.platform.webots.MotorForce
                 * @instance
                 */
                MotorForce.prototype.name = "";

                /**
                 * MotorForce force.
                 * @member {number} force
                 * @memberof message.platform.webots.MotorForce
                 * @instance
                 */
                MotorForce.prototype.force = 0;

                /**
                 * Encodes the specified MotorForce message. Does not implicitly {@link message.platform.webots.MotorForce.verify|verify} messages.
                 * @function encode
                 * @memberof message.platform.webots.MotorForce
                 * @static
                 * @param {message.platform.webots.IMotorForce} message MotorForce message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MotorForce.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.force != null && Object.hasOwnProperty.call(message, "force"))
                        writer.uint32(/* id 2, wireType 1 =*/17).double(message.force);
                    return writer;
                };

                /**
                 * Decodes a MotorForce message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.platform.webots.MotorForce
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.platform.webots.MotorForce} MotorForce
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MotorForce.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.platform.webots.MotorForce();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.force = reader.double();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return MotorForce;
            })();

            webots.MotorTorque = (function() {

                /**
                 * Properties of a MotorTorque.
                 * @memberof message.platform.webots
                 * @interface IMotorTorque
                 * @property {string|null} [name] MotorTorque name
                 * @property {number|null} [torque] MotorTorque torque
                 */

                /**
                 * Constructs a new MotorTorque.
                 * @memberof message.platform.webots
                 * @classdesc Represents a MotorTorque.
                 * @implements IMotorTorque
                 * @constructor
                 * @param {message.platform.webots.IMotorTorque=} [properties] Properties to set
                 */
                function MotorTorque(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MotorTorque name.
                 * @member {string} name
                 * @memberof message.platform.webots.MotorTorque
                 * @instance
                 */
                MotorTorque.prototype.name = "";

                /**
                 * MotorTorque torque.
                 * @member {number} torque
                 * @memberof message.platform.webots.MotorTorque
                 * @instance
                 */
                MotorTorque.prototype.torque = 0;

                /**
                 * Encodes the specified MotorTorque message. Does not implicitly {@link message.platform.webots.MotorTorque.verify|verify} messages.
                 * @function encode
                 * @memberof message.platform.webots.MotorTorque
                 * @static
                 * @param {message.platform.webots.IMotorTorque} message MotorTorque message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MotorTorque.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.torque != null && Object.hasOwnProperty.call(message, "torque"))
                        writer.uint32(/* id 2, wireType 1 =*/17).double(message.torque);
                    return writer;
                };

                /**
                 * Decodes a MotorTorque message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.platform.webots.MotorTorque
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.platform.webots.MotorTorque} MotorTorque
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MotorTorque.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.platform.webots.MotorTorque();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.torque = reader.double();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return MotorTorque;
            })();

            webots.MotorPID = (function() {

                /**
                 * Properties of a MotorPID.
                 * @memberof message.platform.webots
                 * @interface IMotorPID
                 * @property {string|null} [name] MotorPID name
                 * @property {message.platform.webots.IVector3|null} [PID] MotorPID PID
                 */

                /**
                 * Constructs a new MotorPID.
                 * @memberof message.platform.webots
                 * @classdesc Represents a MotorPID.
                 * @implements IMotorPID
                 * @constructor
                 * @param {message.platform.webots.IMotorPID=} [properties] Properties to set
                 */
                function MotorPID(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MotorPID name.
                 * @member {string} name
                 * @memberof message.platform.webots.MotorPID
                 * @instance
                 */
                MotorPID.prototype.name = "";

                /**
                 * MotorPID PID.
                 * @member {message.platform.webots.IVector3|null|undefined} PID
                 * @memberof message.platform.webots.MotorPID
                 * @instance
                 */
                MotorPID.prototype.PID = null;

                /**
                 * Encodes the specified MotorPID message. Does not implicitly {@link message.platform.webots.MotorPID.verify|verify} messages.
                 * @function encode
                 * @memberof message.platform.webots.MotorPID
                 * @static
                 * @param {message.platform.webots.IMotorPID} message MotorPID message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MotorPID.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.PID != null && Object.hasOwnProperty.call(message, "PID"))
                        $root.message.platform.webots.Vector3.encode(message.PID, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Decodes a MotorPID message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.platform.webots.MotorPID
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.platform.webots.MotorPID} MotorPID
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MotorPID.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.platform.webots.MotorPID();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.PID = $root.message.platform.webots.Vector3.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return MotorPID;
            })();

            webots.SensorTimeStep = (function() {

                /**
                 * Properties of a SensorTimeStep.
                 * @memberof message.platform.webots
                 * @interface ISensorTimeStep
                 * @property {string|null} [name] SensorTimeStep name
                 * @property {number|null} [timeStep] SensorTimeStep timeStep
                 */

                /**
                 * Constructs a new SensorTimeStep.
                 * @memberof message.platform.webots
                 * @classdesc Represents a SensorTimeStep.
                 * @implements ISensorTimeStep
                 * @constructor
                 * @param {message.platform.webots.ISensorTimeStep=} [properties] Properties to set
                 */
                function SensorTimeStep(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SensorTimeStep name.
                 * @member {string} name
                 * @memberof message.platform.webots.SensorTimeStep
                 * @instance
                 */
                SensorTimeStep.prototype.name = "";

                /**
                 * SensorTimeStep timeStep.
                 * @member {number} timeStep
                 * @memberof message.platform.webots.SensorTimeStep
                 * @instance
                 */
                SensorTimeStep.prototype.timeStep = 0;

                /**
                 * Encodes the specified SensorTimeStep message. Does not implicitly {@link message.platform.webots.SensorTimeStep.verify|verify} messages.
                 * @function encode
                 * @memberof message.platform.webots.SensorTimeStep
                 * @static
                 * @param {message.platform.webots.ISensorTimeStep} message SensorTimeStep message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SensorTimeStep.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.timeStep != null && Object.hasOwnProperty.call(message, "timeStep"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.timeStep);
                    return writer;
                };

                /**
                 * Decodes a SensorTimeStep message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.platform.webots.SensorTimeStep
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.platform.webots.SensorTimeStep} SensorTimeStep
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SensorTimeStep.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.platform.webots.SensorTimeStep();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.timeStep = reader.uint32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return SensorTimeStep;
            })();

            webots.CameraQuality = (function() {

                /**
                 * Properties of a CameraQuality.
                 * @memberof message.platform.webots
                 * @interface ICameraQuality
                 * @property {string|null} [name] CameraQuality name
                 * @property {number|null} [quality] CameraQuality quality
                 */

                /**
                 * Constructs a new CameraQuality.
                 * @memberof message.platform.webots
                 * @classdesc Represents a CameraQuality.
                 * @implements ICameraQuality
                 * @constructor
                 * @param {message.platform.webots.ICameraQuality=} [properties] Properties to set
                 */
                function CameraQuality(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CameraQuality name.
                 * @member {string} name
                 * @memberof message.platform.webots.CameraQuality
                 * @instance
                 */
                CameraQuality.prototype.name = "";

                /**
                 * CameraQuality quality.
                 * @member {number} quality
                 * @memberof message.platform.webots.CameraQuality
                 * @instance
                 */
                CameraQuality.prototype.quality = 0;

                /**
                 * Encodes the specified CameraQuality message. Does not implicitly {@link message.platform.webots.CameraQuality.verify|verify} messages.
                 * @function encode
                 * @memberof message.platform.webots.CameraQuality
                 * @static
                 * @param {message.platform.webots.ICameraQuality} message CameraQuality message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CameraQuality.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.quality != null && Object.hasOwnProperty.call(message, "quality"))
                        writer.uint32(/* id 2, wireType 0 =*/16).sint32(message.quality);
                    return writer;
                };

                /**
                 * Decodes a CameraQuality message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.platform.webots.CameraQuality
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.platform.webots.CameraQuality} CameraQuality
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CameraQuality.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.platform.webots.CameraQuality();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.quality = reader.sint32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return CameraQuality;
            })();

            webots.CameraExposure = (function() {

                /**
                 * Properties of a CameraExposure.
                 * @memberof message.platform.webots
                 * @interface ICameraExposure
                 * @property {string|null} [name] CameraExposure name
                 * @property {number|null} [exposure] CameraExposure exposure
                 */

                /**
                 * Constructs a new CameraExposure.
                 * @memberof message.platform.webots
                 * @classdesc Represents a CameraExposure.
                 * @implements ICameraExposure
                 * @constructor
                 * @param {message.platform.webots.ICameraExposure=} [properties] Properties to set
                 */
                function CameraExposure(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CameraExposure name.
                 * @member {string} name
                 * @memberof message.platform.webots.CameraExposure
                 * @instance
                 */
                CameraExposure.prototype.name = "";

                /**
                 * CameraExposure exposure.
                 * @member {number} exposure
                 * @memberof message.platform.webots.CameraExposure
                 * @instance
                 */
                CameraExposure.prototype.exposure = 0;

                /**
                 * Encodes the specified CameraExposure message. Does not implicitly {@link message.platform.webots.CameraExposure.verify|verify} messages.
                 * @function encode
                 * @memberof message.platform.webots.CameraExposure
                 * @static
                 * @param {message.platform.webots.ICameraExposure} message CameraExposure message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CameraExposure.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.exposure != null && Object.hasOwnProperty.call(message, "exposure"))
                        writer.uint32(/* id 2, wireType 1 =*/17).double(message.exposure);
                    return writer;
                };

                /**
                 * Decodes a CameraExposure message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.platform.webots.CameraExposure
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.platform.webots.CameraExposure} CameraExposure
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CameraExposure.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.platform.webots.CameraExposure();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.exposure = reader.double();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return CameraExposure;
            })();

            webots.ActuatorRequests = (function() {

                /**
                 * Properties of an ActuatorRequests.
                 * @memberof message.platform.webots
                 * @interface IActuatorRequests
                 * @property {Array.<message.platform.webots.IMotorPosition>|null} [motorPositions] ActuatorRequests motorPositions
                 * @property {Array.<message.platform.webots.IMotorVelocity>|null} [motorVelocities] ActuatorRequests motorVelocities
                 * @property {Array.<message.platform.webots.IMotorForce>|null} [motorForces] ActuatorRequests motorForces
                 * @property {Array.<message.platform.webots.IMotorTorque>|null} [motorTorques] ActuatorRequests motorTorques
                 * @property {Array.<message.platform.webots.IMotorPID>|null} [motorPids] ActuatorRequests motorPids
                 * @property {Array.<message.platform.webots.ISensorTimeStep>|null} [sensorTimeSteps] ActuatorRequests sensorTimeSteps
                 * @property {Array.<message.platform.webots.ICameraQuality>|null} [cameraQualities] ActuatorRequests cameraQualities
                 * @property {Array.<message.platform.webots.ICameraExposure>|null} [cameraExposures] ActuatorRequests cameraExposures
                 */

                /**
                 * Constructs a new ActuatorRequests.
                 * @memberof message.platform.webots
                 * @classdesc Represents an ActuatorRequests.
                 * @implements IActuatorRequests
                 * @constructor
                 * @param {message.platform.webots.IActuatorRequests=} [properties] Properties to set
                 */
                function ActuatorRequests(properties) {
                    this.motorPositions = [];
                    this.motorVelocities = [];
                    this.motorForces = [];
                    this.motorTorques = [];
                    this.motorPids = [];
                    this.sensorTimeSteps = [];
                    this.cameraQualities = [];
                    this.cameraExposures = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ActuatorRequests motorPositions.
                 * @member {Array.<message.platform.webots.IMotorPosition>} motorPositions
                 * @memberof message.platform.webots.ActuatorRequests
                 * @instance
                 */
                ActuatorRequests.prototype.motorPositions = $util.emptyArray;

                /**
                 * ActuatorRequests motorVelocities.
                 * @member {Array.<message.platform.webots.IMotorVelocity>} motorVelocities
                 * @memberof message.platform.webots.ActuatorRequests
                 * @instance
                 */
                ActuatorRequests.prototype.motorVelocities = $util.emptyArray;

                /**
                 * ActuatorRequests motorForces.
                 * @member {Array.<message.platform.webots.IMotorForce>} motorForces
                 * @memberof message.platform.webots.ActuatorRequests
                 * @instance
                 */
                ActuatorRequests.prototype.motorForces = $util.emptyArray;

                /**
                 * ActuatorRequests motorTorques.
                 * @member {Array.<message.platform.webots.IMotorTorque>} motorTorques
                 * @memberof message.platform.webots.ActuatorRequests
                 * @instance
                 */
                ActuatorRequests.prototype.motorTorques = $util.emptyArray;

                /**
                 * ActuatorRequests motorPids.
                 * @member {Array.<message.platform.webots.IMotorPID>} motorPids
                 * @memberof message.platform.webots.ActuatorRequests
                 * @instance
                 */
                ActuatorRequests.prototype.motorPids = $util.emptyArray;

                /**
                 * ActuatorRequests sensorTimeSteps.
                 * @member {Array.<message.platform.webots.ISensorTimeStep>} sensorTimeSteps
                 * @memberof message.platform.webots.ActuatorRequests
                 * @instance
                 */
                ActuatorRequests.prototype.sensorTimeSteps = $util.emptyArray;

                /**
                 * ActuatorRequests cameraQualities.
                 * @member {Array.<message.platform.webots.ICameraQuality>} cameraQualities
                 * @memberof message.platform.webots.ActuatorRequests
                 * @instance
                 */
                ActuatorRequests.prototype.cameraQualities = $util.emptyArray;

                /**
                 * ActuatorRequests cameraExposures.
                 * @member {Array.<message.platform.webots.ICameraExposure>} cameraExposures
                 * @memberof message.platform.webots.ActuatorRequests
                 * @instance
                 */
                ActuatorRequests.prototype.cameraExposures = $util.emptyArray;

                /**
                 * Encodes the specified ActuatorRequests message. Does not implicitly {@link message.platform.webots.ActuatorRequests.verify|verify} messages.
                 * @function encode
                 * @memberof message.platform.webots.ActuatorRequests
                 * @static
                 * @param {message.platform.webots.IActuatorRequests} message ActuatorRequests message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ActuatorRequests.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.motorPositions != null && message.motorPositions.length)
                        for (let i = 0; i < message.motorPositions.length; ++i)
                            $root.message.platform.webots.MotorPosition.encode(message.motorPositions[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.motorVelocities != null && message.motorVelocities.length)
                        for (let i = 0; i < message.motorVelocities.length; ++i)
                            $root.message.platform.webots.MotorVelocity.encode(message.motorVelocities[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.motorForces != null && message.motorForces.length)
                        for (let i = 0; i < message.motorForces.length; ++i)
                            $root.message.platform.webots.MotorForce.encode(message.motorForces[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.motorTorques != null && message.motorTorques.length)
                        for (let i = 0; i < message.motorTorques.length; ++i)
                            $root.message.platform.webots.MotorTorque.encode(message.motorTorques[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.motorPids != null && message.motorPids.length)
                        for (let i = 0; i < message.motorPids.length; ++i)
                            $root.message.platform.webots.MotorPID.encode(message.motorPids[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.sensorTimeSteps != null && message.sensorTimeSteps.length)
                        for (let i = 0; i < message.sensorTimeSteps.length; ++i)
                            $root.message.platform.webots.SensorTimeStep.encode(message.sensorTimeSteps[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.cameraQualities != null && message.cameraQualities.length)
                        for (let i = 0; i < message.cameraQualities.length; ++i)
                            $root.message.platform.webots.CameraQuality.encode(message.cameraQualities[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.cameraExposures != null && message.cameraExposures.length)
                        for (let i = 0; i < message.cameraExposures.length; ++i)
                            $root.message.platform.webots.CameraExposure.encode(message.cameraExposures[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    return writer;
                };

                /**
                 * Decodes an ActuatorRequests message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.platform.webots.ActuatorRequests
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.platform.webots.ActuatorRequests} ActuatorRequests
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ActuatorRequests.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.platform.webots.ActuatorRequests();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.motorPositions && message.motorPositions.length))
                                message.motorPositions = [];
                            message.motorPositions.push($root.message.platform.webots.MotorPosition.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            if (!(message.motorVelocities && message.motorVelocities.length))
                                message.motorVelocities = [];
                            message.motorVelocities.push($root.message.platform.webots.MotorVelocity.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            if (!(message.motorForces && message.motorForces.length))
                                message.motorForces = [];
                            message.motorForces.push($root.message.platform.webots.MotorForce.decode(reader, reader.uint32()));
                            break;
                        case 4:
                            if (!(message.motorTorques && message.motorTorques.length))
                                message.motorTorques = [];
                            message.motorTorques.push($root.message.platform.webots.MotorTorque.decode(reader, reader.uint32()));
                            break;
                        case 5:
                            if (!(message.motorPids && message.motorPids.length))
                                message.motorPids = [];
                            message.motorPids.push($root.message.platform.webots.MotorPID.decode(reader, reader.uint32()));
                            break;
                        case 6:
                            if (!(message.sensorTimeSteps && message.sensorTimeSteps.length))
                                message.sensorTimeSteps = [];
                            message.sensorTimeSteps.push($root.message.platform.webots.SensorTimeStep.decode(reader, reader.uint32()));
                            break;
                        case 7:
                            if (!(message.cameraQualities && message.cameraQualities.length))
                                message.cameraQualities = [];
                            message.cameraQualities.push($root.message.platform.webots.CameraQuality.decode(reader, reader.uint32()));
                            break;
                        case 8:
                            if (!(message.cameraExposures && message.cameraExposures.length))
                                message.cameraExposures = [];
                            message.cameraExposures.push($root.message.platform.webots.CameraExposure.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return ActuatorRequests;
            })();

            return webots;
        })();

        return platform;
    })();

    message.skill = (function() {

        /**
         * Namespace skill.
         * @memberof message
         * @namespace
         */
        const skill = {};

        skill.GetUp = (function() {

            /**
             * Properties of a GetUp.
             * @memberof message.skill
             * @interface IGetUp
             */

            /**
             * Constructs a new GetUp.
             * @memberof message.skill
             * @classdesc Emit a GetUp Task in order to tell the system to perform the appropriate getup action for it's current situation
             * @implements IGetUp
             * @constructor
             * @param {message.skill.IGetUp=} [properties] Properties to set
             */
            function GetUp(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Encodes the specified GetUp message. Does not implicitly {@link message.skill.GetUp.verify|verify} messages.
             * @function encode
             * @memberof message.skill.GetUp
             * @static
             * @param {message.skill.IGetUp} message GetUp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetUp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Decodes a GetUp message from the specified reader or buffer.
             * @function decode
             * @memberof message.skill.GetUp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.skill.GetUp} GetUp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetUp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.skill.GetUp();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return GetUp;
        })();

        skill.Kick = (function() {

            /**
             * Properties of a Kick.
             * @memberof message.skill
             * @interface IKick
             * @property {number|null} [leg] Leg to kick with
             * @property {Ivec3|null} [target] The point to kick
             * @property {Ivec3|null} [direction] corresponding to the force of the kick
             */

            /**
             * Constructs a new Kick.
             * @memberof message.skill
             * @classdesc Represents a Kick.
             * @implements IKick
             * @constructor
             * @param {message.skill.IKick=} [properties] Properties to set
             */
            function Kick(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Leg to kick with
             * @member {number} leg
             * @memberof message.skill.Kick
             * @instance
             */
            Kick.prototype.leg = 0;

            /**
             * The point to kick
             * @member {Ivec3|null|undefined} target
             * @memberof message.skill.Kick
             * @instance
             */
            Kick.prototype.target = null;

            /**
             * corresponding to the force of the kick
             * @member {Ivec3|null|undefined} direction
             * @memberof message.skill.Kick
             * @instance
             */
            Kick.prototype.direction = null;

            /**
             * Encodes the specified Kick message. Does not implicitly {@link message.skill.Kick.verify|verify} messages.
             * @function encode
             * @memberof message.skill.Kick
             * @static
             * @param {message.skill.IKick} message Kick message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Kick.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.leg != null && Object.hasOwnProperty.call(message, "leg"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.leg);
                if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                    $root.vec3.encode(message.target, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.direction != null && Object.hasOwnProperty.call(message, "direction"))
                    $root.vec3.encode(message.direction, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a Kick message from the specified reader or buffer.
             * @function decode
             * @memberof message.skill.Kick
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.skill.Kick} Kick
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Kick.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.skill.Kick();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2:
                        message.leg = reader.uint32();
                        break;
                    case 3:
                        message.target = $root.vec3.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.direction = $root.vec3.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return Kick;
        })();

        skill.Look = (function() {

            /**
             * Properties of a Look.
             * @memberof message.skill
             * @interface ILook
             * @property {Ivec3|null} [rPCt] Vector from the camera to the point to look at, in torso space
             * @property {boolean|null} [smooth] If true, smooth the goal angle using exponential smoothing
             */

            /**
             * Constructs a new Look.
             * @memberof message.skill
             * @classdesc A message telling the robot to look in the given direction
             * @implements ILook
             * @constructor
             * @param {message.skill.ILook=} [properties] Properties to set
             */
            function Look(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Vector from the camera to the point to look at, in torso space
             * @member {Ivec3|null|undefined} rPCt
             * @memberof message.skill.Look
             * @instance
             */
            Look.prototype.rPCt = null;

            /**
             * If true, smooth the goal angle using exponential smoothing
             * @member {boolean} smooth
             * @memberof message.skill.Look
             * @instance
             */
            Look.prototype.smooth = false;

            /**
             * Encodes the specified Look message. Does not implicitly {@link message.skill.Look.verify|verify} messages.
             * @function encode
             * @memberof message.skill.Look
             * @static
             * @param {message.skill.ILook} message Look message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Look.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.rPCt != null && Object.hasOwnProperty.call(message, "rPCt"))
                    $root.vec3.encode(message.rPCt, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.smooth != null && Object.hasOwnProperty.call(message, "smooth"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.smooth);
                return writer;
            };

            /**
             * Decodes a Look message from the specified reader or buffer.
             * @function decode
             * @memberof message.skill.Look
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.skill.Look} Look
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Look.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.skill.Look();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.rPCt = $root.vec3.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.smooth = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return Look;
        })();

        skill.Walk = (function() {

            /**
             * Properties of a Walk.
             * @memberof message.skill
             * @interface IWalk
             * @property {Ifvec3|null} [velocityTarget] Walk velocityTarget
             */

            /**
             * Constructs a new Walk.
             * @memberof message.skill
             * @classdesc Represents a Walk.
             * @implements IWalk
             * @constructor
             * @param {message.skill.IWalk=} [properties] Properties to set
             */
            function Walk(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Walk velocityTarget.
             * @member {Ifvec3|null|undefined} velocityTarget
             * @memberof message.skill.Walk
             * @instance
             */
            Walk.prototype.velocityTarget = null;

            /**
             * Encodes the specified Walk message. Does not implicitly {@link message.skill.Walk.verify|verify} messages.
             * @function encode
             * @memberof message.skill.Walk
             * @static
             * @param {message.skill.IWalk} message Walk message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Walk.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.velocityTarget != null && Object.hasOwnProperty.call(message, "velocityTarget"))
                    $root.fvec3.encode(message.velocityTarget, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a Walk message from the specified reader or buffer.
             * @function decode
             * @memberof message.skill.Walk
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.skill.Walk} Walk
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Walk.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.skill.Walk();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.velocityTarget = $root.fvec3.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return Walk;
        })();

        return skill;
    })();

    message.strategy = (function() {

        /**
         * Namespace strategy.
         * @memberof message
         * @namespace
         */
        const strategy = {};

        strategy.FallRecovery = (function() {

            /**
             * Properties of a FallRecovery.
             * @memberof message.strategy
             * @interface IFallRecovery
             */

            /**
             * Constructs a new FallRecovery.
             * @memberof message.strategy
             * @classdesc A task that will tell behaviour to manage the falling and getting up state of the system.
             * This includes ensuring the robot will relax its limbs when it is falling, and get up if it has fallen.
             * @implements IFallRecovery
             * @constructor
             * @param {message.strategy.IFallRecovery=} [properties] Properties to set
             */
            function FallRecovery(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Encodes the specified FallRecovery message. Does not implicitly {@link message.strategy.FallRecovery.verify|verify} messages.
             * @function encode
             * @memberof message.strategy.FallRecovery
             * @static
             * @param {message.strategy.IFallRecovery} message FallRecovery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FallRecovery.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Decodes a FallRecovery message from the specified reader or buffer.
             * @function decode
             * @memberof message.strategy.FallRecovery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.strategy.FallRecovery} FallRecovery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FallRecovery.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.strategy.FallRecovery();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return FallRecovery;
        })();

        strategy.FindBall = (function() {

            /**
             * Properties of a FindBall.
             * @memberof message.strategy
             * @interface IFindBall
             */

            /**
             * Constructs a new FindBall.
             * @memberof message.strategy
             * @classdesc A Task that requests to handle the finding of the ball when its location is unknown
             * @implements IFindBall
             * @constructor
             * @param {message.strategy.IFindBall=} [properties] Properties to set
             */
            function FindBall(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Encodes the specified FindBall message. Does not implicitly {@link message.strategy.FindBall.verify|verify} messages.
             * @function encode
             * @memberof message.strategy.FindBall
             * @static
             * @param {message.strategy.IFindBall} message FindBall message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FindBall.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Decodes a FindBall message from the specified reader or buffer.
             * @function decode
             * @memberof message.strategy.FindBall
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.strategy.FindBall} FindBall
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FindBall.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.strategy.FindBall();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return FindBall;
        })();

        strategy.LookAtBall = (function() {

            /**
             * Properties of a LookAtBall.
             * @memberof message.strategy
             * @interface ILookAtBall
             */

            /**
             * Constructs a new LookAtBall.
             * @memberof message.strategy
             * @classdesc Task requesting to look at the ball
             * @implements ILookAtBall
             * @constructor
             * @param {message.strategy.ILookAtBall=} [properties] Properties to set
             */
            function LookAtBall(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Encodes the specified LookAtBall message. Does not implicitly {@link message.strategy.LookAtBall.verify|verify} messages.
             * @function encode
             * @memberof message.strategy.LookAtBall
             * @static
             * @param {message.strategy.ILookAtBall} message LookAtBall message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LookAtBall.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Decodes a LookAtBall message from the specified reader or buffer.
             * @function decode
             * @memberof message.strategy.LookAtBall
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.strategy.LookAtBall} LookAtBall
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LookAtBall.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.strategy.LookAtBall();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return LookAtBall;
        })();

        strategy.LookAtGoals = (function() {

            /**
             * Properties of a LookAtGoals.
             * @memberof message.strategy
             * @interface ILookAtGoals
             */

            /**
             * Constructs a new LookAtGoals.
             * @memberof message.strategy
             * @classdesc Task requesting to look at the goal
             * @implements ILookAtGoals
             * @constructor
             * @param {message.strategy.ILookAtGoals=} [properties] Properties to set
             */
            function LookAtGoals(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Encodes the specified LookAtGoals message. Does not implicitly {@link message.strategy.LookAtGoals.verify|verify} messages.
             * @function encode
             * @memberof message.strategy.LookAtGoals
             * @static
             * @param {message.strategy.ILookAtGoals} message LookAtGoals message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LookAtGoals.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Decodes a LookAtGoals message from the specified reader or buffer.
             * @function decode
             * @memberof message.strategy.LookAtGoals
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.strategy.LookAtGoals} LookAtGoals
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LookAtGoals.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.strategy.LookAtGoals();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return LookAtGoals;
        })();

        strategy.Ready = (function() {

            /**
             * Properties of a Ready.
             * @memberof message.strategy
             * @interface IReady
             * @property {Ivec3|null} [rRFf] The target position to walk to relative to the field
             */

            /**
             * Constructs a new Ready.
             * @memberof message.strategy
             * @classdesc Ready state strategy for walking onto the field
             * @implements IReady
             * @constructor
             * @param {message.strategy.IReady=} [properties] Properties to set
             */
            function Ready(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * The target position to walk to relative to the field
             * @member {Ivec3|null|undefined} rRFf
             * @memberof message.strategy.Ready
             * @instance
             */
            Ready.prototype.rRFf = null;

            /**
             * Encodes the specified Ready message. Does not implicitly {@link message.strategy.Ready.verify|verify} messages.
             * @function encode
             * @memberof message.strategy.Ready
             * @static
             * @param {message.strategy.IReady} message Ready message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Ready.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.rRFf != null && Object.hasOwnProperty.call(message, "rRFf"))
                    $root.vec3.encode(message.rRFf, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a Ready message from the specified reader or buffer.
             * @function decode
             * @memberof message.strategy.Ready
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.strategy.Ready} Ready
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Ready.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.strategy.Ready();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.rRFf = $root.vec3.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return Ready;
        })();

        strategy.StandStill = (function() {

            /**
             * Properties of a StandStill.
             * @memberof message.strategy
             * @interface IStandStill
             */

            /**
             * Constructs a new StandStill.
             * @memberof message.strategy
             * @classdesc Makes the robot stop walking and stand still
             * @implements IStandStill
             * @constructor
             * @param {message.strategy.IStandStill=} [properties] Properties to set
             */
            function StandStill(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Encodes the specified StandStill message. Does not implicitly {@link message.strategy.StandStill.verify|verify} messages.
             * @function encode
             * @memberof message.strategy.StandStill
             * @static
             * @param {message.strategy.IStandStill} message StandStill message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StandStill.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Decodes a StandStill message from the specified reader or buffer.
             * @function decode
             * @memberof message.strategy.StandStill
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.strategy.StandStill} StandStill
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StandStill.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.strategy.StandStill();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return StandStill;
        })();

        strategy.WalkToBall = (function() {

            /**
             * Properties of a WalkToBall.
             * @memberof message.strategy
             * @interface IWalkToBall
             */

            /**
             * Constructs a new WalkToBall.
             * @memberof message.strategy
             * @classdesc Robot walks to the ball or searches if it can't find it
             * @implements IWalkToBall
             * @constructor
             * @param {message.strategy.IWalkToBall=} [properties] Properties to set
             */
            function WalkToBall(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Encodes the specified WalkToBall message. Does not implicitly {@link message.strategy.WalkToBall.verify|verify} messages.
             * @function encode
             * @memberof message.strategy.WalkToBall
             * @static
             * @param {message.strategy.IWalkToBall} message WalkToBall message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WalkToBall.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Decodes a WalkToBall message from the specified reader or buffer.
             * @function decode
             * @memberof message.strategy.WalkToBall
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.strategy.WalkToBall} WalkToBall
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WalkToBall.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.strategy.WalkToBall();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return WalkToBall;
        })();

        return strategy;
    })();

    message.support = (function() {

        /**
         * Namespace support.
         * @memberof message
         * @namespace
         */
        const support = {};

        support.FieldDescription = (function() {

            /**
             * Properties of a FieldDescription.
             * @memberof message.support
             * @interface IFieldDescription
             * @property {number|null} [ballRadius] @see Law 2
             * @property {number|null} [goalpostTopHeight] Calculated as goal_crossbar_height + goal_crossbar_width
             * @property {Ivec2|null} [goalpostOwnL] It's the left one, as if you were looking from halfway
             * @property {Ivec2|null} [goalpostOwnR] It's the right one, as if you were looking from halfway
             * @property {Ivec2|null} [goalpostOppL] {x, y} of opposition left goalpost, calculated from goal_width and field_length
             * @property {Ivec2|null} [goalpostOppR] {x, y} of opposition right goalpost, calculated from goal_width and field_length
             * @property {message.support.FieldDescription.IFieldDimensions|null} [dimensions] Set of field dimensions loaded from config
             */

            /**
             * Constructs a new FieldDescription.
             * @memberof message.support
             * @classdesc Information about location and size of field objects and markers.
             * Details about field measurements can be found in 'Law 1 - The Field of Play',
             * in the RoboCup rulebook, here https://humanoid.robocup.org/materials/rules/
             * We have these config values mirrored in `SoccerConfig/data/config/`.
             * @implements IFieldDescription
             * @constructor
             * @param {message.support.IFieldDescription=} [properties] Properties to set
             */
            function FieldDescription(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * @see Law 2
             * @member {number} ballRadius
             * @memberof message.support.FieldDescription
             * @instance
             */
            FieldDescription.prototype.ballRadius = 0;

            /**
             * Calculated as goal_crossbar_height + goal_crossbar_width
             * @member {number} goalpostTopHeight
             * @memberof message.support.FieldDescription
             * @instance
             */
            FieldDescription.prototype.goalpostTopHeight = 0;

            /**
             * It's the left one, as if you were looking from halfway
             * @member {Ivec2|null|undefined} goalpostOwnL
             * @memberof message.support.FieldDescription
             * @instance
             */
            FieldDescription.prototype.goalpostOwnL = null;

            /**
             * It's the right one, as if you were looking from halfway
             * @member {Ivec2|null|undefined} goalpostOwnR
             * @memberof message.support.FieldDescription
             * @instance
             */
            FieldDescription.prototype.goalpostOwnR = null;

            /**
             * {x, y} of opposition left goalpost, calculated from goal_width and field_length
             * @member {Ivec2|null|undefined} goalpostOppL
             * @memberof message.support.FieldDescription
             * @instance
             */
            FieldDescription.prototype.goalpostOppL = null;

            /**
             * {x, y} of opposition right goalpost, calculated from goal_width and field_length
             * @member {Ivec2|null|undefined} goalpostOppR
             * @memberof message.support.FieldDescription
             * @instance
             */
            FieldDescription.prototype.goalpostOppR = null;

            /**
             * Set of field dimensions loaded from config
             * @member {message.support.FieldDescription.IFieldDimensions|null|undefined} dimensions
             * @memberof message.support.FieldDescription
             * @instance
             */
            FieldDescription.prototype.dimensions = null;

            /**
             * Encodes the specified FieldDescription message. Does not implicitly {@link message.support.FieldDescription.verify|verify} messages.
             * @function encode
             * @memberof message.support.FieldDescription
             * @static
             * @param {message.support.IFieldDescription} message FieldDescription message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldDescription.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.ballRadius != null && Object.hasOwnProperty.call(message, "ballRadius"))
                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.ballRadius);
                if (message.goalpostTopHeight != null && Object.hasOwnProperty.call(message, "goalpostTopHeight"))
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.goalpostTopHeight);
                if (message.goalpostOwnL != null && Object.hasOwnProperty.call(message, "goalpostOwnL"))
                    $root.vec2.encode(message.goalpostOwnL, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.goalpostOwnR != null && Object.hasOwnProperty.call(message, "goalpostOwnR"))
                    $root.vec2.encode(message.goalpostOwnR, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.goalpostOppL != null && Object.hasOwnProperty.call(message, "goalpostOppL"))
                    $root.vec2.encode(message.goalpostOppL, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.goalpostOppR != null && Object.hasOwnProperty.call(message, "goalpostOppR"))
                    $root.vec2.encode(message.goalpostOppR, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.dimensions != null && Object.hasOwnProperty.call(message, "dimensions"))
                    $root.message.support.FieldDescription.FieldDimensions.encode(message.dimensions, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a FieldDescription message from the specified reader or buffer.
             * @function decode
             * @memberof message.support.FieldDescription
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.support.FieldDescription} FieldDescription
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldDescription.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.support.FieldDescription();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.ballRadius = reader.double();
                        break;
                    case 2:
                        message.goalpostTopHeight = reader.double();
                        break;
                    case 4:
                        message.goalpostOwnL = $root.vec2.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.goalpostOwnR = $root.vec2.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.goalpostOppL = $root.vec2.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.goalpostOppR = $root.vec2.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.dimensions = $root.message.support.FieldDescription.FieldDimensions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * The cross-sectional shape of the goalposts
             * @name message.support.FieldDescription.GoalpostType
             * @enum {number}
             * @property {number} RECTANGLE=0 RECTANGLE value
             * @property {number} CIRCLE=1 CIRCLE value
             */
            FieldDescription.GoalpostType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "RECTANGLE"] = 0;
                values[valuesById[1] = "CIRCLE"] = 1;
                return values;
            })();

            FieldDescription.FieldDimensions = (function() {

                /**
                 * Properties of a FieldDimensions.
                 * @memberof message.support.FieldDescription
                 * @interface IFieldDimensions
                 * @property {number|null} [lineWidth] The rules say that the lines must be the same width
                 * @property {number|null} [fieldLength] The 'touch line' length - AKA the sideline
                 * @property {number|null} [fieldWidth] The 'goal line' length - AKA the baseline
                 * @property {message.support.FieldDescription.GoalpostType|null} [goalpostType] Cross-sectional shape of goal-posts
                 * @property {number|null} [goalDepth] Distance behind the keeper to the net
                 * @property {number|null} [goalWidth] Distance between inner edges of goal posts
                 * @property {number|null} [goalAreaLength] of the field facing goals
                 * @property {number|null} [goalAreaWidth] of the field facing goals
                 * @property {number|null} [goalCrossbarHeight] Height to the bottom of the crossbar
                 * @property {number|null} [goalpostWidth] FieldDimensions goalpostWidth
                 * @property {number|null} [goalpostDepth] FieldDimensions goalpostDepth
                 * @property {number|null} [goalCrossbarWidth] FieldDimensions goalCrossbarWidth
                 * @property {number|null} [goalCrossbarDepth] FieldDimensions goalCrossbarDepth
                 * @property {number|null} [goalNetHeight] FieldDimensions goalNetHeight
                 * @property {number|null} [penaltyMarkDistance] Measured from the goal line to the middle of the penalty mark
                 * @property {number|null} [centerCircleDiameter] Diameter of the circle in the center of the field
                 * @property {number|null} [borderStripMinWidth] Minimum width of the border strip around the field
                 * @property {number|null} [penaltyAreaLength] if you're facing the centre of the field from the goal line
                 * @property {number|null} [penaltyAreaWidth] penalty box facing the centre of the field/goal
                 */

                /**
                 * Constructs a new FieldDimensions.
                 * @memberof message.support.FieldDescription
                 * @classdesc Measurements of the field which are loaded from config file. In metres
                 * @implements IFieldDimensions
                 * @constructor
                 * @param {message.support.FieldDescription.IFieldDimensions=} [properties] Properties to set
                 */
                function FieldDimensions(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * The rules say that the lines must be the same width
                 * @member {number} lineWidth
                 * @memberof message.support.FieldDescription.FieldDimensions
                 * @instance
                 */
                FieldDimensions.prototype.lineWidth = 0;

                /**
                 * The 'touch line' length - AKA the sideline
                 * @member {number} fieldLength
                 * @memberof message.support.FieldDescription.FieldDimensions
                 * @instance
                 */
                FieldDimensions.prototype.fieldLength = 0;

                /**
                 * The 'goal line' length - AKA the baseline
                 * @member {number} fieldWidth
                 * @memberof message.support.FieldDescription.FieldDimensions
                 * @instance
                 */
                FieldDimensions.prototype.fieldWidth = 0;

                /**
                 * Cross-sectional shape of goal-posts
                 * @member {message.support.FieldDescription.GoalpostType} goalpostType
                 * @memberof message.support.FieldDescription.FieldDimensions
                 * @instance
                 */
                FieldDimensions.prototype.goalpostType = 0;

                /**
                 * Distance behind the keeper to the net
                 * @member {number} goalDepth
                 * @memberof message.support.FieldDescription.FieldDimensions
                 * @instance
                 */
                FieldDimensions.prototype.goalDepth = 0;

                /**
                 * Distance between inner edges of goal posts
                 * @member {number} goalWidth
                 * @memberof message.support.FieldDescription.FieldDimensions
                 * @instance
                 */
                FieldDimensions.prototype.goalWidth = 0;

                /**
                 * of the field facing goals
                 * @member {number} goalAreaLength
                 * @memberof message.support.FieldDescription.FieldDimensions
                 * @instance
                 */
                FieldDimensions.prototype.goalAreaLength = 0;

                /**
                 * of the field facing goals
                 * @member {number} goalAreaWidth
                 * @memberof message.support.FieldDescription.FieldDimensions
                 * @instance
                 */
                FieldDimensions.prototype.goalAreaWidth = 0;

                /**
                 * Height to the bottom of the crossbar
                 * @member {number} goalCrossbarHeight
                 * @memberof message.support.FieldDescription.FieldDimensions
                 * @instance
                 */
                FieldDimensions.prototype.goalCrossbarHeight = 0;

                /**
                 * FieldDimensions goalpostWidth.
                 * @member {number} goalpostWidth
                 * @memberof message.support.FieldDescription.FieldDimensions
                 * @instance
                 */
                FieldDimensions.prototype.goalpostWidth = 0;

                /**
                 * FieldDimensions goalpostDepth.
                 * @member {number} goalpostDepth
                 * @memberof message.support.FieldDescription.FieldDimensions
                 * @instance
                 */
                FieldDimensions.prototype.goalpostDepth = 0;

                /**
                 * FieldDimensions goalCrossbarWidth.
                 * @member {number} goalCrossbarWidth
                 * @memberof message.support.FieldDescription.FieldDimensions
                 * @instance
                 */
                FieldDimensions.prototype.goalCrossbarWidth = 0;

                /**
                 * FieldDimensions goalCrossbarDepth.
                 * @member {number} goalCrossbarDepth
                 * @memberof message.support.FieldDescription.FieldDimensions
                 * @instance
                 */
                FieldDimensions.prototype.goalCrossbarDepth = 0;

                /**
                 * FieldDimensions goalNetHeight.
                 * @member {number} goalNetHeight
                 * @memberof message.support.FieldDescription.FieldDimensions
                 * @instance
                 */
                FieldDimensions.prototype.goalNetHeight = 0;

                /**
                 * Measured from the goal line to the middle of the penalty mark
                 * @member {number} penaltyMarkDistance
                 * @memberof message.support.FieldDescription.FieldDimensions
                 * @instance
                 */
                FieldDimensions.prototype.penaltyMarkDistance = 0;

                /**
                 * Diameter of the circle in the center of the field
                 * @member {number} centerCircleDiameter
                 * @memberof message.support.FieldDescription.FieldDimensions
                 * @instance
                 */
                FieldDimensions.prototype.centerCircleDiameter = 0;

                /**
                 * Minimum width of the border strip around the field
                 * @member {number} borderStripMinWidth
                 * @memberof message.support.FieldDescription.FieldDimensions
                 * @instance
                 */
                FieldDimensions.prototype.borderStripMinWidth = 0;

                /**
                 * if you're facing the centre of the field from the goal line
                 * @member {number} penaltyAreaLength
                 * @memberof message.support.FieldDescription.FieldDimensions
                 * @instance
                 */
                FieldDimensions.prototype.penaltyAreaLength = 0;

                /**
                 * penalty box facing the centre of the field/goal
                 * @member {number} penaltyAreaWidth
                 * @memberof message.support.FieldDescription.FieldDimensions
                 * @instance
                 */
                FieldDimensions.prototype.penaltyAreaWidth = 0;

                /**
                 * Encodes the specified FieldDimensions message. Does not implicitly {@link message.support.FieldDescription.FieldDimensions.verify|verify} messages.
                 * @function encode
                 * @memberof message.support.FieldDescription.FieldDimensions
                 * @static
                 * @param {message.support.FieldDescription.IFieldDimensions} message FieldDimensions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FieldDimensions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.lineWidth != null && Object.hasOwnProperty.call(message, "lineWidth"))
                        writer.uint32(/* id 1, wireType 1 =*/9).double(message.lineWidth);
                    if (message.fieldLength != null && Object.hasOwnProperty.call(message, "fieldLength"))
                        writer.uint32(/* id 2, wireType 1 =*/17).double(message.fieldLength);
                    if (message.fieldWidth != null && Object.hasOwnProperty.call(message, "fieldWidth"))
                        writer.uint32(/* id 3, wireType 1 =*/25).double(message.fieldWidth);
                    if (message.goalpostType != null && Object.hasOwnProperty.call(message, "goalpostType"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.goalpostType);
                    if (message.goalDepth != null && Object.hasOwnProperty.call(message, "goalDepth"))
                        writer.uint32(/* id 5, wireType 1 =*/41).double(message.goalDepth);
                    if (message.goalWidth != null && Object.hasOwnProperty.call(message, "goalWidth"))
                        writer.uint32(/* id 6, wireType 1 =*/49).double(message.goalWidth);
                    if (message.goalAreaLength != null && Object.hasOwnProperty.call(message, "goalAreaLength"))
                        writer.uint32(/* id 7, wireType 1 =*/57).double(message.goalAreaLength);
                    if (message.goalAreaWidth != null && Object.hasOwnProperty.call(message, "goalAreaWidth"))
                        writer.uint32(/* id 8, wireType 1 =*/65).double(message.goalAreaWidth);
                    if (message.goalCrossbarHeight != null && Object.hasOwnProperty.call(message, "goalCrossbarHeight"))
                        writer.uint32(/* id 9, wireType 1 =*/73).double(message.goalCrossbarHeight);
                    if (message.goalpostWidth != null && Object.hasOwnProperty.call(message, "goalpostWidth"))
                        writer.uint32(/* id 10, wireType 1 =*/81).double(message.goalpostWidth);
                    if (message.goalpostDepth != null && Object.hasOwnProperty.call(message, "goalpostDepth"))
                        writer.uint32(/* id 11, wireType 1 =*/89).double(message.goalpostDepth);
                    if (message.goalCrossbarWidth != null && Object.hasOwnProperty.call(message, "goalCrossbarWidth"))
                        writer.uint32(/* id 12, wireType 1 =*/97).double(message.goalCrossbarWidth);
                    if (message.goalCrossbarDepth != null && Object.hasOwnProperty.call(message, "goalCrossbarDepth"))
                        writer.uint32(/* id 13, wireType 1 =*/105).double(message.goalCrossbarDepth);
                    if (message.goalNetHeight != null && Object.hasOwnProperty.call(message, "goalNetHeight"))
                        writer.uint32(/* id 14, wireType 1 =*/113).double(message.goalNetHeight);
                    if (message.penaltyMarkDistance != null && Object.hasOwnProperty.call(message, "penaltyMarkDistance"))
                        writer.uint32(/* id 15, wireType 1 =*/121).double(message.penaltyMarkDistance);
                    if (message.centerCircleDiameter != null && Object.hasOwnProperty.call(message, "centerCircleDiameter"))
                        writer.uint32(/* id 16, wireType 1 =*/129).double(message.centerCircleDiameter);
                    if (message.borderStripMinWidth != null && Object.hasOwnProperty.call(message, "borderStripMinWidth"))
                        writer.uint32(/* id 17, wireType 1 =*/137).double(message.borderStripMinWidth);
                    if (message.penaltyAreaLength != null && Object.hasOwnProperty.call(message, "penaltyAreaLength"))
                        writer.uint32(/* id 18, wireType 1 =*/145).double(message.penaltyAreaLength);
                    if (message.penaltyAreaWidth != null && Object.hasOwnProperty.call(message, "penaltyAreaWidth"))
                        writer.uint32(/* id 19, wireType 1 =*/153).double(message.penaltyAreaWidth);
                    return writer;
                };

                /**
                 * Decodes a FieldDimensions message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.support.FieldDescription.FieldDimensions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.support.FieldDescription.FieldDimensions} FieldDimensions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FieldDimensions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.support.FieldDescription.FieldDimensions();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.lineWidth = reader.double();
                            break;
                        case 2:
                            message.fieldLength = reader.double();
                            break;
                        case 3:
                            message.fieldWidth = reader.double();
                            break;
                        case 4:
                            message.goalpostType = reader.int32();
                            break;
                        case 5:
                            message.goalDepth = reader.double();
                            break;
                        case 6:
                            message.goalWidth = reader.double();
                            break;
                        case 7:
                            message.goalAreaLength = reader.double();
                            break;
                        case 8:
                            message.goalAreaWidth = reader.double();
                            break;
                        case 9:
                            message.goalCrossbarHeight = reader.double();
                            break;
                        case 10:
                            message.goalpostWidth = reader.double();
                            break;
                        case 11:
                            message.goalpostDepth = reader.double();
                            break;
                        case 12:
                            message.goalCrossbarWidth = reader.double();
                            break;
                        case 13:
                            message.goalCrossbarDepth = reader.double();
                            break;
                        case 14:
                            message.goalNetHeight = reader.double();
                            break;
                        case 15:
                            message.penaltyMarkDistance = reader.double();
                            break;
                        case 16:
                            message.centerCircleDiameter = reader.double();
                            break;
                        case 17:
                            message.borderStripMinWidth = reader.double();
                            break;
                        case 18:
                            message.penaltyAreaLength = reader.double();
                            break;
                        case 19:
                            message.penaltyAreaWidth = reader.double();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return FieldDimensions;
            })();

            return FieldDescription;
        })();

        support.GlobalConfig = (function() {

            /**
             * Properties of a GlobalConfig.
             * @memberof message.support
             * @interface IGlobalConfig
             * @property {number|null} [playerId] The robots number in the team. Starts at 1. Should be the same as the robots number (nugus1, nugus2, etc)
             * @property {number|null} [teamId] go to teams.cfg, then find <number>=NUbots and the <number> is our team ID.
             */

            /**
             * Constructs a new GlobalConfig.
             * @memberof message.support
             * @classdesc Represents a GlobalConfig.
             * @implements IGlobalConfig
             * @constructor
             * @param {message.support.IGlobalConfig=} [properties] Properties to set
             */
            function GlobalConfig(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * The robots number in the team. Starts at 1. Should be the same as the robots number (nugus1, nugus2, etc)
             * @member {number} playerId
             * @memberof message.support.GlobalConfig
             * @instance
             */
            GlobalConfig.prototype.playerId = 0;

            /**
             * go to teams.cfg, then find <number>=NUbots and the <number> is our team ID.
             * @member {number} teamId
             * @memberof message.support.GlobalConfig
             * @instance
             */
            GlobalConfig.prototype.teamId = 0;

            /**
             * Encodes the specified GlobalConfig message. Does not implicitly {@link message.support.GlobalConfig.verify|verify} messages.
             * @function encode
             * @memberof message.support.GlobalConfig
             * @static
             * @param {message.support.IGlobalConfig} message GlobalConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GlobalConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.playerId != null && Object.hasOwnProperty.call(message, "playerId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.playerId);
                if (message.teamId != null && Object.hasOwnProperty.call(message, "teamId"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.teamId);
                return writer;
            };

            /**
             * Decodes a GlobalConfig message from the specified reader or buffer.
             * @function decode
             * @memberof message.support.GlobalConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.support.GlobalConfig} GlobalConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GlobalConfig.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.support.GlobalConfig();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.playerId = reader.uint32();
                        break;
                    case 2:
                        message.teamId = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return GlobalConfig;
        })();

        support.nuclear = (function() {

            /**
             * Namespace nuclear.
             * @memberof message.support
             * @namespace
             */
            const nuclear = {};

            nuclear.ReactionStatistics = (function() {

                /**
                 * Properties of a ReactionStatistics.
                 * @memberof message.support.nuclear
                 * @interface IReactionStatistics
                 * @property {string|null} [name] ReactionStatistics name
                 * @property {string|null} [triggerName] ReactionStatistics triggerName
                 * @property {string|null} [functionName] ReactionStatistics functionName
                 * @property {number|Long|null} [reactionId] ReactionStatistics reactionId
                 * @property {number|Long|null} [taskId] ReactionStatistics taskId
                 * @property {number|Long|null} [causeReactionId] ReactionStatistics causeReactionId
                 * @property {number|Long|null} [causeTaskId] ReactionStatistics causeTaskId
                 * @property {number|Long|null} [emitted] Timestamp when the message was emitted
                 * @property {number|Long|null} [started] Timestamp when the reaction started
                 * @property {number|Long|null} [finished] Timestamp when the reaction finished
                 */

                /**
                 * Constructs a new ReactionStatistics.
                 * @memberof message.support.nuclear
                 * @classdesc Represents a ReactionStatistics.
                 * @implements IReactionStatistics
                 * @constructor
                 * @param {message.support.nuclear.IReactionStatistics=} [properties] Properties to set
                 */
                function ReactionStatistics(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ReactionStatistics name.
                 * @member {string} name
                 * @memberof message.support.nuclear.ReactionStatistics
                 * @instance
                 */
                ReactionStatistics.prototype.name = "";

                /**
                 * ReactionStatistics triggerName.
                 * @member {string} triggerName
                 * @memberof message.support.nuclear.ReactionStatistics
                 * @instance
                 */
                ReactionStatistics.prototype.triggerName = "";

                /**
                 * ReactionStatistics functionName.
                 * @member {string} functionName
                 * @memberof message.support.nuclear.ReactionStatistics
                 * @instance
                 */
                ReactionStatistics.prototype.functionName = "";

                /**
                 * ReactionStatistics reactionId.
                 * @member {number|Long} reactionId
                 * @memberof message.support.nuclear.ReactionStatistics
                 * @instance
                 */
                ReactionStatistics.prototype.reactionId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * ReactionStatistics taskId.
                 * @member {number|Long} taskId
                 * @memberof message.support.nuclear.ReactionStatistics
                 * @instance
                 */
                ReactionStatistics.prototype.taskId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * ReactionStatistics causeReactionId.
                 * @member {number|Long} causeReactionId
                 * @memberof message.support.nuclear.ReactionStatistics
                 * @instance
                 */
                ReactionStatistics.prototype.causeReactionId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * ReactionStatistics causeTaskId.
                 * @member {number|Long} causeTaskId
                 * @memberof message.support.nuclear.ReactionStatistics
                 * @instance
                 */
                ReactionStatistics.prototype.causeTaskId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * Timestamp when the message was emitted
                 * @member {number|Long} emitted
                 * @memberof message.support.nuclear.ReactionStatistics
                 * @instance
                 */
                ReactionStatistics.prototype.emitted = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * Timestamp when the reaction started
                 * @member {number|Long} started
                 * @memberof message.support.nuclear.ReactionStatistics
                 * @instance
                 */
                ReactionStatistics.prototype.started = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * Timestamp when the reaction finished
                 * @member {number|Long} finished
                 * @memberof message.support.nuclear.ReactionStatistics
                 * @instance
                 */
                ReactionStatistics.prototype.finished = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * Encodes the specified ReactionStatistics message. Does not implicitly {@link message.support.nuclear.ReactionStatistics.verify|verify} messages.
                 * @function encode
                 * @memberof message.support.nuclear.ReactionStatistics
                 * @static
                 * @param {message.support.nuclear.IReactionStatistics} message ReactionStatistics message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReactionStatistics.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.triggerName != null && Object.hasOwnProperty.call(message, "triggerName"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.triggerName);
                    if (message.functionName != null && Object.hasOwnProperty.call(message, "functionName"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.functionName);
                    if (message.reactionId != null && Object.hasOwnProperty.call(message, "reactionId"))
                        writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.reactionId);
                    if (message.taskId != null && Object.hasOwnProperty.call(message, "taskId"))
                        writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.taskId);
                    if (message.causeReactionId != null && Object.hasOwnProperty.call(message, "causeReactionId"))
                        writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.causeReactionId);
                    if (message.causeTaskId != null && Object.hasOwnProperty.call(message, "causeTaskId"))
                        writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.causeTaskId);
                    if (message.emitted != null && Object.hasOwnProperty.call(message, "emitted"))
                        writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.emitted);
                    if (message.started != null && Object.hasOwnProperty.call(message, "started"))
                        writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.started);
                    if (message.finished != null && Object.hasOwnProperty.call(message, "finished"))
                        writer.uint32(/* id 10, wireType 0 =*/80).uint64(message.finished);
                    return writer;
                };

                /**
                 * Decodes a ReactionStatistics message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.support.nuclear.ReactionStatistics
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.support.nuclear.ReactionStatistics} ReactionStatistics
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReactionStatistics.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.support.nuclear.ReactionStatistics();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.triggerName = reader.string();
                            break;
                        case 3:
                            message.functionName = reader.string();
                            break;
                        case 4:
                            message.reactionId = reader.uint64();
                            break;
                        case 5:
                            message.taskId = reader.uint64();
                            break;
                        case 6:
                            message.causeReactionId = reader.uint64();
                            break;
                        case 7:
                            message.causeTaskId = reader.uint64();
                            break;
                        case 8:
                            message.emitted = reader.uint64();
                            break;
                        case 9:
                            message.started = reader.uint64();
                            break;
                        case 10:
                            message.finished = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return ReactionStatistics;
            })();

            return nuclear;
        })();

        support.nusight = (function() {

            /**
             * Namespace nusight.
             * @memberof message.support
             * @namespace
             */
            const nusight = {};

            nusight.Command = (function() {

                /**
                 * Properties of a Command.
                 * @memberof message.support.nusight
                 * @interface ICommand
                 * @property {string|null} [command] Command command
                 */

                /**
                 * Constructs a new Command.
                 * @memberof message.support.nusight
                 * @classdesc Represents a Command.
                 * @implements ICommand
                 * @constructor
                 * @param {message.support.nusight.ICommand=} [properties] Properties to set
                 */
                function Command(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Command command.
                 * @member {string} command
                 * @memberof message.support.nusight.Command
                 * @instance
                 */
                Command.prototype.command = "";

                /**
                 * Encodes the specified Command message. Does not implicitly {@link message.support.nusight.Command.verify|verify} messages.
                 * @function encode
                 * @memberof message.support.nusight.Command
                 * @static
                 * @param {message.support.nusight.ICommand} message Command message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Command.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.command != null && Object.hasOwnProperty.call(message, "command"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.command);
                    return writer;
                };

                /**
                 * Decodes a Command message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.support.nusight.Command
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.support.nusight.Command} Command
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Command.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.support.nusight.Command();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.command = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return Command;
            })();

            nusight.DataPoint = (function() {

                /**
                 * Properties of a DataPoint.
                 * @memberof message.support.nusight
                 * @interface IDataPoint
                 * @property {string|null} [label] DataPoint label
                 * @property {Array.<number>|null} [value] DataPoint value
                 * @property {google.protobuf.ITimestamp|null} [timestamp] DataPoint timestamp
                 */

                /**
                 * Constructs a new DataPoint.
                 * @memberof message.support.nusight
                 * @classdesc Represents a DataPoint.
                 * @implements IDataPoint
                 * @constructor
                 * @param {message.support.nusight.IDataPoint=} [properties] Properties to set
                 */
                function DataPoint(properties) {
                    this.value = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DataPoint label.
                 * @member {string} label
                 * @memberof message.support.nusight.DataPoint
                 * @instance
                 */
                DataPoint.prototype.label = "";

                /**
                 * DataPoint value.
                 * @member {Array.<number>} value
                 * @memberof message.support.nusight.DataPoint
                 * @instance
                 */
                DataPoint.prototype.value = $util.emptyArray;

                /**
                 * DataPoint timestamp.
                 * @member {google.protobuf.ITimestamp|null|undefined} timestamp
                 * @memberof message.support.nusight.DataPoint
                 * @instance
                 */
                DataPoint.prototype.timestamp = null;

                /**
                 * Encodes the specified DataPoint message. Does not implicitly {@link message.support.nusight.DataPoint.verify|verify} messages.
                 * @function encode
                 * @memberof message.support.nusight.DataPoint
                 * @static
                 * @param {message.support.nusight.IDataPoint} message DataPoint message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DataPoint.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.label != null && Object.hasOwnProperty.call(message, "label"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.label);
                    if (message.value != null && message.value.length) {
                        writer.uint32(/* id 2, wireType 2 =*/18).fork();
                        for (let i = 0; i < message.value.length; ++i)
                            writer.float(message.value[i]);
                        writer.ldelim();
                    }
                    if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                        $root.google.protobuf.Timestamp.encode(message.timestamp, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    return writer;
                };

                /**
                 * Decodes a DataPoint message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.support.nusight.DataPoint
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.support.nusight.DataPoint} DataPoint
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DataPoint.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.support.nusight.DataPoint();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.label = reader.string();
                            break;
                        case 2:
                            if (!(message.value && message.value.length))
                                message.value = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.value.push(reader.float());
                            } else
                                message.value.push(reader.float());
                            break;
                        case 4:
                            message.timestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return DataPoint;
            })();

            nusight.Overview = (function() {

                /**
                 * Properties of an Overview.
                 * @memberof message.support.nusight
                 * @interface IOverview
                 * @property {google.protobuf.ITimestamp|null} [timestamp] The timestamp this overview packet was sent
                 * @property {number|null} [robotId] Overview robotId
                 * @property {string|null} [roleName] The name of the binary this robot is executing
                 * @property {number|null} [battery] @see message::input::Sensors::battery
                 * @property {number|null} [voltage] @see message::input::Sensors::voltage
                 * @property {message.behaviour.Behaviour.State|null} [behaviourState] The current behaviour state. List of possible states in message::behaviour::Behaviour
                 * @property {Ifvec3|null} [robotPosition] Localisation measured in field space
                 * @property {Ifmat3|null} [robotPositionCovariance] Overview robotPositionCovariance
                 * @property {Ifvec2|null} [ballPosition] The ball position measured in field space
                 * @property {Ifmat2|null} [ballPositionCovariance] Overview ballPositionCovariance
                 * @property {Ifvec2|null} [kickTarget] The {x, y} location we are kicking to
                 * @property {message.input.GameState.Data.Mode|null} [gameMode] The type of game being played. From Game Controller
                 * @property {message.input.GameState.Data.Phase|null} [gamePhase] The current stage of gameplay. For Game Controller
                 * @property {message.input.GameState.Data.PenaltyReason|null} [penaltyReason] Why the penalty was given. For Game Controller
                 * @property {google.protobuf.ITimestamp|null} [lastCameraImage] Last time the camera image was seen
                 * @property {google.protobuf.ITimestamp|null} [lastSeenBall] Last time vision objects were seen
                 * @property {google.protobuf.ITimestamp|null} [lastSeenGoal] Overview lastSeenGoal
                 * @property {Ifvec3|null} [walkCommand] required rotational velocity about the z axis. In torso space
                 */

                /**
                 * Constructs a new Overview.
                 * @memberof message.support.nusight
                 * @classdesc Represents an Overview.
                 * @implements IOverview
                 * @constructor
                 * @param {message.support.nusight.IOverview=} [properties] Properties to set
                 */
                function Overview(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * The timestamp this overview packet was sent
                 * @member {google.protobuf.ITimestamp|null|undefined} timestamp
                 * @memberof message.support.nusight.Overview
                 * @instance
                 */
                Overview.prototype.timestamp = null;

                /**
                 * Overview robotId.
                 * @member {number} robotId
                 * @memberof message.support.nusight.Overview
                 * @instance
                 */
                Overview.prototype.robotId = 0;

                /**
                 * The name of the binary this robot is executing
                 * @member {string} roleName
                 * @memberof message.support.nusight.Overview
                 * @instance
                 */
                Overview.prototype.roleName = "";

                /**
                 * @see message::input::Sensors::battery
                 * @member {number} battery
                 * @memberof message.support.nusight.Overview
                 * @instance
                 */
                Overview.prototype.battery = 0;

                /**
                 * @see message::input::Sensors::voltage
                 * @member {number} voltage
                 * @memberof message.support.nusight.Overview
                 * @instance
                 */
                Overview.prototype.voltage = 0;

                /**
                 * The current behaviour state. List of possible states in message::behaviour::Behaviour
                 * @member {message.behaviour.Behaviour.State} behaviourState
                 * @memberof message.support.nusight.Overview
                 * @instance
                 */
                Overview.prototype.behaviourState = 0;

                /**
                 * Localisation measured in field space
                 * @member {Ifvec3|null|undefined} robotPosition
                 * @memberof message.support.nusight.Overview
                 * @instance
                 */
                Overview.prototype.robotPosition = null;

                /**
                 * Overview robotPositionCovariance.
                 * @member {Ifmat3|null|undefined} robotPositionCovariance
                 * @memberof message.support.nusight.Overview
                 * @instance
                 */
                Overview.prototype.robotPositionCovariance = null;

                /**
                 * The ball position measured in field space
                 * @member {Ifvec2|null|undefined} ballPosition
                 * @memberof message.support.nusight.Overview
                 * @instance
                 */
                Overview.prototype.ballPosition = null;

                /**
                 * Overview ballPositionCovariance.
                 * @member {Ifmat2|null|undefined} ballPositionCovariance
                 * @memberof message.support.nusight.Overview
                 * @instance
                 */
                Overview.prototype.ballPositionCovariance = null;

                /**
                 * The {x, y} location we are kicking to
                 * @member {Ifvec2|null|undefined} kickTarget
                 * @memberof message.support.nusight.Overview
                 * @instance
                 */
                Overview.prototype.kickTarget = null;

                /**
                 * The type of game being played. From Game Controller
                 * @member {message.input.GameState.Data.Mode} gameMode
                 * @memberof message.support.nusight.Overview
                 * @instance
                 */
                Overview.prototype.gameMode = 0;

                /**
                 * The current stage of gameplay. For Game Controller
                 * @member {message.input.GameState.Data.Phase} gamePhase
                 * @memberof message.support.nusight.Overview
                 * @instance
                 */
                Overview.prototype.gamePhase = 0;

                /**
                 * Why the penalty was given. For Game Controller
                 * @member {message.input.GameState.Data.PenaltyReason} penaltyReason
                 * @memberof message.support.nusight.Overview
                 * @instance
                 */
                Overview.prototype.penaltyReason = 0;

                /**
                 * Last time the camera image was seen
                 * @member {google.protobuf.ITimestamp|null|undefined} lastCameraImage
                 * @memberof message.support.nusight.Overview
                 * @instance
                 */
                Overview.prototype.lastCameraImage = null;

                /**
                 * Last time vision objects were seen
                 * @member {google.protobuf.ITimestamp|null|undefined} lastSeenBall
                 * @memberof message.support.nusight.Overview
                 * @instance
                 */
                Overview.prototype.lastSeenBall = null;

                /**
                 * Overview lastSeenGoal.
                 * @member {google.protobuf.ITimestamp|null|undefined} lastSeenGoal
                 * @memberof message.support.nusight.Overview
                 * @instance
                 */
                Overview.prototype.lastSeenGoal = null;

                /**
                 * required rotational velocity about the z axis. In torso space
                 * @member {Ifvec3|null|undefined} walkCommand
                 * @memberof message.support.nusight.Overview
                 * @instance
                 */
                Overview.prototype.walkCommand = null;

                /**
                 * Encodes the specified Overview message. Does not implicitly {@link message.support.nusight.Overview.verify|verify} messages.
                 * @function encode
                 * @memberof message.support.nusight.Overview
                 * @static
                 * @param {message.support.nusight.IOverview} message Overview message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Overview.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                        $root.google.protobuf.Timestamp.encode(message.timestamp, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.robotId != null && Object.hasOwnProperty.call(message, "robotId"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.robotId);
                    if (message.roleName != null && Object.hasOwnProperty.call(message, "roleName"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.roleName);
                    if (message.battery != null && Object.hasOwnProperty.call(message, "battery"))
                        writer.uint32(/* id 4, wireType 5 =*/37).float(message.battery);
                    if (message.voltage != null && Object.hasOwnProperty.call(message, "voltage"))
                        writer.uint32(/* id 5, wireType 5 =*/45).float(message.voltage);
                    if (message.behaviourState != null && Object.hasOwnProperty.call(message, "behaviourState"))
                        writer.uint32(/* id 6, wireType 0 =*/48).int32(message.behaviourState);
                    if (message.robotPosition != null && Object.hasOwnProperty.call(message, "robotPosition"))
                        $root.fvec3.encode(message.robotPosition, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.robotPositionCovariance != null && Object.hasOwnProperty.call(message, "robotPositionCovariance"))
                        $root.fmat3.encode(message.robotPositionCovariance, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.ballPosition != null && Object.hasOwnProperty.call(message, "ballPosition"))
                        $root.fvec2.encode(message.ballPosition, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    if (message.ballPositionCovariance != null && Object.hasOwnProperty.call(message, "ballPositionCovariance"))
                        $root.fmat2.encode(message.ballPositionCovariance, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                    if (message.kickTarget != null && Object.hasOwnProperty.call(message, "kickTarget"))
                        $root.fvec2.encode(message.kickTarget, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                    if (message.gameMode != null && Object.hasOwnProperty.call(message, "gameMode"))
                        writer.uint32(/* id 12, wireType 0 =*/96).int32(message.gameMode);
                    if (message.gamePhase != null && Object.hasOwnProperty.call(message, "gamePhase"))
                        writer.uint32(/* id 13, wireType 0 =*/104).int32(message.gamePhase);
                    if (message.penaltyReason != null && Object.hasOwnProperty.call(message, "penaltyReason"))
                        writer.uint32(/* id 14, wireType 0 =*/112).int32(message.penaltyReason);
                    if (message.lastCameraImage != null && Object.hasOwnProperty.call(message, "lastCameraImage"))
                        $root.google.protobuf.Timestamp.encode(message.lastCameraImage, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                    if (message.lastSeenBall != null && Object.hasOwnProperty.call(message, "lastSeenBall"))
                        $root.google.protobuf.Timestamp.encode(message.lastSeenBall, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
                    if (message.lastSeenGoal != null && Object.hasOwnProperty.call(message, "lastSeenGoal"))
                        $root.google.protobuf.Timestamp.encode(message.lastSeenGoal, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                    if (message.walkCommand != null && Object.hasOwnProperty.call(message, "walkCommand"))
                        $root.fvec3.encode(message.walkCommand, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
                    return writer;
                };

                /**
                 * Decodes an Overview message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.support.nusight.Overview
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.support.nusight.Overview} Overview
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Overview.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.support.nusight.Overview();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.timestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.robotId = reader.uint32();
                            break;
                        case 3:
                            message.roleName = reader.string();
                            break;
                        case 4:
                            message.battery = reader.float();
                            break;
                        case 5:
                            message.voltage = reader.float();
                            break;
                        case 6:
                            message.behaviourState = reader.int32();
                            break;
                        case 7:
                            message.robotPosition = $root.fvec3.decode(reader, reader.uint32());
                            break;
                        case 8:
                            message.robotPositionCovariance = $root.fmat3.decode(reader, reader.uint32());
                            break;
                        case 9:
                            message.ballPosition = $root.fvec2.decode(reader, reader.uint32());
                            break;
                        case 10:
                            message.ballPositionCovariance = $root.fmat2.decode(reader, reader.uint32());
                            break;
                        case 11:
                            message.kickTarget = $root.fvec2.decode(reader, reader.uint32());
                            break;
                        case 12:
                            message.gameMode = reader.int32();
                            break;
                        case 13:
                            message.gamePhase = reader.int32();
                            break;
                        case 14:
                            message.penaltyReason = reader.int32();
                            break;
                        case 15:
                            message.lastCameraImage = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 16:
                            message.lastSeenBall = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 17:
                            message.lastSeenGoal = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 18:
                            message.walkCommand = $root.fvec3.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return Overview;
            })();

            return nusight;
        })();

        return support;
    })();

    message.vision = (function() {

        /**
         * Namespace vision.
         * @memberof message
         * @namespace
         */
        const vision = {};

        vision.Ball = (function() {

            /**
             * Properties of a Ball.
             * @memberof message.vision
             * @interface IBall
             * @property {Ifvec3|null} [uBCc] Central axis unit vector of the ball from the camera in camera space
             * @property {number|null} [radius] Cosine of the angle from the centre of the ball to the edge of the ball
             * @property {Array.<message.vision.Ball.IMeasurement>|null} [measurements] Different methods of measurements are taken to help ball localisation determine the true position
             * @property {Ifvec4|null} [colour] the reason it was discarded
             */

            /**
             * Constructs a new Ball.
             * @memberof message.vision
             * @classdesc Represents a Ball.
             * @implements IBall
             * @constructor
             * @param {message.vision.IBall=} [properties] Properties to set
             */
            function Ball(properties) {
                this.measurements = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Central axis unit vector of the ball from the camera in camera space
             * @member {Ifvec3|null|undefined} uBCc
             * @memberof message.vision.Ball
             * @instance
             */
            Ball.prototype.uBCc = null;

            /**
             * Cosine of the angle from the centre of the ball to the edge of the ball
             * @member {number} radius
             * @memberof message.vision.Ball
             * @instance
             */
            Ball.prototype.radius = 0;

            /**
             * Different methods of measurements are taken to help ball localisation determine the true position
             * @member {Array.<message.vision.Ball.IMeasurement>} measurements
             * @memberof message.vision.Ball
             * @instance
             */
            Ball.prototype.measurements = $util.emptyArray;

            /**
             * the reason it was discarded
             * @member {Ifvec4|null|undefined} colour
             * @memberof message.vision.Ball
             * @instance
             */
            Ball.prototype.colour = null;

            /**
             * Encodes the specified Ball message. Does not implicitly {@link message.vision.Ball.verify|verify} messages.
             * @function encode
             * @memberof message.vision.Ball
             * @static
             * @param {message.vision.IBall} message Ball message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Ball.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uBCc != null && Object.hasOwnProperty.call(message, "uBCc"))
                    $root.fvec3.encode(message.uBCc, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.radius != null && Object.hasOwnProperty.call(message, "radius"))
                    writer.uint32(/* id 2, wireType 5 =*/21).float(message.radius);
                if (message.measurements != null && message.measurements.length)
                    for (let i = 0; i < message.measurements.length; ++i)
                        $root.message.vision.Ball.Measurement.encode(message.measurements[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.colour != null && Object.hasOwnProperty.call(message, "colour"))
                    $root.fvec4.encode(message.colour, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a Ball message from the specified reader or buffer.
             * @function decode
             * @memberof message.vision.Ball
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.vision.Ball} Ball
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Ball.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.vision.Ball();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.uBCc = $root.fvec3.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.radius = reader.float();
                        break;
                    case 4:
                        if (!(message.measurements && message.measurements.length))
                            message.measurements = [];
                        message.measurements.push($root.message.vision.Ball.Measurement.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        message.colour = $root.fvec4.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Method of measuring the ball position
             * @name message.vision.Ball.MeasurementType
             * @enum {number}
             * @property {number} UNKNOWN=0 UNKNOWN value
             * @property {number} PROJECTION=1 PROJECTION value
             * @property {number} ANGULAR=2 ANGULAR value
             */
            Ball.MeasurementType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN"] = 0;
                values[valuesById[1] = "PROJECTION"] = 1;
                values[valuesById[2] = "ANGULAR"] = 2;
                return values;
            })();

            Ball.Measurement = (function() {

                /**
                 * Properties of a Measurement.
                 * @memberof message.vision.Ball
                 * @interface IMeasurement
                 * @property {message.vision.Ball.MeasurementType|null} [type] Measurement type
                 * @property {Ifvec3|null} [srBCc] Gives a better representation of the error of the measurement, since error comes from the angular position
                 * @property {Ifmat3|null} [covariance] Confidence of this measurement, for localisation
                 */

                /**
                 * Constructs a new Measurement.
                 * @memberof message.vision.Ball
                 * @classdesc and the certainty of the measurement
                 * @implements IMeasurement
                 * @constructor
                 * @param {message.vision.Ball.IMeasurement=} [properties] Properties to set
                 */
                function Measurement(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Measurement type.
                 * @member {message.vision.Ball.MeasurementType} type
                 * @memberof message.vision.Ball.Measurement
                 * @instance
                 */
                Measurement.prototype.type = 0;

                /**
                 * Gives a better representation of the error of the measurement, since error comes from the angular position
                 * @member {Ifvec3|null|undefined} srBCc
                 * @memberof message.vision.Ball.Measurement
                 * @instance
                 */
                Measurement.prototype.srBCc = null;

                /**
                 * Confidence of this measurement, for localisation
                 * @member {Ifmat3|null|undefined} covariance
                 * @memberof message.vision.Ball.Measurement
                 * @instance
                 */
                Measurement.prototype.covariance = null;

                /**
                 * Encodes the specified Measurement message. Does not implicitly {@link message.vision.Ball.Measurement.verify|verify} messages.
                 * @function encode
                 * @memberof message.vision.Ball.Measurement
                 * @static
                 * @param {message.vision.Ball.IMeasurement} message Measurement message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Measurement.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                    if (message.srBCc != null && Object.hasOwnProperty.call(message, "srBCc"))
                        $root.fvec3.encode(message.srBCc, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.covariance != null && Object.hasOwnProperty.call(message, "covariance"))
                        $root.fmat3.encode(message.covariance, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Decodes a Measurement message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.vision.Ball.Measurement
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.vision.Ball.Measurement} Measurement
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Measurement.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.vision.Ball.Measurement();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.type = reader.int32();
                            break;
                        case 2:
                            message.srBCc = $root.fvec3.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.covariance = $root.fmat3.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return Measurement;
            })();

            return Ball;
        })();

        vision.Balls = (function() {

            /**
             * Properties of a Balls.
             * @memberof message.vision
             * @interface IBalls
             * @property {number|null} [id] ID of the camera that took the image containing the balls
             * @property {google.protobuf.ITimestamp|null} [timestamp] When the image was taken that this measurement is derived from
             * @property {Imat4|null} [Hcw] Isometry3d transform from world space to camera space at the time that the image was taken
             * @property {Array.<message.vision.IBall>|null} [balls] Could be empty, if there were no balls detected in the image
             */

            /**
             * Constructs a new Balls.
             * @memberof message.vision
             * @classdesc Represents a Balls.
             * @implements IBalls
             * @constructor
             * @param {message.vision.IBalls=} [properties] Properties to set
             */
            function Balls(properties) {
                this.balls = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ID of the camera that took the image containing the balls
             * @member {number} id
             * @memberof message.vision.Balls
             * @instance
             */
            Balls.prototype.id = 0;

            /**
             * When the image was taken that this measurement is derived from
             * @member {google.protobuf.ITimestamp|null|undefined} timestamp
             * @memberof message.vision.Balls
             * @instance
             */
            Balls.prototype.timestamp = null;

            /**
             * Isometry3d transform from world space to camera space at the time that the image was taken
             * @member {Imat4|null|undefined} Hcw
             * @memberof message.vision.Balls
             * @instance
             */
            Balls.prototype.Hcw = null;

            /**
             * Could be empty, if there were no balls detected in the image
             * @member {Array.<message.vision.IBall>} balls
             * @memberof message.vision.Balls
             * @instance
             */
            Balls.prototype.balls = $util.emptyArray;

            /**
             * Encodes the specified Balls message. Does not implicitly {@link message.vision.Balls.verify|verify} messages.
             * @function encode
             * @memberof message.vision.Balls
             * @static
             * @param {message.vision.IBalls} message Balls message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Balls.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    $root.google.protobuf.Timestamp.encode(message.timestamp, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.Hcw != null && Object.hasOwnProperty.call(message, "Hcw"))
                    $root.mat4.encode(message.Hcw, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.balls != null && message.balls.length)
                    for (let i = 0; i < message.balls.length; ++i)
                        $root.message.vision.Ball.encode(message.balls[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a Balls message from the specified reader or buffer.
             * @function decode
             * @memberof message.vision.Balls
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.vision.Balls} Balls
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Balls.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.vision.Balls();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.uint32();
                        break;
                    case 2:
                        message.timestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.Hcw = $root.mat4.decode(reader, reader.uint32());
                        break;
                    case 4:
                        if (!(message.balls && message.balls.length))
                            message.balls = [];
                        message.balls.push($root.message.vision.Ball.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return Balls;
        })();

        vision.FieldLines = (function() {

            /**
             * Properties of a FieldLines.
             * @memberof message.vision
             * @interface IFieldLines
             * @property {number|null} [id] ID of the camera that took the image containing the lines
             * @property {google.protobuf.ITimestamp|null} [timestamp] When the image was taken that this measurement is derived from
             * @property {Imat4|null} [Hcw] Affine3d transform from world space to camera space at the time that the image was taken
             * @property {Array.<Ifvec3>|null} [points] Could be empty, if there were no lines detected in the image
             */

            /**
             * Constructs a new FieldLines.
             * @memberof message.vision
             * @classdesc Represents a FieldLines.
             * @implements IFieldLines
             * @constructor
             * @param {message.vision.IFieldLines=} [properties] Properties to set
             */
            function FieldLines(properties) {
                this.points = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ID of the camera that took the image containing the lines
             * @member {number} id
             * @memberof message.vision.FieldLines
             * @instance
             */
            FieldLines.prototype.id = 0;

            /**
             * When the image was taken that this measurement is derived from
             * @member {google.protobuf.ITimestamp|null|undefined} timestamp
             * @memberof message.vision.FieldLines
             * @instance
             */
            FieldLines.prototype.timestamp = null;

            /**
             * Affine3d transform from world space to camera space at the time that the image was taken
             * @member {Imat4|null|undefined} Hcw
             * @memberof message.vision.FieldLines
             * @instance
             */
            FieldLines.prototype.Hcw = null;

            /**
             * Could be empty, if there were no lines detected in the image
             * @member {Array.<Ifvec3>} points
             * @memberof message.vision.FieldLines
             * @instance
             */
            FieldLines.prototype.points = $util.emptyArray;

            /**
             * Encodes the specified FieldLines message. Does not implicitly {@link message.vision.FieldLines.verify|verify} messages.
             * @function encode
             * @memberof message.vision.FieldLines
             * @static
             * @param {message.vision.IFieldLines} message FieldLines message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldLines.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    $root.google.protobuf.Timestamp.encode(message.timestamp, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.Hcw != null && Object.hasOwnProperty.call(message, "Hcw"))
                    $root.mat4.encode(message.Hcw, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.points != null && message.points.length)
                    for (let i = 0; i < message.points.length; ++i)
                        $root.fvec3.encode(message.points[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a FieldLines message from the specified reader or buffer.
             * @function decode
             * @memberof message.vision.FieldLines
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.vision.FieldLines} FieldLines
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldLines.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.vision.FieldLines();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.uint32();
                        break;
                    case 2:
                        message.timestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.Hcw = $root.mat4.decode(reader, reader.uint32());
                        break;
                    case 4:
                        if (!(message.points && message.points.length))
                            message.points = [];
                        message.points.push($root.fvec3.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return FieldLines;
        })();

        vision.Goal = (function() {

            /**
             * Properties of a Goal.
             * @memberof message.vision
             * @interface IGoal
             * @property {message.vision.Goal.Side|null} [side] Goal side
             * @property {message.vision.Goal.IPost|null} [post] Goal post
             * @property {Array.<message.vision.Goal.IMeasurement>|null} [measurements] Goal measurements
             * @property {Ifvec2|null} [screenAngular] Goal screenAngular
             * @property {Ifvec2|null} [angularSize] Goal angularSize
             */

            /**
             * Constructs a new Goal.
             * @memberof message.vision
             * @classdesc Represents a Goal.
             * @implements IGoal
             * @constructor
             * @param {message.vision.IGoal=} [properties] Properties to set
             */
            function Goal(properties) {
                this.measurements = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Goal side.
             * @member {message.vision.Goal.Side} side
             * @memberof message.vision.Goal
             * @instance
             */
            Goal.prototype.side = 0;

            /**
             * Goal post.
             * @member {message.vision.Goal.IPost|null|undefined} post
             * @memberof message.vision.Goal
             * @instance
             */
            Goal.prototype.post = null;

            /**
             * Goal measurements.
             * @member {Array.<message.vision.Goal.IMeasurement>} measurements
             * @memberof message.vision.Goal
             * @instance
             */
            Goal.prototype.measurements = $util.emptyArray;

            /**
             * Goal screenAngular.
             * @member {Ifvec2|null|undefined} screenAngular
             * @memberof message.vision.Goal
             * @instance
             */
            Goal.prototype.screenAngular = null;

            /**
             * Goal angularSize.
             * @member {Ifvec2|null|undefined} angularSize
             * @memberof message.vision.Goal
             * @instance
             */
            Goal.prototype.angularSize = null;

            /**
             * Encodes the specified Goal message. Does not implicitly {@link message.vision.Goal.verify|verify} messages.
             * @function encode
             * @memberof message.vision.Goal
             * @static
             * @param {message.vision.IGoal} message Goal message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Goal.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.side != null && Object.hasOwnProperty.call(message, "side"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.side);
                if (message.post != null && Object.hasOwnProperty.call(message, "post"))
                    $root.message.vision.Goal.Post.encode(message.post, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.measurements != null && message.measurements.length)
                    for (let i = 0; i < message.measurements.length; ++i)
                        $root.message.vision.Goal.Measurement.encode(message.measurements[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.screenAngular != null && Object.hasOwnProperty.call(message, "screenAngular"))
                    $root.fvec2.encode(message.screenAngular, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.angularSize != null && Object.hasOwnProperty.call(message, "angularSize"))
                    $root.fvec2.encode(message.angularSize, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a Goal message from the specified reader or buffer.
             * @function decode
             * @memberof message.vision.Goal
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.vision.Goal} Goal
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Goal.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.vision.Goal();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.side = reader.int32();
                        break;
                    case 3:
                        message.post = $root.message.vision.Goal.Post.decode(reader, reader.uint32());
                        break;
                    case 4:
                        if (!(message.measurements && message.measurements.length))
                            message.measurements = [];
                        message.measurements.push($root.message.vision.Goal.Measurement.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        message.screenAngular = $root.fvec2.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.angularSize = $root.fvec2.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Side enum.
             * @name message.vision.Goal.Side
             * @enum {number}
             * @property {number} UNKNOWN_SIDE=0 UNKNOWN_SIDE value
             * @property {number} LEFT=1 LEFT value
             * @property {number} RIGHT=2 RIGHT value
             */
            Goal.Side = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN_SIDE"] = 0;
                values[valuesById[1] = "LEFT"] = 1;
                values[valuesById[2] = "RIGHT"] = 2;
                return values;
            })();

            /**
             * Which team the goals belong to
             * @name message.vision.Goal.Team
             * @enum {number}
             * @property {number} UNKNOWN_TEAM=0 UNKNOWN_TEAM value
             * @property {number} OWN=1 OWN value
             * @property {number} OPPONENT=2 OPPONENT value
             */
            Goal.Team = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN_TEAM"] = 0;
                values[valuesById[1] = "OWN"] = 1;
                values[valuesById[2] = "OPPONENT"] = 2;
                return values;
            })();

            /**
             * MeasurementType enum.
             * @name message.vision.Goal.MeasurementType
             * @enum {number}
             * @property {number} UNKNOWN=0 UNKNOWN value
             * @property {number} CENTRE=1 The distance is from the camera to bottom centre of post
             */
            Goal.MeasurementType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN"] = 0;
                values[valuesById[1] = "CENTRE"] = 1;
                return values;
            })();

            Goal.Measurement = (function() {

                /**
                 * Properties of a Measurement.
                 * @memberof message.vision.Goal
                 * @interface IMeasurement
                 * @property {message.vision.Goal.MeasurementType|null} [type] Measurement type
                 * @property {Ifvec3|null} [srGCc] Normal vectors point inwards towards the centre of the object
                 * @property {Ifmat3|null} [covariance] Measurement covariance
                 */

                /**
                 * Constructs a new Measurement.
                 * @memberof message.vision.Goal
                 * @classdesc Represents a Measurement.
                 * @implements IMeasurement
                 * @constructor
                 * @param {message.vision.Goal.IMeasurement=} [properties] Properties to set
                 */
                function Measurement(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Measurement type.
                 * @member {message.vision.Goal.MeasurementType} type
                 * @memberof message.vision.Goal.Measurement
                 * @instance
                 */
                Measurement.prototype.type = 0;

                /**
                 * Normal vectors point inwards towards the centre of the object
                 * @member {Ifvec3|null|undefined} srGCc
                 * @memberof message.vision.Goal.Measurement
                 * @instance
                 */
                Measurement.prototype.srGCc = null;

                /**
                 * Measurement covariance.
                 * @member {Ifmat3|null|undefined} covariance
                 * @memberof message.vision.Goal.Measurement
                 * @instance
                 */
                Measurement.prototype.covariance = null;

                /**
                 * Encodes the specified Measurement message. Does not implicitly {@link message.vision.Goal.Measurement.verify|verify} messages.
                 * @function encode
                 * @memberof message.vision.Goal.Measurement
                 * @static
                 * @param {message.vision.Goal.IMeasurement} message Measurement message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Measurement.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                    if (message.srGCc != null && Object.hasOwnProperty.call(message, "srGCc"))
                        $root.fvec3.encode(message.srGCc, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.covariance != null && Object.hasOwnProperty.call(message, "covariance"))
                        $root.fmat3.encode(message.covariance, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Decodes a Measurement message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.vision.Goal.Measurement
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.vision.Goal.Measurement} Measurement
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Measurement.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.vision.Goal.Measurement();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.type = reader.int32();
                            break;
                        case 2:
                            message.srGCc = $root.fvec3.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.covariance = $root.fmat3.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return Measurement;
            })();

            Goal.Post = (function() {

                /**
                 * Properties of a Post.
                 * @memberof message.vision.Goal
                 * @interface IPost
                 * @property {Ifvec3|null} [top] Vector pointing to top point of post in camera space
                 * @property {Ifvec3|null} [bottom] Vector pointing to bottom point of post in camera space
                 * @property {number|null} [distance] Distance from camera to goals, in metres
                 */

                /**
                 * Constructs a new Post.
                 * @memberof message.vision.Goal
                 * @classdesc Represents a Post.
                 * @implements IPost
                 * @constructor
                 * @param {message.vision.Goal.IPost=} [properties] Properties to set
                 */
                function Post(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Vector pointing to top point of post in camera space
                 * @member {Ifvec3|null|undefined} top
                 * @memberof message.vision.Goal.Post
                 * @instance
                 */
                Post.prototype.top = null;

                /**
                 * Vector pointing to bottom point of post in camera space
                 * @member {Ifvec3|null|undefined} bottom
                 * @memberof message.vision.Goal.Post
                 * @instance
                 */
                Post.prototype.bottom = null;

                /**
                 * Distance from camera to goals, in metres
                 * @member {number} distance
                 * @memberof message.vision.Goal.Post
                 * @instance
                 */
                Post.prototype.distance = 0;

                /**
                 * Encodes the specified Post message. Does not implicitly {@link message.vision.Goal.Post.verify|verify} messages.
                 * @function encode
                 * @memberof message.vision.Goal.Post
                 * @static
                 * @param {message.vision.Goal.IPost} message Post message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Post.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.top != null && Object.hasOwnProperty.call(message, "top"))
                        $root.fvec3.encode(message.top, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.bottom != null && Object.hasOwnProperty.call(message, "bottom"))
                        $root.fvec3.encode(message.bottom, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.distance != null && Object.hasOwnProperty.call(message, "distance"))
                        writer.uint32(/* id 3, wireType 5 =*/29).float(message.distance);
                    return writer;
                };

                /**
                 * Decodes a Post message from the specified reader or buffer.
                 * @function decode
                 * @memberof message.vision.Goal.Post
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.vision.Goal.Post} Post
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Post.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.vision.Goal.Post();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.top = $root.fvec3.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.bottom = $root.fvec3.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.distance = reader.float();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return Post;
            })();

            return Goal;
        })();

        vision.Goals = (function() {

            /**
             * Properties of a Goals.
             * @memberof message.vision
             * @interface IGoals
             * @property {number|null} [id] Goals id
             * @property {google.protobuf.ITimestamp|null} [timestamp] Goals timestamp
             * @property {Imat4|null} [Hcw] Isometry3d transform from world space to camera space at the time that the image was taken
             * @property {Array.<message.vision.IGoal>|null} [goals] Goals goals
             */

            /**
             * Constructs a new Goals.
             * @memberof message.vision
             * @classdesc Represents a Goals.
             * @implements IGoals
             * @constructor
             * @param {message.vision.IGoals=} [properties] Properties to set
             */
            function Goals(properties) {
                this.goals = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Goals id.
             * @member {number} id
             * @memberof message.vision.Goals
             * @instance
             */
            Goals.prototype.id = 0;

            /**
             * Goals timestamp.
             * @member {google.protobuf.ITimestamp|null|undefined} timestamp
             * @memberof message.vision.Goals
             * @instance
             */
            Goals.prototype.timestamp = null;

            /**
             * Isometry3d transform from world space to camera space at the time that the image was taken
             * @member {Imat4|null|undefined} Hcw
             * @memberof message.vision.Goals
             * @instance
             */
            Goals.prototype.Hcw = null;

            /**
             * Goals goals.
             * @member {Array.<message.vision.IGoal>} goals
             * @memberof message.vision.Goals
             * @instance
             */
            Goals.prototype.goals = $util.emptyArray;

            /**
             * Encodes the specified Goals message. Does not implicitly {@link message.vision.Goals.verify|verify} messages.
             * @function encode
             * @memberof message.vision.Goals
             * @static
             * @param {message.vision.IGoals} message Goals message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Goals.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    $root.google.protobuf.Timestamp.encode(message.timestamp, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.Hcw != null && Object.hasOwnProperty.call(message, "Hcw"))
                    $root.mat4.encode(message.Hcw, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.goals != null && message.goals.length)
                    for (let i = 0; i < message.goals.length; ++i)
                        $root.message.vision.Goal.encode(message.goals[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a Goals message from the specified reader or buffer.
             * @function decode
             * @memberof message.vision.Goals
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.vision.Goals} Goals
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Goals.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.vision.Goals();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.uint32();
                        break;
                    case 2:
                        message.timestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.Hcw = $root.mat4.decode(reader, reader.uint32());
                        break;
                    case 4:
                        if (!(message.goals && message.goals.length))
                            message.goals = [];
                        message.goals.push($root.message.vision.Goal.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return Goals;
        })();

        vision.GreenHorizon = (function() {

            /**
             * Properties of a GreenHorizon.
             * @memberof message.vision
             * @interface IGreenHorizon
             * @property {Array.<Ifvec3>|null} [horizon] A set of rays in world space, projected to the ground. They comprise the points in the convex hull
             * @property {Imat4|null} [Hcw] Isometry3d transform from world space to camera space at the time that the image was taken
             * @property {number|null} [id] ID of the camera that took the image containing the green horizon
             * @property {message.vision.IVisualMesh|null} [mesh] The visual mesh that this green horizon was calculated from
             * @property {google.protobuf.ITimestamp|null} [timestamp] When the image was taken that this measurement is derived from
             * @property {Object.<string,number>|null} [classMap] A mapping from class names to column indices (for accessing the corresponding classification column)
             * @property {message.platform.webots.IVisionGroundTruth|null} [visionGroundTruth] Ground truth data from webots
             */

            /**
             * Constructs a new GreenHorizon.
             * @memberof message.vision
             * @classdesc Represents a GreenHorizon.
             * @implements IGreenHorizon
             * @constructor
             * @param {message.vision.IGreenHorizon=} [properties] Properties to set
             */
            function GreenHorizon(properties) {
                this.horizon = [];
                this.classMap = {};
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * A set of rays in world space, projected to the ground. They comprise the points in the convex hull
             * @member {Array.<Ifvec3>} horizon
             * @memberof message.vision.GreenHorizon
             * @instance
             */
            GreenHorizon.prototype.horizon = $util.emptyArray;

            /**
             * Isometry3d transform from world space to camera space at the time that the image was taken
             * @member {Imat4|null|undefined} Hcw
             * @memberof message.vision.GreenHorizon
             * @instance
             */
            GreenHorizon.prototype.Hcw = null;

            /**
             * ID of the camera that took the image containing the green horizon
             * @member {number} id
             * @memberof message.vision.GreenHorizon
             * @instance
             */
            GreenHorizon.prototype.id = 0;

            /**
             * The visual mesh that this green horizon was calculated from
             * @member {message.vision.IVisualMesh|null|undefined} mesh
             * @memberof message.vision.GreenHorizon
             * @instance
             */
            GreenHorizon.prototype.mesh = null;

            /**
             * When the image was taken that this measurement is derived from
             * @member {google.protobuf.ITimestamp|null|undefined} timestamp
             * @memberof message.vision.GreenHorizon
             * @instance
             */
            GreenHorizon.prototype.timestamp = null;

            /**
             * A mapping from class names to column indices (for accessing the corresponding classification column)
             * @member {Object.<string,number>} classMap
             * @memberof message.vision.GreenHorizon
             * @instance
             */
            GreenHorizon.prototype.classMap = $util.emptyObject;

            /**
             * Ground truth data from webots
             * @member {message.platform.webots.IVisionGroundTruth|null|undefined} visionGroundTruth
             * @memberof message.vision.GreenHorizon
             * @instance
             */
            GreenHorizon.prototype.visionGroundTruth = null;

            /**
             * Encodes the specified GreenHorizon message. Does not implicitly {@link message.vision.GreenHorizon.verify|verify} messages.
             * @function encode
             * @memberof message.vision.GreenHorizon
             * @static
             * @param {message.vision.IGreenHorizon} message GreenHorizon message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GreenHorizon.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.horizon != null && message.horizon.length)
                    for (let i = 0; i < message.horizon.length; ++i)
                        $root.fvec3.encode(message.horizon[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.Hcw != null && Object.hasOwnProperty.call(message, "Hcw"))
                    $root.mat4.encode(message.Hcw, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.id);
                if (message.mesh != null && Object.hasOwnProperty.call(message, "mesh"))
                    $root.message.vision.VisualMesh.encode(message.mesh, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    $root.google.protobuf.Timestamp.encode(message.timestamp, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.classMap != null && Object.hasOwnProperty.call(message, "classMap"))
                    for (let keys = Object.keys(message.classMap), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 6, wireType 2 =*/50).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 0 =*/16).uint32(message.classMap[keys[i]]).ldelim();
                if (message.visionGroundTruth != null && Object.hasOwnProperty.call(message, "visionGroundTruth"))
                    $root.message.platform.webots.VisionGroundTruth.encode(message.visionGroundTruth, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a GreenHorizon message from the specified reader or buffer.
             * @function decode
             * @memberof message.vision.GreenHorizon
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.vision.GreenHorizon} GreenHorizon
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GreenHorizon.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.vision.GreenHorizon(), key, value;
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.horizon && message.horizon.length))
                            message.horizon = [];
                        message.horizon.push($root.fvec3.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        message.Hcw = $root.mat4.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.id = reader.uint32();
                        break;
                    case 4:
                        message.mesh = $root.message.vision.VisualMesh.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.timestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 6:
                        if (message.classMap === $util.emptyObject)
                            message.classMap = {};
                        let end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = 0;
                        while (reader.pos < end2) {
                            let tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.uint32();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.classMap[key] = value;
                        break;
                    case 7:
                        message.visionGroundTruth = $root.message.platform.webots.VisionGroundTruth.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return GreenHorizon;
        })();

        vision.Obstacle = (function() {

            /**
             * Properties of an Obstacle.
             * @memberof message.vision
             * @interface IObstacle
             * @property {number|null} [id] ID of the camera that took the image containing the obstacle
             * @property {google.protobuf.ITimestamp|null} [timestamp] When the obstacle was seen
             * @property {message.IPolygon|null} [shape] {x, y} points bounding the location of the obstacle
             * @property {message.vision.Obstacle.Team|null} [team] Obstacle team
             */

            /**
             * Constructs a new Obstacle.
             * @memberof message.vision
             * @classdesc Represents an Obstacle.
             * @implements IObstacle
             * @constructor
             * @param {message.vision.IObstacle=} [properties] Properties to set
             */
            function Obstacle(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ID of the camera that took the image containing the obstacle
             * @member {number} id
             * @memberof message.vision.Obstacle
             * @instance
             */
            Obstacle.prototype.id = 0;

            /**
             * When the obstacle was seen
             * @member {google.protobuf.ITimestamp|null|undefined} timestamp
             * @memberof message.vision.Obstacle
             * @instance
             */
            Obstacle.prototype.timestamp = null;

            /**
             * {x, y} points bounding the location of the obstacle
             * @member {message.IPolygon|null|undefined} shape
             * @memberof message.vision.Obstacle
             * @instance
             */
            Obstacle.prototype.shape = null;

            /**
             * Obstacle team.
             * @member {message.vision.Obstacle.Team} team
             * @memberof message.vision.Obstacle
             * @instance
             */
            Obstacle.prototype.team = 0;

            /**
             * Encodes the specified Obstacle message. Does not implicitly {@link message.vision.Obstacle.verify|verify} messages.
             * @function encode
             * @memberof message.vision.Obstacle
             * @static
             * @param {message.vision.IObstacle} message Obstacle message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Obstacle.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    $root.google.protobuf.Timestamp.encode(message.timestamp, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.shape != null && Object.hasOwnProperty.call(message, "shape"))
                    $root.message.Polygon.encode(message.shape, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.team != null && Object.hasOwnProperty.call(message, "team"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.team);
                return writer;
            };

            /**
             * Decodes an Obstacle message from the specified reader or buffer.
             * @function decode
             * @memberof message.vision.Obstacle
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.vision.Obstacle} Obstacle
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Obstacle.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.vision.Obstacle();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.uint32();
                        break;
                    case 2:
                        message.timestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.shape = $root.message.Polygon.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.team = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Team enum.
             * @name message.vision.Obstacle.Team
             * @enum {number}
             * @property {number} UNKNOWN_TEAM=0 UNKNOWN_TEAM value
             * @property {number} MAGENTA=1 MAGENTA value
             * @property {number} CYAN=2 CYAN value
             */
            Obstacle.Team = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN_TEAM"] = 0;
                values[valuesById[1] = "MAGENTA"] = 1;
                values[valuesById[2] = "CYAN"] = 2;
                return values;
            })();

            return Obstacle;
        })();

        vision.Obstacles = (function() {

            /**
             * Properties of an Obstacles.
             * @memberof message.vision
             * @interface IObstacles
             * @property {Array.<message.vision.IObstacle>|null} [lines] Obstacles lines
             */

            /**
             * Constructs a new Obstacles.
             * @memberof message.vision
             * @classdesc Represents an Obstacles.
             * @implements IObstacles
             * @constructor
             * @param {message.vision.IObstacles=} [properties] Properties to set
             */
            function Obstacles(properties) {
                this.lines = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Obstacles lines.
             * @member {Array.<message.vision.IObstacle>} lines
             * @memberof message.vision.Obstacles
             * @instance
             */
            Obstacles.prototype.lines = $util.emptyArray;

            /**
             * Encodes the specified Obstacles message. Does not implicitly {@link message.vision.Obstacles.verify|verify} messages.
             * @function encode
             * @memberof message.vision.Obstacles
             * @static
             * @param {message.vision.IObstacles} message Obstacles message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Obstacles.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.lines != null && message.lines.length)
                    for (let i = 0; i < message.lines.length; ++i)
                        $root.message.vision.Obstacle.encode(message.lines[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes an Obstacles message from the specified reader or buffer.
             * @function decode
             * @memberof message.vision.Obstacles
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.vision.Obstacles} Obstacles
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Obstacles.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.vision.Obstacles();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.lines && message.lines.length))
                            message.lines = [];
                        message.lines.push($root.message.vision.Obstacle.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return Obstacles;
        })();

        vision.VisualMesh = (function() {

            /**
             * Properties of a VisualMesh.
             * @memberof message.vision
             * @interface IVisualMesh
             * @property {google.protobuf.ITimestamp|null} [timestamp] Time this message was created
             * @property {number|null} [id] ID of the camera that this mesh was constructed from
             * @property {string|null} [name] name of the camera that this mesh was constructed from
             * @property {Imat4|null} [Hcw] World to camera transform that this mesh was constructed with
             * @property {Ifmat|null} [coordinates] Pixel coordinates projected from the rays
             * @property {Iimat|null} [neighbourhood] Neighbours of each node in the mesh. Each row corresponds to a node and the columns are the neighbours
             * @property {Array.<number>|null} [indices] The corresponding global indices for each on-screen node
             * @property {Ifmat|null} [classifications] class. The mapping from columns to classes is dependant on how the classes were presented during training
             * @property {Ifmat|null} [rays] Unit vectors pointing from the camera to each node in the mesh
             * @property {Object.<string,number>|null} [classMap] A mapping from class names to column indices (for accessing the corresponding classification column)
             * @property {message.platform.webots.IVisionGroundTruth|null} [visionGroundTruth] Ground truth data from webots
             */

            /**
             * Constructs a new VisualMesh.
             * @memberof message.vision
             * @classdesc Represents a VisualMesh.
             * @implements IVisualMesh
             * @constructor
             * @param {message.vision.IVisualMesh=} [properties] Properties to set
             */
            function VisualMesh(properties) {
                this.indices = [];
                this.classMap = {};
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Time this message was created
             * @member {google.protobuf.ITimestamp|null|undefined} timestamp
             * @memberof message.vision.VisualMesh
             * @instance
             */
            VisualMesh.prototype.timestamp = null;

            /**
             * ID of the camera that this mesh was constructed from
             * @member {number} id
             * @memberof message.vision.VisualMesh
             * @instance
             */
            VisualMesh.prototype.id = 0;

            /**
             * name of the camera that this mesh was constructed from
             * @member {string} name
             * @memberof message.vision.VisualMesh
             * @instance
             */
            VisualMesh.prototype.name = "";

            /**
             * World to camera transform that this mesh was constructed with
             * @member {Imat4|null|undefined} Hcw
             * @memberof message.vision.VisualMesh
             * @instance
             */
            VisualMesh.prototype.Hcw = null;

            /**
             * Pixel coordinates projected from the rays
             * @member {Ifmat|null|undefined} coordinates
             * @memberof message.vision.VisualMesh
             * @instance
             */
            VisualMesh.prototype.coordinates = null;

            /**
             * Neighbours of each node in the mesh. Each row corresponds to a node and the columns are the neighbours
             * @member {Iimat|null|undefined} neighbourhood
             * @memberof message.vision.VisualMesh
             * @instance
             */
            VisualMesh.prototype.neighbourhood = null;

            /**
             * The corresponding global indices for each on-screen node
             * @member {Array.<number>} indices
             * @memberof message.vision.VisualMesh
             * @instance
             */
            VisualMesh.prototype.indices = $util.emptyArray;

            /**
             * class. The mapping from columns to classes is dependant on how the classes were presented during training
             * @member {Ifmat|null|undefined} classifications
             * @memberof message.vision.VisualMesh
             * @instance
             */
            VisualMesh.prototype.classifications = null;

            /**
             * Unit vectors pointing from the camera to each node in the mesh
             * @member {Ifmat|null|undefined} rays
             * @memberof message.vision.VisualMesh
             * @instance
             */
            VisualMesh.prototype.rays = null;

            /**
             * A mapping from class names to column indices (for accessing the corresponding classification column)
             * @member {Object.<string,number>} classMap
             * @memberof message.vision.VisualMesh
             * @instance
             */
            VisualMesh.prototype.classMap = $util.emptyObject;

            /**
             * Ground truth data from webots
             * @member {message.platform.webots.IVisionGroundTruth|null|undefined} visionGroundTruth
             * @memberof message.vision.VisualMesh
             * @instance
             */
            VisualMesh.prototype.visionGroundTruth = null;

            /**
             * Encodes the specified VisualMesh message. Does not implicitly {@link message.vision.VisualMesh.verify|verify} messages.
             * @function encode
             * @memberof message.vision.VisualMesh
             * @static
             * @param {message.vision.IVisualMesh} message VisualMesh message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VisualMesh.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    $root.google.protobuf.Timestamp.encode(message.timestamp, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.id);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
                if (message.Hcw != null && Object.hasOwnProperty.call(message, "Hcw"))
                    $root.mat4.encode(message.Hcw, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.coordinates != null && Object.hasOwnProperty.call(message, "coordinates"))
                    $root.fmat.encode(message.coordinates, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.neighbourhood != null && Object.hasOwnProperty.call(message, "neighbourhood"))
                    $root.imat.encode(message.neighbourhood, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.indices != null && message.indices.length) {
                    writer.uint32(/* id 7, wireType 2 =*/58).fork();
                    for (let i = 0; i < message.indices.length; ++i)
                        writer.int32(message.indices[i]);
                    writer.ldelim();
                }
                if (message.classifications != null && Object.hasOwnProperty.call(message, "classifications"))
                    $root.fmat.encode(message.classifications, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.rays != null && Object.hasOwnProperty.call(message, "rays"))
                    $root.fmat.encode(message.rays, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.classMap != null && Object.hasOwnProperty.call(message, "classMap"))
                    for (let keys = Object.keys(message.classMap), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 10, wireType 2 =*/82).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 0 =*/16).uint32(message.classMap[keys[i]]).ldelim();
                if (message.visionGroundTruth != null && Object.hasOwnProperty.call(message, "visionGroundTruth"))
                    $root.message.platform.webots.VisionGroundTruth.encode(message.visionGroundTruth, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a VisualMesh message from the specified reader or buffer.
             * @function decode
             * @memberof message.vision.VisualMesh
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.vision.VisualMesh} VisualMesh
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VisualMesh.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.vision.VisualMesh(), key, value;
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.timestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.id = reader.uint32();
                        break;
                    case 3:
                        message.name = reader.string();
                        break;
                    case 4:
                        message.Hcw = $root.mat4.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.coordinates = $root.fmat.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.neighbourhood = $root.imat.decode(reader, reader.uint32());
                        break;
                    case 7:
                        if (!(message.indices && message.indices.length))
                            message.indices = [];
                        if ((tag & 7) === 2) {
                            let end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.indices.push(reader.int32());
                        } else
                            message.indices.push(reader.int32());
                        break;
                    case 8:
                        message.classifications = $root.fmat.decode(reader, reader.uint32());
                        break;
                    case 9:
                        message.rays = $root.fmat.decode(reader, reader.uint32());
                        break;
                    case 10:
                        if (message.classMap === $util.emptyObject)
                            message.classMap = {};
                        let end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = 0;
                        while (reader.pos < end2) {
                            let tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.uint32();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.classMap[key] = value;
                        break;
                    case 11:
                        message.visionGroundTruth = $root.message.platform.webots.VisionGroundTruth.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return VisualMesh;
        })();

        return vision;
    })();

    return message;
})();

export const vec = $root.vec = (() => {

    /**
     * Properties of a vec.
     * @exports Ivec
     * @interface Ivec
     * @property {Array.<number>|null} [v] vec v
     */

    /**
     * Constructs a new vec.
     * @exports vec
     * @classdesc Represents a vec.
     * @implements Ivec
     * @constructor
     * @param {Ivec=} [properties] Properties to set
     */
    function vec(properties) {
        this.v = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * vec v.
     * @member {Array.<number>} v
     * @memberof vec
     * @instance
     */
    vec.prototype.v = $util.emptyArray;

    /**
     * Encodes the specified vec message. Does not implicitly {@link vec.verify|verify} messages.
     * @function encode
     * @memberof vec
     * @static
     * @param {Ivec} message vec message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    vec.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.v != null && message.v.length) {
            writer.uint32(/* id 1, wireType 2 =*/10).fork();
            for (let i = 0; i < message.v.length; ++i)
                writer.double(message.v[i]);
            writer.ldelim();
        }
        return writer;
    };

    /**
     * Decodes a vec message from the specified reader or buffer.
     * @function decode
     * @memberof vec
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {vec} vec
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    vec.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.vec();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.v && message.v.length))
                    message.v = [];
                if ((tag & 7) === 2) {
                    let end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                        message.v.push(reader.double());
                } else
                    message.v.push(reader.double());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return vec;
})();

export const fvec = $root.fvec = (() => {

    /**
     * Properties of a fvec.
     * @exports Ifvec
     * @interface Ifvec
     * @property {Array.<number>|null} [v] fvec v
     */

    /**
     * Constructs a new fvec.
     * @exports fvec
     * @classdesc Represents a fvec.
     * @implements Ifvec
     * @constructor
     * @param {Ifvec=} [properties] Properties to set
     */
    function fvec(properties) {
        this.v = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * fvec v.
     * @member {Array.<number>} v
     * @memberof fvec
     * @instance
     */
    fvec.prototype.v = $util.emptyArray;

    /**
     * Encodes the specified fvec message. Does not implicitly {@link fvec.verify|verify} messages.
     * @function encode
     * @memberof fvec
     * @static
     * @param {Ifvec} message fvec message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    fvec.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.v != null && message.v.length) {
            writer.uint32(/* id 1, wireType 2 =*/10).fork();
            for (let i = 0; i < message.v.length; ++i)
                writer.float(message.v[i]);
            writer.ldelim();
        }
        return writer;
    };

    /**
     * Decodes a fvec message from the specified reader or buffer.
     * @function decode
     * @memberof fvec
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {fvec} fvec
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    fvec.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.fvec();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.v && message.v.length))
                    message.v = [];
                if ((tag & 7) === 2) {
                    let end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                        message.v.push(reader.float());
                } else
                    message.v.push(reader.float());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return fvec;
})();

export const ivec = $root.ivec = (() => {

    /**
     * Properties of an ivec.
     * @exports Iivec
     * @interface Iivec
     * @property {Array.<number>|null} [v] ivec v
     */

    /**
     * Constructs a new ivec.
     * @exports ivec
     * @classdesc Represents an ivec.
     * @implements Iivec
     * @constructor
     * @param {Iivec=} [properties] Properties to set
     */
    function ivec(properties) {
        this.v = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ivec v.
     * @member {Array.<number>} v
     * @memberof ivec
     * @instance
     */
    ivec.prototype.v = $util.emptyArray;

    /**
     * Encodes the specified ivec message. Does not implicitly {@link ivec.verify|verify} messages.
     * @function encode
     * @memberof ivec
     * @static
     * @param {Iivec} message ivec message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ivec.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.v != null && message.v.length) {
            writer.uint32(/* id 1, wireType 2 =*/10).fork();
            for (let i = 0; i < message.v.length; ++i)
                writer.sfixed32(message.v[i]);
            writer.ldelim();
        }
        return writer;
    };

    /**
     * Decodes an ivec message from the specified reader or buffer.
     * @function decode
     * @memberof ivec
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ivec} ivec
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ivec.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ivec();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.v && message.v.length))
                    message.v = [];
                if ((tag & 7) === 2) {
                    let end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                        message.v.push(reader.sfixed32());
                } else
                    message.v.push(reader.sfixed32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return ivec;
})();

export const uvec = $root.uvec = (() => {

    /**
     * Properties of an uvec.
     * @exports Iuvec
     * @interface Iuvec
     * @property {Array.<number>|null} [v] uvec v
     */

    /**
     * Constructs a new uvec.
     * @exports uvec
     * @classdesc Represents an uvec.
     * @implements Iuvec
     * @constructor
     * @param {Iuvec=} [properties] Properties to set
     */
    function uvec(properties) {
        this.v = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * uvec v.
     * @member {Array.<number>} v
     * @memberof uvec
     * @instance
     */
    uvec.prototype.v = $util.emptyArray;

    /**
     * Encodes the specified uvec message. Does not implicitly {@link uvec.verify|verify} messages.
     * @function encode
     * @memberof uvec
     * @static
     * @param {Iuvec} message uvec message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    uvec.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.v != null && message.v.length) {
            writer.uint32(/* id 1, wireType 2 =*/10).fork();
            for (let i = 0; i < message.v.length; ++i)
                writer.fixed32(message.v[i]);
            writer.ldelim();
        }
        return writer;
    };

    /**
     * Decodes an uvec message from the specified reader or buffer.
     * @function decode
     * @memberof uvec
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {uvec} uvec
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    uvec.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.uvec();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.v && message.v.length))
                    message.v = [];
                if ((tag & 7) === 2) {
                    let end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                        message.v.push(reader.fixed32());
                } else
                    message.v.push(reader.fixed32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return uvec;
})();

export const cvec = $root.cvec = (() => {

    /**
     * Properties of a cvec.
     * @exports Icvec
     * @interface Icvec
     * @property {Uint8Array|null} [v] cvec v
     */

    /**
     * Constructs a new cvec.
     * @exports cvec
     * @classdesc Represents a cvec.
     * @implements Icvec
     * @constructor
     * @param {Icvec=} [properties] Properties to set
     */
    function cvec(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * cvec v.
     * @member {Uint8Array} v
     * @memberof cvec
     * @instance
     */
    cvec.prototype.v = $util.newBuffer([]);

    /**
     * Encodes the specified cvec message. Does not implicitly {@link cvec.verify|verify} messages.
     * @function encode
     * @memberof cvec
     * @static
     * @param {Icvec} message cvec message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    cvec.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.v != null && Object.hasOwnProperty.call(message, "v"))
            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.v);
        return writer;
    };

    /**
     * Decodes a cvec message from the specified reader or buffer.
     * @function decode
     * @memberof cvec
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {cvec} cvec
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    cvec.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cvec();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.v = reader.bytes();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return cvec;
})();

export const vec2 = $root.vec2 = (() => {

    /**
     * Properties of a vec2.
     * @exports Ivec2
     * @interface Ivec2
     * @property {number|null} [x] vec2 x
     * @property {number|null} [y] vec2 y
     */

    /**
     * Constructs a new vec2.
     * @exports vec2
     * @classdesc Represents a vec2.
     * @implements Ivec2
     * @constructor
     * @param {Ivec2=} [properties] Properties to set
     */
    function vec2(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * vec2 x.
     * @member {number} x
     * @memberof vec2
     * @instance
     */
    vec2.prototype.x = 0;

    /**
     * vec2 y.
     * @member {number} y
     * @memberof vec2
     * @instance
     */
    vec2.prototype.y = 0;

    /**
     * Encodes the specified vec2 message. Does not implicitly {@link vec2.verify|verify} messages.
     * @function encode
     * @memberof vec2
     * @static
     * @param {Ivec2} message vec2 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    vec2.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.x != null && Object.hasOwnProperty.call(message, "x"))
            writer.uint32(/* id 1, wireType 1 =*/9).double(message.x);
        if (message.y != null && Object.hasOwnProperty.call(message, "y"))
            writer.uint32(/* id 2, wireType 1 =*/17).double(message.y);
        return writer;
    };

    /**
     * Decodes a vec2 message from the specified reader or buffer.
     * @function decode
     * @memberof vec2
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {vec2} vec2
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    vec2.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.vec2();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.x = reader.double();
                break;
            case 2:
                message.y = reader.double();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return vec2;
})();

export const fvec2 = $root.fvec2 = (() => {

    /**
     * Properties of a fvec2.
     * @exports Ifvec2
     * @interface Ifvec2
     * @property {number|null} [x] fvec2 x
     * @property {number|null} [y] fvec2 y
     */

    /**
     * Constructs a new fvec2.
     * @exports fvec2
     * @classdesc Represents a fvec2.
     * @implements Ifvec2
     * @constructor
     * @param {Ifvec2=} [properties] Properties to set
     */
    function fvec2(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * fvec2 x.
     * @member {number} x
     * @memberof fvec2
     * @instance
     */
    fvec2.prototype.x = 0;

    /**
     * fvec2 y.
     * @member {number} y
     * @memberof fvec2
     * @instance
     */
    fvec2.prototype.y = 0;

    /**
     * Encodes the specified fvec2 message. Does not implicitly {@link fvec2.verify|verify} messages.
     * @function encode
     * @memberof fvec2
     * @static
     * @param {Ifvec2} message fvec2 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    fvec2.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.x != null && Object.hasOwnProperty.call(message, "x"))
            writer.uint32(/* id 1, wireType 5 =*/13).float(message.x);
        if (message.y != null && Object.hasOwnProperty.call(message, "y"))
            writer.uint32(/* id 2, wireType 5 =*/21).float(message.y);
        return writer;
    };

    /**
     * Decodes a fvec2 message from the specified reader or buffer.
     * @function decode
     * @memberof fvec2
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {fvec2} fvec2
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    fvec2.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.fvec2();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.x = reader.float();
                break;
            case 2:
                message.y = reader.float();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return fvec2;
})();

export const ivec2 = $root.ivec2 = (() => {

    /**
     * Properties of an ivec2.
     * @exports Iivec2
     * @interface Iivec2
     * @property {number|null} [x] ivec2 x
     * @property {number|null} [y] ivec2 y
     */

    /**
     * Constructs a new ivec2.
     * @exports ivec2
     * @classdesc Represents an ivec2.
     * @implements Iivec2
     * @constructor
     * @param {Iivec2=} [properties] Properties to set
     */
    function ivec2(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ivec2 x.
     * @member {number} x
     * @memberof ivec2
     * @instance
     */
    ivec2.prototype.x = 0;

    /**
     * ivec2 y.
     * @member {number} y
     * @memberof ivec2
     * @instance
     */
    ivec2.prototype.y = 0;

    /**
     * Encodes the specified ivec2 message. Does not implicitly {@link ivec2.verify|verify} messages.
     * @function encode
     * @memberof ivec2
     * @static
     * @param {Iivec2} message ivec2 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ivec2.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.x != null && Object.hasOwnProperty.call(message, "x"))
            writer.uint32(/* id 1, wireType 0 =*/8).sint32(message.x);
        if (message.y != null && Object.hasOwnProperty.call(message, "y"))
            writer.uint32(/* id 2, wireType 0 =*/16).sint32(message.y);
        return writer;
    };

    /**
     * Decodes an ivec2 message from the specified reader or buffer.
     * @function decode
     * @memberof ivec2
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ivec2} ivec2
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ivec2.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ivec2();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.x = reader.sint32();
                break;
            case 2:
                message.y = reader.sint32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return ivec2;
})();

export const uvec2 = $root.uvec2 = (() => {

    /**
     * Properties of an uvec2.
     * @exports Iuvec2
     * @interface Iuvec2
     * @property {number|null} [x] uvec2 x
     * @property {number|null} [y] uvec2 y
     */

    /**
     * Constructs a new uvec2.
     * @exports uvec2
     * @classdesc Represents an uvec2.
     * @implements Iuvec2
     * @constructor
     * @param {Iuvec2=} [properties] Properties to set
     */
    function uvec2(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * uvec2 x.
     * @member {number} x
     * @memberof uvec2
     * @instance
     */
    uvec2.prototype.x = 0;

    /**
     * uvec2 y.
     * @member {number} y
     * @memberof uvec2
     * @instance
     */
    uvec2.prototype.y = 0;

    /**
     * Encodes the specified uvec2 message. Does not implicitly {@link uvec2.verify|verify} messages.
     * @function encode
     * @memberof uvec2
     * @static
     * @param {Iuvec2} message uvec2 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    uvec2.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.x != null && Object.hasOwnProperty.call(message, "x"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.x);
        if (message.y != null && Object.hasOwnProperty.call(message, "y"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.y);
        return writer;
    };

    /**
     * Decodes an uvec2 message from the specified reader or buffer.
     * @function decode
     * @memberof uvec2
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {uvec2} uvec2
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    uvec2.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.uvec2();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.x = reader.uint32();
                break;
            case 2:
                message.y = reader.uint32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return uvec2;
})();

export const vec3 = $root.vec3 = (() => {

    /**
     * Properties of a vec3.
     * @exports Ivec3
     * @interface Ivec3
     * @property {number|null} [x] vec3 x
     * @property {number|null} [y] vec3 y
     * @property {number|null} [z] vec3 z
     */

    /**
     * Constructs a new vec3.
     * @exports vec3
     * @classdesc Represents a vec3.
     * @implements Ivec3
     * @constructor
     * @param {Ivec3=} [properties] Properties to set
     */
    function vec3(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * vec3 x.
     * @member {number} x
     * @memberof vec3
     * @instance
     */
    vec3.prototype.x = 0;

    /**
     * vec3 y.
     * @member {number} y
     * @memberof vec3
     * @instance
     */
    vec3.prototype.y = 0;

    /**
     * vec3 z.
     * @member {number} z
     * @memberof vec3
     * @instance
     */
    vec3.prototype.z = 0;

    /**
     * Encodes the specified vec3 message. Does not implicitly {@link vec3.verify|verify} messages.
     * @function encode
     * @memberof vec3
     * @static
     * @param {Ivec3} message vec3 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    vec3.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.x != null && Object.hasOwnProperty.call(message, "x"))
            writer.uint32(/* id 1, wireType 1 =*/9).double(message.x);
        if (message.y != null && Object.hasOwnProperty.call(message, "y"))
            writer.uint32(/* id 2, wireType 1 =*/17).double(message.y);
        if (message.z != null && Object.hasOwnProperty.call(message, "z"))
            writer.uint32(/* id 3, wireType 1 =*/25).double(message.z);
        return writer;
    };

    /**
     * Decodes a vec3 message from the specified reader or buffer.
     * @function decode
     * @memberof vec3
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {vec3} vec3
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    vec3.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.vec3();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.x = reader.double();
                break;
            case 2:
                message.y = reader.double();
                break;
            case 3:
                message.z = reader.double();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return vec3;
})();

export const fvec3 = $root.fvec3 = (() => {

    /**
     * Properties of a fvec3.
     * @exports Ifvec3
     * @interface Ifvec3
     * @property {number|null} [x] fvec3 x
     * @property {number|null} [y] fvec3 y
     * @property {number|null} [z] fvec3 z
     */

    /**
     * Constructs a new fvec3.
     * @exports fvec3
     * @classdesc Represents a fvec3.
     * @implements Ifvec3
     * @constructor
     * @param {Ifvec3=} [properties] Properties to set
     */
    function fvec3(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * fvec3 x.
     * @member {number} x
     * @memberof fvec3
     * @instance
     */
    fvec3.prototype.x = 0;

    /**
     * fvec3 y.
     * @member {number} y
     * @memberof fvec3
     * @instance
     */
    fvec3.prototype.y = 0;

    /**
     * fvec3 z.
     * @member {number} z
     * @memberof fvec3
     * @instance
     */
    fvec3.prototype.z = 0;

    /**
     * Encodes the specified fvec3 message. Does not implicitly {@link fvec3.verify|verify} messages.
     * @function encode
     * @memberof fvec3
     * @static
     * @param {Ifvec3} message fvec3 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    fvec3.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.x != null && Object.hasOwnProperty.call(message, "x"))
            writer.uint32(/* id 1, wireType 5 =*/13).float(message.x);
        if (message.y != null && Object.hasOwnProperty.call(message, "y"))
            writer.uint32(/* id 2, wireType 5 =*/21).float(message.y);
        if (message.z != null && Object.hasOwnProperty.call(message, "z"))
            writer.uint32(/* id 3, wireType 5 =*/29).float(message.z);
        return writer;
    };

    /**
     * Decodes a fvec3 message from the specified reader or buffer.
     * @function decode
     * @memberof fvec3
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {fvec3} fvec3
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    fvec3.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.fvec3();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.x = reader.float();
                break;
            case 2:
                message.y = reader.float();
                break;
            case 3:
                message.z = reader.float();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return fvec3;
})();

export const ivec3 = $root.ivec3 = (() => {

    /**
     * Properties of an ivec3.
     * @exports Iivec3
     * @interface Iivec3
     * @property {number|null} [x] ivec3 x
     * @property {number|null} [y] ivec3 y
     * @property {number|null} [z] ivec3 z
     */

    /**
     * Constructs a new ivec3.
     * @exports ivec3
     * @classdesc Represents an ivec3.
     * @implements Iivec3
     * @constructor
     * @param {Iivec3=} [properties] Properties to set
     */
    function ivec3(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ivec3 x.
     * @member {number} x
     * @memberof ivec3
     * @instance
     */
    ivec3.prototype.x = 0;

    /**
     * ivec3 y.
     * @member {number} y
     * @memberof ivec3
     * @instance
     */
    ivec3.prototype.y = 0;

    /**
     * ivec3 z.
     * @member {number} z
     * @memberof ivec3
     * @instance
     */
    ivec3.prototype.z = 0;

    /**
     * Encodes the specified ivec3 message. Does not implicitly {@link ivec3.verify|verify} messages.
     * @function encode
     * @memberof ivec3
     * @static
     * @param {Iivec3} message ivec3 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ivec3.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.x != null && Object.hasOwnProperty.call(message, "x"))
            writer.uint32(/* id 1, wireType 0 =*/8).sint32(message.x);
        if (message.y != null && Object.hasOwnProperty.call(message, "y"))
            writer.uint32(/* id 2, wireType 0 =*/16).sint32(message.y);
        if (message.z != null && Object.hasOwnProperty.call(message, "z"))
            writer.uint32(/* id 3, wireType 0 =*/24).sint32(message.z);
        return writer;
    };

    /**
     * Decodes an ivec3 message from the specified reader or buffer.
     * @function decode
     * @memberof ivec3
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ivec3} ivec3
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ivec3.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ivec3();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.x = reader.sint32();
                break;
            case 2:
                message.y = reader.sint32();
                break;
            case 3:
                message.z = reader.sint32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return ivec3;
})();

export const uvec3 = $root.uvec3 = (() => {

    /**
     * Properties of an uvec3.
     * @exports Iuvec3
     * @interface Iuvec3
     * @property {number|null} [x] uvec3 x
     * @property {number|null} [y] uvec3 y
     * @property {number|null} [z] uvec3 z
     */

    /**
     * Constructs a new uvec3.
     * @exports uvec3
     * @classdesc Represents an uvec3.
     * @implements Iuvec3
     * @constructor
     * @param {Iuvec3=} [properties] Properties to set
     */
    function uvec3(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * uvec3 x.
     * @member {number} x
     * @memberof uvec3
     * @instance
     */
    uvec3.prototype.x = 0;

    /**
     * uvec3 y.
     * @member {number} y
     * @memberof uvec3
     * @instance
     */
    uvec3.prototype.y = 0;

    /**
     * uvec3 z.
     * @member {number} z
     * @memberof uvec3
     * @instance
     */
    uvec3.prototype.z = 0;

    /**
     * Encodes the specified uvec3 message. Does not implicitly {@link uvec3.verify|verify} messages.
     * @function encode
     * @memberof uvec3
     * @static
     * @param {Iuvec3} message uvec3 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    uvec3.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.x != null && Object.hasOwnProperty.call(message, "x"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.x);
        if (message.y != null && Object.hasOwnProperty.call(message, "y"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.y);
        if (message.z != null && Object.hasOwnProperty.call(message, "z"))
            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.z);
        return writer;
    };

    /**
     * Decodes an uvec3 message from the specified reader or buffer.
     * @function decode
     * @memberof uvec3
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {uvec3} uvec3
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    uvec3.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.uvec3();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.x = reader.uint32();
                break;
            case 2:
                message.y = reader.uint32();
                break;
            case 3:
                message.z = reader.uint32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return uvec3;
})();

export const vec4 = $root.vec4 = (() => {

    /**
     * Properties of a vec4.
     * @exports Ivec4
     * @interface Ivec4
     * @property {number|null} [x] vec4 x
     * @property {number|null} [y] vec4 y
     * @property {number|null} [z] vec4 z
     * @property {number|null} [t] vec4 t
     */

    /**
     * Constructs a new vec4.
     * @exports vec4
     * @classdesc Represents a vec4.
     * @implements Ivec4
     * @constructor
     * @param {Ivec4=} [properties] Properties to set
     */
    function vec4(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * vec4 x.
     * @member {number} x
     * @memberof vec4
     * @instance
     */
    vec4.prototype.x = 0;

    /**
     * vec4 y.
     * @member {number} y
     * @memberof vec4
     * @instance
     */
    vec4.prototype.y = 0;

    /**
     * vec4 z.
     * @member {number} z
     * @memberof vec4
     * @instance
     */
    vec4.prototype.z = 0;

    /**
     * vec4 t.
     * @member {number} t
     * @memberof vec4
     * @instance
     */
    vec4.prototype.t = 0;

    /**
     * Encodes the specified vec4 message. Does not implicitly {@link vec4.verify|verify} messages.
     * @function encode
     * @memberof vec4
     * @static
     * @param {Ivec4} message vec4 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    vec4.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.x != null && Object.hasOwnProperty.call(message, "x"))
            writer.uint32(/* id 1, wireType 1 =*/9).double(message.x);
        if (message.y != null && Object.hasOwnProperty.call(message, "y"))
            writer.uint32(/* id 2, wireType 1 =*/17).double(message.y);
        if (message.z != null && Object.hasOwnProperty.call(message, "z"))
            writer.uint32(/* id 3, wireType 1 =*/25).double(message.z);
        if (message.t != null && Object.hasOwnProperty.call(message, "t"))
            writer.uint32(/* id 4, wireType 1 =*/33).double(message.t);
        return writer;
    };

    /**
     * Decodes a vec4 message from the specified reader or buffer.
     * @function decode
     * @memberof vec4
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {vec4} vec4
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    vec4.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.vec4();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.x = reader.double();
                break;
            case 2:
                message.y = reader.double();
                break;
            case 3:
                message.z = reader.double();
                break;
            case 4:
                message.t = reader.double();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return vec4;
})();

export const fvec4 = $root.fvec4 = (() => {

    /**
     * Properties of a fvec4.
     * @exports Ifvec4
     * @interface Ifvec4
     * @property {number|null} [x] fvec4 x
     * @property {number|null} [y] fvec4 y
     * @property {number|null} [z] fvec4 z
     * @property {number|null} [t] fvec4 t
     */

    /**
     * Constructs a new fvec4.
     * @exports fvec4
     * @classdesc Represents a fvec4.
     * @implements Ifvec4
     * @constructor
     * @param {Ifvec4=} [properties] Properties to set
     */
    function fvec4(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * fvec4 x.
     * @member {number} x
     * @memberof fvec4
     * @instance
     */
    fvec4.prototype.x = 0;

    /**
     * fvec4 y.
     * @member {number} y
     * @memberof fvec4
     * @instance
     */
    fvec4.prototype.y = 0;

    /**
     * fvec4 z.
     * @member {number} z
     * @memberof fvec4
     * @instance
     */
    fvec4.prototype.z = 0;

    /**
     * fvec4 t.
     * @member {number} t
     * @memberof fvec4
     * @instance
     */
    fvec4.prototype.t = 0;

    /**
     * Encodes the specified fvec4 message. Does not implicitly {@link fvec4.verify|verify} messages.
     * @function encode
     * @memberof fvec4
     * @static
     * @param {Ifvec4} message fvec4 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    fvec4.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.x != null && Object.hasOwnProperty.call(message, "x"))
            writer.uint32(/* id 1, wireType 5 =*/13).float(message.x);
        if (message.y != null && Object.hasOwnProperty.call(message, "y"))
            writer.uint32(/* id 2, wireType 5 =*/21).float(message.y);
        if (message.z != null && Object.hasOwnProperty.call(message, "z"))
            writer.uint32(/* id 3, wireType 5 =*/29).float(message.z);
        if (message.t != null && Object.hasOwnProperty.call(message, "t"))
            writer.uint32(/* id 4, wireType 5 =*/37).float(message.t);
        return writer;
    };

    /**
     * Decodes a fvec4 message from the specified reader or buffer.
     * @function decode
     * @memberof fvec4
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {fvec4} fvec4
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    fvec4.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.fvec4();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.x = reader.float();
                break;
            case 2:
                message.y = reader.float();
                break;
            case 3:
                message.z = reader.float();
                break;
            case 4:
                message.t = reader.float();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return fvec4;
})();

export const ivec4 = $root.ivec4 = (() => {

    /**
     * Properties of an ivec4.
     * @exports Iivec4
     * @interface Iivec4
     * @property {number|null} [x] ivec4 x
     * @property {number|null} [y] ivec4 y
     * @property {number|null} [z] ivec4 z
     * @property {number|null} [t] ivec4 t
     */

    /**
     * Constructs a new ivec4.
     * @exports ivec4
     * @classdesc Represents an ivec4.
     * @implements Iivec4
     * @constructor
     * @param {Iivec4=} [properties] Properties to set
     */
    function ivec4(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ivec4 x.
     * @member {number} x
     * @memberof ivec4
     * @instance
     */
    ivec4.prototype.x = 0;

    /**
     * ivec4 y.
     * @member {number} y
     * @memberof ivec4
     * @instance
     */
    ivec4.prototype.y = 0;

    /**
     * ivec4 z.
     * @member {number} z
     * @memberof ivec4
     * @instance
     */
    ivec4.prototype.z = 0;

    /**
     * ivec4 t.
     * @member {number} t
     * @memberof ivec4
     * @instance
     */
    ivec4.prototype.t = 0;

    /**
     * Encodes the specified ivec4 message. Does not implicitly {@link ivec4.verify|verify} messages.
     * @function encode
     * @memberof ivec4
     * @static
     * @param {Iivec4} message ivec4 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ivec4.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.x != null && Object.hasOwnProperty.call(message, "x"))
            writer.uint32(/* id 1, wireType 0 =*/8).sint32(message.x);
        if (message.y != null && Object.hasOwnProperty.call(message, "y"))
            writer.uint32(/* id 2, wireType 0 =*/16).sint32(message.y);
        if (message.z != null && Object.hasOwnProperty.call(message, "z"))
            writer.uint32(/* id 3, wireType 0 =*/24).sint32(message.z);
        if (message.t != null && Object.hasOwnProperty.call(message, "t"))
            writer.uint32(/* id 4, wireType 0 =*/32).sint32(message.t);
        return writer;
    };

    /**
     * Decodes an ivec4 message from the specified reader or buffer.
     * @function decode
     * @memberof ivec4
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ivec4} ivec4
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ivec4.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ivec4();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.x = reader.sint32();
                break;
            case 2:
                message.y = reader.sint32();
                break;
            case 3:
                message.z = reader.sint32();
                break;
            case 4:
                message.t = reader.sint32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return ivec4;
})();

export const uvec4 = $root.uvec4 = (() => {

    /**
     * Properties of an uvec4.
     * @exports Iuvec4
     * @interface Iuvec4
     * @property {number|null} [x] uvec4 x
     * @property {number|null} [y] uvec4 y
     * @property {number|null} [z] uvec4 z
     * @property {number|null} [t] uvec4 t
     */

    /**
     * Constructs a new uvec4.
     * @exports uvec4
     * @classdesc Represents an uvec4.
     * @implements Iuvec4
     * @constructor
     * @param {Iuvec4=} [properties] Properties to set
     */
    function uvec4(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * uvec4 x.
     * @member {number} x
     * @memberof uvec4
     * @instance
     */
    uvec4.prototype.x = 0;

    /**
     * uvec4 y.
     * @member {number} y
     * @memberof uvec4
     * @instance
     */
    uvec4.prototype.y = 0;

    /**
     * uvec4 z.
     * @member {number} z
     * @memberof uvec4
     * @instance
     */
    uvec4.prototype.z = 0;

    /**
     * uvec4 t.
     * @member {number} t
     * @memberof uvec4
     * @instance
     */
    uvec4.prototype.t = 0;

    /**
     * Encodes the specified uvec4 message. Does not implicitly {@link uvec4.verify|verify} messages.
     * @function encode
     * @memberof uvec4
     * @static
     * @param {Iuvec4} message uvec4 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    uvec4.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.x != null && Object.hasOwnProperty.call(message, "x"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.x);
        if (message.y != null && Object.hasOwnProperty.call(message, "y"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.y);
        if (message.z != null && Object.hasOwnProperty.call(message, "z"))
            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.z);
        if (message.t != null && Object.hasOwnProperty.call(message, "t"))
            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.t);
        return writer;
    };

    /**
     * Decodes an uvec4 message from the specified reader or buffer.
     * @function decode
     * @memberof uvec4
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {uvec4} uvec4
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    uvec4.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.uvec4();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.x = reader.uint32();
                break;
            case 2:
                message.y = reader.uint32();
                break;
            case 3:
                message.z = reader.uint32();
                break;
            case 4:
                message.t = reader.uint32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return uvec4;
})();

export const vec5 = $root.vec5 = (() => {

    /**
     * Properties of a vec5.
     * @exports Ivec5
     * @interface Ivec5
     * @property {number|null} [s0] vec5 s0
     * @property {number|null} [s1] vec5 s1
     * @property {number|null} [s2] vec5 s2
     * @property {number|null} [s3] vec5 s3
     * @property {number|null} [s4] vec5 s4
     */

    /**
     * Constructs a new vec5.
     * @exports vec5
     * @classdesc Represents a vec5.
     * @implements Ivec5
     * @constructor
     * @param {Ivec5=} [properties] Properties to set
     */
    function vec5(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * vec5 s0.
     * @member {number} s0
     * @memberof vec5
     * @instance
     */
    vec5.prototype.s0 = 0;

    /**
     * vec5 s1.
     * @member {number} s1
     * @memberof vec5
     * @instance
     */
    vec5.prototype.s1 = 0;

    /**
     * vec5 s2.
     * @member {number} s2
     * @memberof vec5
     * @instance
     */
    vec5.prototype.s2 = 0;

    /**
     * vec5 s3.
     * @member {number} s3
     * @memberof vec5
     * @instance
     */
    vec5.prototype.s3 = 0;

    /**
     * vec5 s4.
     * @member {number} s4
     * @memberof vec5
     * @instance
     */
    vec5.prototype.s4 = 0;

    /**
     * Encodes the specified vec5 message. Does not implicitly {@link vec5.verify|verify} messages.
     * @function encode
     * @memberof vec5
     * @static
     * @param {Ivec5} message vec5 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    vec5.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            writer.uint32(/* id 1, wireType 1 =*/9).double(message.s0);
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            writer.uint32(/* id 2, wireType 1 =*/17).double(message.s1);
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            writer.uint32(/* id 3, wireType 1 =*/25).double(message.s2);
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            writer.uint32(/* id 4, wireType 1 =*/33).double(message.s3);
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            writer.uint32(/* id 5, wireType 1 =*/41).double(message.s4);
        return writer;
    };

    /**
     * Decodes a vec5 message from the specified reader or buffer.
     * @function decode
     * @memberof vec5
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {vec5} vec5
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    vec5.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.vec5();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = reader.double();
                break;
            case 2:
                message.s1 = reader.double();
                break;
            case 3:
                message.s2 = reader.double();
                break;
            case 4:
                message.s3 = reader.double();
                break;
            case 5:
                message.s4 = reader.double();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return vec5;
})();

export const fvec5 = $root.fvec5 = (() => {

    /**
     * Properties of a fvec5.
     * @exports Ifvec5
     * @interface Ifvec5
     * @property {number|null} [s0] fvec5 s0
     * @property {number|null} [s1] fvec5 s1
     * @property {number|null} [s2] fvec5 s2
     * @property {number|null} [s3] fvec5 s3
     * @property {number|null} [s4] fvec5 s4
     */

    /**
     * Constructs a new fvec5.
     * @exports fvec5
     * @classdesc Represents a fvec5.
     * @implements Ifvec5
     * @constructor
     * @param {Ifvec5=} [properties] Properties to set
     */
    function fvec5(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * fvec5 s0.
     * @member {number} s0
     * @memberof fvec5
     * @instance
     */
    fvec5.prototype.s0 = 0;

    /**
     * fvec5 s1.
     * @member {number} s1
     * @memberof fvec5
     * @instance
     */
    fvec5.prototype.s1 = 0;

    /**
     * fvec5 s2.
     * @member {number} s2
     * @memberof fvec5
     * @instance
     */
    fvec5.prototype.s2 = 0;

    /**
     * fvec5 s3.
     * @member {number} s3
     * @memberof fvec5
     * @instance
     */
    fvec5.prototype.s3 = 0;

    /**
     * fvec5 s4.
     * @member {number} s4
     * @memberof fvec5
     * @instance
     */
    fvec5.prototype.s4 = 0;

    /**
     * Encodes the specified fvec5 message. Does not implicitly {@link fvec5.verify|verify} messages.
     * @function encode
     * @memberof fvec5
     * @static
     * @param {Ifvec5} message fvec5 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    fvec5.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            writer.uint32(/* id 1, wireType 5 =*/13).float(message.s0);
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            writer.uint32(/* id 2, wireType 5 =*/21).float(message.s1);
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            writer.uint32(/* id 3, wireType 5 =*/29).float(message.s2);
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            writer.uint32(/* id 4, wireType 5 =*/37).float(message.s3);
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            writer.uint32(/* id 5, wireType 5 =*/45).float(message.s4);
        return writer;
    };

    /**
     * Decodes a fvec5 message from the specified reader or buffer.
     * @function decode
     * @memberof fvec5
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {fvec5} fvec5
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    fvec5.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.fvec5();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = reader.float();
                break;
            case 2:
                message.s1 = reader.float();
                break;
            case 3:
                message.s2 = reader.float();
                break;
            case 4:
                message.s3 = reader.float();
                break;
            case 5:
                message.s4 = reader.float();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return fvec5;
})();

export const ivec5 = $root.ivec5 = (() => {

    /**
     * Properties of an ivec5.
     * @exports Iivec5
     * @interface Iivec5
     * @property {number|null} [s0] ivec5 s0
     * @property {number|null} [s1] ivec5 s1
     * @property {number|null} [s2] ivec5 s2
     * @property {number|null} [s3] ivec5 s3
     * @property {number|null} [s4] ivec5 s4
     */

    /**
     * Constructs a new ivec5.
     * @exports ivec5
     * @classdesc Represents an ivec5.
     * @implements Iivec5
     * @constructor
     * @param {Iivec5=} [properties] Properties to set
     */
    function ivec5(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ivec5 s0.
     * @member {number} s0
     * @memberof ivec5
     * @instance
     */
    ivec5.prototype.s0 = 0;

    /**
     * ivec5 s1.
     * @member {number} s1
     * @memberof ivec5
     * @instance
     */
    ivec5.prototype.s1 = 0;

    /**
     * ivec5 s2.
     * @member {number} s2
     * @memberof ivec5
     * @instance
     */
    ivec5.prototype.s2 = 0;

    /**
     * ivec5 s3.
     * @member {number} s3
     * @memberof ivec5
     * @instance
     */
    ivec5.prototype.s3 = 0;

    /**
     * ivec5 s4.
     * @member {number} s4
     * @memberof ivec5
     * @instance
     */
    ivec5.prototype.s4 = 0;

    /**
     * Encodes the specified ivec5 message. Does not implicitly {@link ivec5.verify|verify} messages.
     * @function encode
     * @memberof ivec5
     * @static
     * @param {Iivec5} message ivec5 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ivec5.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            writer.uint32(/* id 1, wireType 0 =*/8).sint32(message.s0);
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            writer.uint32(/* id 2, wireType 0 =*/16).sint32(message.s1);
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            writer.uint32(/* id 3, wireType 0 =*/24).sint32(message.s2);
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            writer.uint32(/* id 4, wireType 0 =*/32).sint32(message.s3);
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            writer.uint32(/* id 5, wireType 0 =*/40).sint32(message.s4);
        return writer;
    };

    /**
     * Decodes an ivec5 message from the specified reader or buffer.
     * @function decode
     * @memberof ivec5
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ivec5} ivec5
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ivec5.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ivec5();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = reader.sint32();
                break;
            case 2:
                message.s1 = reader.sint32();
                break;
            case 3:
                message.s2 = reader.sint32();
                break;
            case 4:
                message.s3 = reader.sint32();
                break;
            case 5:
                message.s4 = reader.sint32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return ivec5;
})();

export const uvec5 = $root.uvec5 = (() => {

    /**
     * Properties of an uvec5.
     * @exports Iuvec5
     * @interface Iuvec5
     * @property {number|null} [s0] uvec5 s0
     * @property {number|null} [s1] uvec5 s1
     * @property {number|null} [s2] uvec5 s2
     * @property {number|null} [s3] uvec5 s3
     * @property {number|null} [s4] uvec5 s4
     */

    /**
     * Constructs a new uvec5.
     * @exports uvec5
     * @classdesc Represents an uvec5.
     * @implements Iuvec5
     * @constructor
     * @param {Iuvec5=} [properties] Properties to set
     */
    function uvec5(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * uvec5 s0.
     * @member {number} s0
     * @memberof uvec5
     * @instance
     */
    uvec5.prototype.s0 = 0;

    /**
     * uvec5 s1.
     * @member {number} s1
     * @memberof uvec5
     * @instance
     */
    uvec5.prototype.s1 = 0;

    /**
     * uvec5 s2.
     * @member {number} s2
     * @memberof uvec5
     * @instance
     */
    uvec5.prototype.s2 = 0;

    /**
     * uvec5 s3.
     * @member {number} s3
     * @memberof uvec5
     * @instance
     */
    uvec5.prototype.s3 = 0;

    /**
     * uvec5 s4.
     * @member {number} s4
     * @memberof uvec5
     * @instance
     */
    uvec5.prototype.s4 = 0;

    /**
     * Encodes the specified uvec5 message. Does not implicitly {@link uvec5.verify|verify} messages.
     * @function encode
     * @memberof uvec5
     * @static
     * @param {Iuvec5} message uvec5 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    uvec5.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.s0);
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.s1);
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.s2);
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.s3);
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.s4);
        return writer;
    };

    /**
     * Decodes an uvec5 message from the specified reader or buffer.
     * @function decode
     * @memberof uvec5
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {uvec5} uvec5
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    uvec5.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.uvec5();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = reader.uint32();
                break;
            case 2:
                message.s1 = reader.uint32();
                break;
            case 3:
                message.s2 = reader.uint32();
                break;
            case 4:
                message.s3 = reader.uint32();
                break;
            case 5:
                message.s4 = reader.uint32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return uvec5;
})();

export const vec6 = $root.vec6 = (() => {

    /**
     * Properties of a vec6.
     * @exports Ivec6
     * @interface Ivec6
     * @property {number|null} [s0] vec6 s0
     * @property {number|null} [s1] vec6 s1
     * @property {number|null} [s2] vec6 s2
     * @property {number|null} [s3] vec6 s3
     * @property {number|null} [s4] vec6 s4
     * @property {number|null} [s5] vec6 s5
     */

    /**
     * Constructs a new vec6.
     * @exports vec6
     * @classdesc Represents a vec6.
     * @implements Ivec6
     * @constructor
     * @param {Ivec6=} [properties] Properties to set
     */
    function vec6(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * vec6 s0.
     * @member {number} s0
     * @memberof vec6
     * @instance
     */
    vec6.prototype.s0 = 0;

    /**
     * vec6 s1.
     * @member {number} s1
     * @memberof vec6
     * @instance
     */
    vec6.prototype.s1 = 0;

    /**
     * vec6 s2.
     * @member {number} s2
     * @memberof vec6
     * @instance
     */
    vec6.prototype.s2 = 0;

    /**
     * vec6 s3.
     * @member {number} s3
     * @memberof vec6
     * @instance
     */
    vec6.prototype.s3 = 0;

    /**
     * vec6 s4.
     * @member {number} s4
     * @memberof vec6
     * @instance
     */
    vec6.prototype.s4 = 0;

    /**
     * vec6 s5.
     * @member {number} s5
     * @memberof vec6
     * @instance
     */
    vec6.prototype.s5 = 0;

    /**
     * Encodes the specified vec6 message. Does not implicitly {@link vec6.verify|verify} messages.
     * @function encode
     * @memberof vec6
     * @static
     * @param {Ivec6} message vec6 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    vec6.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            writer.uint32(/* id 1, wireType 1 =*/9).double(message.s0);
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            writer.uint32(/* id 2, wireType 1 =*/17).double(message.s1);
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            writer.uint32(/* id 3, wireType 1 =*/25).double(message.s2);
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            writer.uint32(/* id 4, wireType 1 =*/33).double(message.s3);
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            writer.uint32(/* id 5, wireType 1 =*/41).double(message.s4);
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            writer.uint32(/* id 6, wireType 1 =*/49).double(message.s5);
        return writer;
    };

    /**
     * Decodes a vec6 message from the specified reader or buffer.
     * @function decode
     * @memberof vec6
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {vec6} vec6
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    vec6.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.vec6();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = reader.double();
                break;
            case 2:
                message.s1 = reader.double();
                break;
            case 3:
                message.s2 = reader.double();
                break;
            case 4:
                message.s3 = reader.double();
                break;
            case 5:
                message.s4 = reader.double();
                break;
            case 6:
                message.s5 = reader.double();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return vec6;
})();

export const fvec6 = $root.fvec6 = (() => {

    /**
     * Properties of a fvec6.
     * @exports Ifvec6
     * @interface Ifvec6
     * @property {number|null} [s0] fvec6 s0
     * @property {number|null} [s1] fvec6 s1
     * @property {number|null} [s2] fvec6 s2
     * @property {number|null} [s3] fvec6 s3
     * @property {number|null} [s4] fvec6 s4
     * @property {number|null} [s5] fvec6 s5
     */

    /**
     * Constructs a new fvec6.
     * @exports fvec6
     * @classdesc Represents a fvec6.
     * @implements Ifvec6
     * @constructor
     * @param {Ifvec6=} [properties] Properties to set
     */
    function fvec6(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * fvec6 s0.
     * @member {number} s0
     * @memberof fvec6
     * @instance
     */
    fvec6.prototype.s0 = 0;

    /**
     * fvec6 s1.
     * @member {number} s1
     * @memberof fvec6
     * @instance
     */
    fvec6.prototype.s1 = 0;

    /**
     * fvec6 s2.
     * @member {number} s2
     * @memberof fvec6
     * @instance
     */
    fvec6.prototype.s2 = 0;

    /**
     * fvec6 s3.
     * @member {number} s3
     * @memberof fvec6
     * @instance
     */
    fvec6.prototype.s3 = 0;

    /**
     * fvec6 s4.
     * @member {number} s4
     * @memberof fvec6
     * @instance
     */
    fvec6.prototype.s4 = 0;

    /**
     * fvec6 s5.
     * @member {number} s5
     * @memberof fvec6
     * @instance
     */
    fvec6.prototype.s5 = 0;

    /**
     * Encodes the specified fvec6 message. Does not implicitly {@link fvec6.verify|verify} messages.
     * @function encode
     * @memberof fvec6
     * @static
     * @param {Ifvec6} message fvec6 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    fvec6.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            writer.uint32(/* id 1, wireType 5 =*/13).float(message.s0);
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            writer.uint32(/* id 2, wireType 5 =*/21).float(message.s1);
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            writer.uint32(/* id 3, wireType 5 =*/29).float(message.s2);
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            writer.uint32(/* id 4, wireType 5 =*/37).float(message.s3);
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            writer.uint32(/* id 5, wireType 5 =*/45).float(message.s4);
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            writer.uint32(/* id 6, wireType 5 =*/53).float(message.s5);
        return writer;
    };

    /**
     * Decodes a fvec6 message from the specified reader or buffer.
     * @function decode
     * @memberof fvec6
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {fvec6} fvec6
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    fvec6.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.fvec6();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = reader.float();
                break;
            case 2:
                message.s1 = reader.float();
                break;
            case 3:
                message.s2 = reader.float();
                break;
            case 4:
                message.s3 = reader.float();
                break;
            case 5:
                message.s4 = reader.float();
                break;
            case 6:
                message.s5 = reader.float();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return fvec6;
})();

export const ivec6 = $root.ivec6 = (() => {

    /**
     * Properties of an ivec6.
     * @exports Iivec6
     * @interface Iivec6
     * @property {number|null} [s0] ivec6 s0
     * @property {number|null} [s1] ivec6 s1
     * @property {number|null} [s2] ivec6 s2
     * @property {number|null} [s3] ivec6 s3
     * @property {number|null} [s4] ivec6 s4
     * @property {number|null} [s5] ivec6 s5
     */

    /**
     * Constructs a new ivec6.
     * @exports ivec6
     * @classdesc Represents an ivec6.
     * @implements Iivec6
     * @constructor
     * @param {Iivec6=} [properties] Properties to set
     */
    function ivec6(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ivec6 s0.
     * @member {number} s0
     * @memberof ivec6
     * @instance
     */
    ivec6.prototype.s0 = 0;

    /**
     * ivec6 s1.
     * @member {number} s1
     * @memberof ivec6
     * @instance
     */
    ivec6.prototype.s1 = 0;

    /**
     * ivec6 s2.
     * @member {number} s2
     * @memberof ivec6
     * @instance
     */
    ivec6.prototype.s2 = 0;

    /**
     * ivec6 s3.
     * @member {number} s3
     * @memberof ivec6
     * @instance
     */
    ivec6.prototype.s3 = 0;

    /**
     * ivec6 s4.
     * @member {number} s4
     * @memberof ivec6
     * @instance
     */
    ivec6.prototype.s4 = 0;

    /**
     * ivec6 s5.
     * @member {number} s5
     * @memberof ivec6
     * @instance
     */
    ivec6.prototype.s5 = 0;

    /**
     * Encodes the specified ivec6 message. Does not implicitly {@link ivec6.verify|verify} messages.
     * @function encode
     * @memberof ivec6
     * @static
     * @param {Iivec6} message ivec6 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ivec6.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            writer.uint32(/* id 1, wireType 0 =*/8).sint32(message.s0);
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            writer.uint32(/* id 2, wireType 0 =*/16).sint32(message.s1);
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            writer.uint32(/* id 3, wireType 0 =*/24).sint32(message.s2);
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            writer.uint32(/* id 4, wireType 0 =*/32).sint32(message.s3);
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            writer.uint32(/* id 5, wireType 0 =*/40).sint32(message.s4);
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            writer.uint32(/* id 6, wireType 0 =*/48).sint32(message.s5);
        return writer;
    };

    /**
     * Decodes an ivec6 message from the specified reader or buffer.
     * @function decode
     * @memberof ivec6
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ivec6} ivec6
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ivec6.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ivec6();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = reader.sint32();
                break;
            case 2:
                message.s1 = reader.sint32();
                break;
            case 3:
                message.s2 = reader.sint32();
                break;
            case 4:
                message.s3 = reader.sint32();
                break;
            case 5:
                message.s4 = reader.sint32();
                break;
            case 6:
                message.s5 = reader.sint32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return ivec6;
})();

export const uvec6 = $root.uvec6 = (() => {

    /**
     * Properties of an uvec6.
     * @exports Iuvec6
     * @interface Iuvec6
     * @property {number|null} [s0] uvec6 s0
     * @property {number|null} [s1] uvec6 s1
     * @property {number|null} [s2] uvec6 s2
     * @property {number|null} [s3] uvec6 s3
     * @property {number|null} [s4] uvec6 s4
     * @property {number|null} [s5] uvec6 s5
     */

    /**
     * Constructs a new uvec6.
     * @exports uvec6
     * @classdesc Represents an uvec6.
     * @implements Iuvec6
     * @constructor
     * @param {Iuvec6=} [properties] Properties to set
     */
    function uvec6(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * uvec6 s0.
     * @member {number} s0
     * @memberof uvec6
     * @instance
     */
    uvec6.prototype.s0 = 0;

    /**
     * uvec6 s1.
     * @member {number} s1
     * @memberof uvec6
     * @instance
     */
    uvec6.prototype.s1 = 0;

    /**
     * uvec6 s2.
     * @member {number} s2
     * @memberof uvec6
     * @instance
     */
    uvec6.prototype.s2 = 0;

    /**
     * uvec6 s3.
     * @member {number} s3
     * @memberof uvec6
     * @instance
     */
    uvec6.prototype.s3 = 0;

    /**
     * uvec6 s4.
     * @member {number} s4
     * @memberof uvec6
     * @instance
     */
    uvec6.prototype.s4 = 0;

    /**
     * uvec6 s5.
     * @member {number} s5
     * @memberof uvec6
     * @instance
     */
    uvec6.prototype.s5 = 0;

    /**
     * Encodes the specified uvec6 message. Does not implicitly {@link uvec6.verify|verify} messages.
     * @function encode
     * @memberof uvec6
     * @static
     * @param {Iuvec6} message uvec6 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    uvec6.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.s0);
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.s1);
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.s2);
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.s3);
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.s4);
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.s5);
        return writer;
    };

    /**
     * Decodes an uvec6 message from the specified reader or buffer.
     * @function decode
     * @memberof uvec6
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {uvec6} uvec6
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    uvec6.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.uvec6();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = reader.uint32();
                break;
            case 2:
                message.s1 = reader.uint32();
                break;
            case 3:
                message.s2 = reader.uint32();
                break;
            case 4:
                message.s3 = reader.uint32();
                break;
            case 5:
                message.s4 = reader.uint32();
                break;
            case 6:
                message.s5 = reader.uint32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return uvec6;
})();

export const vec7 = $root.vec7 = (() => {

    /**
     * Properties of a vec7.
     * @exports Ivec7
     * @interface Ivec7
     * @property {number|null} [s0] vec7 s0
     * @property {number|null} [s1] vec7 s1
     * @property {number|null} [s2] vec7 s2
     * @property {number|null} [s3] vec7 s3
     * @property {number|null} [s4] vec7 s4
     * @property {number|null} [s5] vec7 s5
     * @property {number|null} [s6] vec7 s6
     */

    /**
     * Constructs a new vec7.
     * @exports vec7
     * @classdesc Represents a vec7.
     * @implements Ivec7
     * @constructor
     * @param {Ivec7=} [properties] Properties to set
     */
    function vec7(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * vec7 s0.
     * @member {number} s0
     * @memberof vec7
     * @instance
     */
    vec7.prototype.s0 = 0;

    /**
     * vec7 s1.
     * @member {number} s1
     * @memberof vec7
     * @instance
     */
    vec7.prototype.s1 = 0;

    /**
     * vec7 s2.
     * @member {number} s2
     * @memberof vec7
     * @instance
     */
    vec7.prototype.s2 = 0;

    /**
     * vec7 s3.
     * @member {number} s3
     * @memberof vec7
     * @instance
     */
    vec7.prototype.s3 = 0;

    /**
     * vec7 s4.
     * @member {number} s4
     * @memberof vec7
     * @instance
     */
    vec7.prototype.s4 = 0;

    /**
     * vec7 s5.
     * @member {number} s5
     * @memberof vec7
     * @instance
     */
    vec7.prototype.s5 = 0;

    /**
     * vec7 s6.
     * @member {number} s6
     * @memberof vec7
     * @instance
     */
    vec7.prototype.s6 = 0;

    /**
     * Encodes the specified vec7 message. Does not implicitly {@link vec7.verify|verify} messages.
     * @function encode
     * @memberof vec7
     * @static
     * @param {Ivec7} message vec7 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    vec7.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            writer.uint32(/* id 1, wireType 1 =*/9).double(message.s0);
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            writer.uint32(/* id 2, wireType 1 =*/17).double(message.s1);
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            writer.uint32(/* id 3, wireType 1 =*/25).double(message.s2);
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            writer.uint32(/* id 4, wireType 1 =*/33).double(message.s3);
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            writer.uint32(/* id 5, wireType 1 =*/41).double(message.s4);
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            writer.uint32(/* id 6, wireType 1 =*/49).double(message.s5);
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            writer.uint32(/* id 7, wireType 1 =*/57).double(message.s6);
        return writer;
    };

    /**
     * Decodes a vec7 message from the specified reader or buffer.
     * @function decode
     * @memberof vec7
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {vec7} vec7
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    vec7.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.vec7();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = reader.double();
                break;
            case 2:
                message.s1 = reader.double();
                break;
            case 3:
                message.s2 = reader.double();
                break;
            case 4:
                message.s3 = reader.double();
                break;
            case 5:
                message.s4 = reader.double();
                break;
            case 6:
                message.s5 = reader.double();
                break;
            case 7:
                message.s6 = reader.double();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return vec7;
})();

export const fvec7 = $root.fvec7 = (() => {

    /**
     * Properties of a fvec7.
     * @exports Ifvec7
     * @interface Ifvec7
     * @property {number|null} [s0] fvec7 s0
     * @property {number|null} [s1] fvec7 s1
     * @property {number|null} [s2] fvec7 s2
     * @property {number|null} [s3] fvec7 s3
     * @property {number|null} [s4] fvec7 s4
     * @property {number|null} [s5] fvec7 s5
     * @property {number|null} [s6] fvec7 s6
     */

    /**
     * Constructs a new fvec7.
     * @exports fvec7
     * @classdesc Represents a fvec7.
     * @implements Ifvec7
     * @constructor
     * @param {Ifvec7=} [properties] Properties to set
     */
    function fvec7(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * fvec7 s0.
     * @member {number} s0
     * @memberof fvec7
     * @instance
     */
    fvec7.prototype.s0 = 0;

    /**
     * fvec7 s1.
     * @member {number} s1
     * @memberof fvec7
     * @instance
     */
    fvec7.prototype.s1 = 0;

    /**
     * fvec7 s2.
     * @member {number} s2
     * @memberof fvec7
     * @instance
     */
    fvec7.prototype.s2 = 0;

    /**
     * fvec7 s3.
     * @member {number} s3
     * @memberof fvec7
     * @instance
     */
    fvec7.prototype.s3 = 0;

    /**
     * fvec7 s4.
     * @member {number} s4
     * @memberof fvec7
     * @instance
     */
    fvec7.prototype.s4 = 0;

    /**
     * fvec7 s5.
     * @member {number} s5
     * @memberof fvec7
     * @instance
     */
    fvec7.prototype.s5 = 0;

    /**
     * fvec7 s6.
     * @member {number} s6
     * @memberof fvec7
     * @instance
     */
    fvec7.prototype.s6 = 0;

    /**
     * Encodes the specified fvec7 message. Does not implicitly {@link fvec7.verify|verify} messages.
     * @function encode
     * @memberof fvec7
     * @static
     * @param {Ifvec7} message fvec7 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    fvec7.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            writer.uint32(/* id 1, wireType 5 =*/13).float(message.s0);
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            writer.uint32(/* id 2, wireType 5 =*/21).float(message.s1);
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            writer.uint32(/* id 3, wireType 5 =*/29).float(message.s2);
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            writer.uint32(/* id 4, wireType 5 =*/37).float(message.s3);
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            writer.uint32(/* id 5, wireType 5 =*/45).float(message.s4);
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            writer.uint32(/* id 6, wireType 5 =*/53).float(message.s5);
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            writer.uint32(/* id 7, wireType 5 =*/61).float(message.s6);
        return writer;
    };

    /**
     * Decodes a fvec7 message from the specified reader or buffer.
     * @function decode
     * @memberof fvec7
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {fvec7} fvec7
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    fvec7.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.fvec7();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = reader.float();
                break;
            case 2:
                message.s1 = reader.float();
                break;
            case 3:
                message.s2 = reader.float();
                break;
            case 4:
                message.s3 = reader.float();
                break;
            case 5:
                message.s4 = reader.float();
                break;
            case 6:
                message.s5 = reader.float();
                break;
            case 7:
                message.s6 = reader.float();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return fvec7;
})();

export const ivec7 = $root.ivec7 = (() => {

    /**
     * Properties of an ivec7.
     * @exports Iivec7
     * @interface Iivec7
     * @property {number|null} [s0] ivec7 s0
     * @property {number|null} [s1] ivec7 s1
     * @property {number|null} [s2] ivec7 s2
     * @property {number|null} [s3] ivec7 s3
     * @property {number|null} [s4] ivec7 s4
     * @property {number|null} [s5] ivec7 s5
     * @property {number|null} [s6] ivec7 s6
     */

    /**
     * Constructs a new ivec7.
     * @exports ivec7
     * @classdesc Represents an ivec7.
     * @implements Iivec7
     * @constructor
     * @param {Iivec7=} [properties] Properties to set
     */
    function ivec7(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ivec7 s0.
     * @member {number} s0
     * @memberof ivec7
     * @instance
     */
    ivec7.prototype.s0 = 0;

    /**
     * ivec7 s1.
     * @member {number} s1
     * @memberof ivec7
     * @instance
     */
    ivec7.prototype.s1 = 0;

    /**
     * ivec7 s2.
     * @member {number} s2
     * @memberof ivec7
     * @instance
     */
    ivec7.prototype.s2 = 0;

    /**
     * ivec7 s3.
     * @member {number} s3
     * @memberof ivec7
     * @instance
     */
    ivec7.prototype.s3 = 0;

    /**
     * ivec7 s4.
     * @member {number} s4
     * @memberof ivec7
     * @instance
     */
    ivec7.prototype.s4 = 0;

    /**
     * ivec7 s5.
     * @member {number} s5
     * @memberof ivec7
     * @instance
     */
    ivec7.prototype.s5 = 0;

    /**
     * ivec7 s6.
     * @member {number} s6
     * @memberof ivec7
     * @instance
     */
    ivec7.prototype.s6 = 0;

    /**
     * Encodes the specified ivec7 message. Does not implicitly {@link ivec7.verify|verify} messages.
     * @function encode
     * @memberof ivec7
     * @static
     * @param {Iivec7} message ivec7 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ivec7.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            writer.uint32(/* id 1, wireType 0 =*/8).sint32(message.s0);
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            writer.uint32(/* id 2, wireType 0 =*/16).sint32(message.s1);
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            writer.uint32(/* id 3, wireType 0 =*/24).sint32(message.s2);
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            writer.uint32(/* id 4, wireType 0 =*/32).sint32(message.s3);
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            writer.uint32(/* id 5, wireType 0 =*/40).sint32(message.s4);
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            writer.uint32(/* id 6, wireType 0 =*/48).sint32(message.s5);
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            writer.uint32(/* id 7, wireType 0 =*/56).sint32(message.s6);
        return writer;
    };

    /**
     * Decodes an ivec7 message from the specified reader or buffer.
     * @function decode
     * @memberof ivec7
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ivec7} ivec7
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ivec7.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ivec7();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = reader.sint32();
                break;
            case 2:
                message.s1 = reader.sint32();
                break;
            case 3:
                message.s2 = reader.sint32();
                break;
            case 4:
                message.s3 = reader.sint32();
                break;
            case 5:
                message.s4 = reader.sint32();
                break;
            case 6:
                message.s5 = reader.sint32();
                break;
            case 7:
                message.s6 = reader.sint32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return ivec7;
})();

export const uvec7 = $root.uvec7 = (() => {

    /**
     * Properties of an uvec7.
     * @exports Iuvec7
     * @interface Iuvec7
     * @property {number|null} [s0] uvec7 s0
     * @property {number|null} [s1] uvec7 s1
     * @property {number|null} [s2] uvec7 s2
     * @property {number|null} [s3] uvec7 s3
     * @property {number|null} [s4] uvec7 s4
     * @property {number|null} [s5] uvec7 s5
     * @property {number|null} [s6] uvec7 s6
     */

    /**
     * Constructs a new uvec7.
     * @exports uvec7
     * @classdesc Represents an uvec7.
     * @implements Iuvec7
     * @constructor
     * @param {Iuvec7=} [properties] Properties to set
     */
    function uvec7(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * uvec7 s0.
     * @member {number} s0
     * @memberof uvec7
     * @instance
     */
    uvec7.prototype.s0 = 0;

    /**
     * uvec7 s1.
     * @member {number} s1
     * @memberof uvec7
     * @instance
     */
    uvec7.prototype.s1 = 0;

    /**
     * uvec7 s2.
     * @member {number} s2
     * @memberof uvec7
     * @instance
     */
    uvec7.prototype.s2 = 0;

    /**
     * uvec7 s3.
     * @member {number} s3
     * @memberof uvec7
     * @instance
     */
    uvec7.prototype.s3 = 0;

    /**
     * uvec7 s4.
     * @member {number} s4
     * @memberof uvec7
     * @instance
     */
    uvec7.prototype.s4 = 0;

    /**
     * uvec7 s5.
     * @member {number} s5
     * @memberof uvec7
     * @instance
     */
    uvec7.prototype.s5 = 0;

    /**
     * uvec7 s6.
     * @member {number} s6
     * @memberof uvec7
     * @instance
     */
    uvec7.prototype.s6 = 0;

    /**
     * Encodes the specified uvec7 message. Does not implicitly {@link uvec7.verify|verify} messages.
     * @function encode
     * @memberof uvec7
     * @static
     * @param {Iuvec7} message uvec7 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    uvec7.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.s0);
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.s1);
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.s2);
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.s3);
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.s4);
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.s5);
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.s6);
        return writer;
    };

    /**
     * Decodes an uvec7 message from the specified reader or buffer.
     * @function decode
     * @memberof uvec7
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {uvec7} uvec7
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    uvec7.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.uvec7();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = reader.uint32();
                break;
            case 2:
                message.s1 = reader.uint32();
                break;
            case 3:
                message.s2 = reader.uint32();
                break;
            case 4:
                message.s3 = reader.uint32();
                break;
            case 5:
                message.s4 = reader.uint32();
                break;
            case 6:
                message.s5 = reader.uint32();
                break;
            case 7:
                message.s6 = reader.uint32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return uvec7;
})();

export const vec8 = $root.vec8 = (() => {

    /**
     * Properties of a vec8.
     * @exports Ivec8
     * @interface Ivec8
     * @property {number|null} [s0] vec8 s0
     * @property {number|null} [s1] vec8 s1
     * @property {number|null} [s2] vec8 s2
     * @property {number|null} [s3] vec8 s3
     * @property {number|null} [s4] vec8 s4
     * @property {number|null} [s5] vec8 s5
     * @property {number|null} [s6] vec8 s6
     * @property {number|null} [s7] vec8 s7
     */

    /**
     * Constructs a new vec8.
     * @exports vec8
     * @classdesc Represents a vec8.
     * @implements Ivec8
     * @constructor
     * @param {Ivec8=} [properties] Properties to set
     */
    function vec8(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * vec8 s0.
     * @member {number} s0
     * @memberof vec8
     * @instance
     */
    vec8.prototype.s0 = 0;

    /**
     * vec8 s1.
     * @member {number} s1
     * @memberof vec8
     * @instance
     */
    vec8.prototype.s1 = 0;

    /**
     * vec8 s2.
     * @member {number} s2
     * @memberof vec8
     * @instance
     */
    vec8.prototype.s2 = 0;

    /**
     * vec8 s3.
     * @member {number} s3
     * @memberof vec8
     * @instance
     */
    vec8.prototype.s3 = 0;

    /**
     * vec8 s4.
     * @member {number} s4
     * @memberof vec8
     * @instance
     */
    vec8.prototype.s4 = 0;

    /**
     * vec8 s5.
     * @member {number} s5
     * @memberof vec8
     * @instance
     */
    vec8.prototype.s5 = 0;

    /**
     * vec8 s6.
     * @member {number} s6
     * @memberof vec8
     * @instance
     */
    vec8.prototype.s6 = 0;

    /**
     * vec8 s7.
     * @member {number} s7
     * @memberof vec8
     * @instance
     */
    vec8.prototype.s7 = 0;

    /**
     * Encodes the specified vec8 message. Does not implicitly {@link vec8.verify|verify} messages.
     * @function encode
     * @memberof vec8
     * @static
     * @param {Ivec8} message vec8 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    vec8.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            writer.uint32(/* id 1, wireType 1 =*/9).double(message.s0);
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            writer.uint32(/* id 2, wireType 1 =*/17).double(message.s1);
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            writer.uint32(/* id 3, wireType 1 =*/25).double(message.s2);
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            writer.uint32(/* id 4, wireType 1 =*/33).double(message.s3);
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            writer.uint32(/* id 5, wireType 1 =*/41).double(message.s4);
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            writer.uint32(/* id 6, wireType 1 =*/49).double(message.s5);
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            writer.uint32(/* id 7, wireType 1 =*/57).double(message.s6);
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            writer.uint32(/* id 8, wireType 1 =*/65).double(message.s7);
        return writer;
    };

    /**
     * Decodes a vec8 message from the specified reader or buffer.
     * @function decode
     * @memberof vec8
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {vec8} vec8
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    vec8.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.vec8();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = reader.double();
                break;
            case 2:
                message.s1 = reader.double();
                break;
            case 3:
                message.s2 = reader.double();
                break;
            case 4:
                message.s3 = reader.double();
                break;
            case 5:
                message.s4 = reader.double();
                break;
            case 6:
                message.s5 = reader.double();
                break;
            case 7:
                message.s6 = reader.double();
                break;
            case 8:
                message.s7 = reader.double();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return vec8;
})();

export const fvec8 = $root.fvec8 = (() => {

    /**
     * Properties of a fvec8.
     * @exports Ifvec8
     * @interface Ifvec8
     * @property {number|null} [s0] fvec8 s0
     * @property {number|null} [s1] fvec8 s1
     * @property {number|null} [s2] fvec8 s2
     * @property {number|null} [s3] fvec8 s3
     * @property {number|null} [s4] fvec8 s4
     * @property {number|null} [s5] fvec8 s5
     * @property {number|null} [s6] fvec8 s6
     * @property {number|null} [s7] fvec8 s7
     */

    /**
     * Constructs a new fvec8.
     * @exports fvec8
     * @classdesc Represents a fvec8.
     * @implements Ifvec8
     * @constructor
     * @param {Ifvec8=} [properties] Properties to set
     */
    function fvec8(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * fvec8 s0.
     * @member {number} s0
     * @memberof fvec8
     * @instance
     */
    fvec8.prototype.s0 = 0;

    /**
     * fvec8 s1.
     * @member {number} s1
     * @memberof fvec8
     * @instance
     */
    fvec8.prototype.s1 = 0;

    /**
     * fvec8 s2.
     * @member {number} s2
     * @memberof fvec8
     * @instance
     */
    fvec8.prototype.s2 = 0;

    /**
     * fvec8 s3.
     * @member {number} s3
     * @memberof fvec8
     * @instance
     */
    fvec8.prototype.s3 = 0;

    /**
     * fvec8 s4.
     * @member {number} s4
     * @memberof fvec8
     * @instance
     */
    fvec8.prototype.s4 = 0;

    /**
     * fvec8 s5.
     * @member {number} s5
     * @memberof fvec8
     * @instance
     */
    fvec8.prototype.s5 = 0;

    /**
     * fvec8 s6.
     * @member {number} s6
     * @memberof fvec8
     * @instance
     */
    fvec8.prototype.s6 = 0;

    /**
     * fvec8 s7.
     * @member {number} s7
     * @memberof fvec8
     * @instance
     */
    fvec8.prototype.s7 = 0;

    /**
     * Encodes the specified fvec8 message. Does not implicitly {@link fvec8.verify|verify} messages.
     * @function encode
     * @memberof fvec8
     * @static
     * @param {Ifvec8} message fvec8 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    fvec8.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            writer.uint32(/* id 1, wireType 5 =*/13).float(message.s0);
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            writer.uint32(/* id 2, wireType 5 =*/21).float(message.s1);
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            writer.uint32(/* id 3, wireType 5 =*/29).float(message.s2);
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            writer.uint32(/* id 4, wireType 5 =*/37).float(message.s3);
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            writer.uint32(/* id 5, wireType 5 =*/45).float(message.s4);
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            writer.uint32(/* id 6, wireType 5 =*/53).float(message.s5);
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            writer.uint32(/* id 7, wireType 5 =*/61).float(message.s6);
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            writer.uint32(/* id 8, wireType 5 =*/69).float(message.s7);
        return writer;
    };

    /**
     * Decodes a fvec8 message from the specified reader or buffer.
     * @function decode
     * @memberof fvec8
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {fvec8} fvec8
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    fvec8.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.fvec8();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = reader.float();
                break;
            case 2:
                message.s1 = reader.float();
                break;
            case 3:
                message.s2 = reader.float();
                break;
            case 4:
                message.s3 = reader.float();
                break;
            case 5:
                message.s4 = reader.float();
                break;
            case 6:
                message.s5 = reader.float();
                break;
            case 7:
                message.s6 = reader.float();
                break;
            case 8:
                message.s7 = reader.float();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return fvec8;
})();

export const ivec8 = $root.ivec8 = (() => {

    /**
     * Properties of an ivec8.
     * @exports Iivec8
     * @interface Iivec8
     * @property {number|null} [s0] ivec8 s0
     * @property {number|null} [s1] ivec8 s1
     * @property {number|null} [s2] ivec8 s2
     * @property {number|null} [s3] ivec8 s3
     * @property {number|null} [s4] ivec8 s4
     * @property {number|null} [s5] ivec8 s5
     * @property {number|null} [s6] ivec8 s6
     * @property {number|null} [s7] ivec8 s7
     */

    /**
     * Constructs a new ivec8.
     * @exports ivec8
     * @classdesc Represents an ivec8.
     * @implements Iivec8
     * @constructor
     * @param {Iivec8=} [properties] Properties to set
     */
    function ivec8(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ivec8 s0.
     * @member {number} s0
     * @memberof ivec8
     * @instance
     */
    ivec8.prototype.s0 = 0;

    /**
     * ivec8 s1.
     * @member {number} s1
     * @memberof ivec8
     * @instance
     */
    ivec8.prototype.s1 = 0;

    /**
     * ivec8 s2.
     * @member {number} s2
     * @memberof ivec8
     * @instance
     */
    ivec8.prototype.s2 = 0;

    /**
     * ivec8 s3.
     * @member {number} s3
     * @memberof ivec8
     * @instance
     */
    ivec8.prototype.s3 = 0;

    /**
     * ivec8 s4.
     * @member {number} s4
     * @memberof ivec8
     * @instance
     */
    ivec8.prototype.s4 = 0;

    /**
     * ivec8 s5.
     * @member {number} s5
     * @memberof ivec8
     * @instance
     */
    ivec8.prototype.s5 = 0;

    /**
     * ivec8 s6.
     * @member {number} s6
     * @memberof ivec8
     * @instance
     */
    ivec8.prototype.s6 = 0;

    /**
     * ivec8 s7.
     * @member {number} s7
     * @memberof ivec8
     * @instance
     */
    ivec8.prototype.s7 = 0;

    /**
     * Encodes the specified ivec8 message. Does not implicitly {@link ivec8.verify|verify} messages.
     * @function encode
     * @memberof ivec8
     * @static
     * @param {Iivec8} message ivec8 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ivec8.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            writer.uint32(/* id 1, wireType 0 =*/8).sint32(message.s0);
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            writer.uint32(/* id 2, wireType 0 =*/16).sint32(message.s1);
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            writer.uint32(/* id 3, wireType 0 =*/24).sint32(message.s2);
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            writer.uint32(/* id 4, wireType 0 =*/32).sint32(message.s3);
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            writer.uint32(/* id 5, wireType 0 =*/40).sint32(message.s4);
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            writer.uint32(/* id 6, wireType 0 =*/48).sint32(message.s5);
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            writer.uint32(/* id 7, wireType 0 =*/56).sint32(message.s6);
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            writer.uint32(/* id 8, wireType 0 =*/64).sint32(message.s7);
        return writer;
    };

    /**
     * Decodes an ivec8 message from the specified reader or buffer.
     * @function decode
     * @memberof ivec8
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ivec8} ivec8
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ivec8.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ivec8();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = reader.sint32();
                break;
            case 2:
                message.s1 = reader.sint32();
                break;
            case 3:
                message.s2 = reader.sint32();
                break;
            case 4:
                message.s3 = reader.sint32();
                break;
            case 5:
                message.s4 = reader.sint32();
                break;
            case 6:
                message.s5 = reader.sint32();
                break;
            case 7:
                message.s6 = reader.sint32();
                break;
            case 8:
                message.s7 = reader.sint32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return ivec8;
})();

export const uvec8 = $root.uvec8 = (() => {

    /**
     * Properties of an uvec8.
     * @exports Iuvec8
     * @interface Iuvec8
     * @property {number|null} [s0] uvec8 s0
     * @property {number|null} [s1] uvec8 s1
     * @property {number|null} [s2] uvec8 s2
     * @property {number|null} [s3] uvec8 s3
     * @property {number|null} [s4] uvec8 s4
     * @property {number|null} [s5] uvec8 s5
     * @property {number|null} [s6] uvec8 s6
     * @property {number|null} [s7] uvec8 s7
     */

    /**
     * Constructs a new uvec8.
     * @exports uvec8
     * @classdesc Represents an uvec8.
     * @implements Iuvec8
     * @constructor
     * @param {Iuvec8=} [properties] Properties to set
     */
    function uvec8(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * uvec8 s0.
     * @member {number} s0
     * @memberof uvec8
     * @instance
     */
    uvec8.prototype.s0 = 0;

    /**
     * uvec8 s1.
     * @member {number} s1
     * @memberof uvec8
     * @instance
     */
    uvec8.prototype.s1 = 0;

    /**
     * uvec8 s2.
     * @member {number} s2
     * @memberof uvec8
     * @instance
     */
    uvec8.prototype.s2 = 0;

    /**
     * uvec8 s3.
     * @member {number} s3
     * @memberof uvec8
     * @instance
     */
    uvec8.prototype.s3 = 0;

    /**
     * uvec8 s4.
     * @member {number} s4
     * @memberof uvec8
     * @instance
     */
    uvec8.prototype.s4 = 0;

    /**
     * uvec8 s5.
     * @member {number} s5
     * @memberof uvec8
     * @instance
     */
    uvec8.prototype.s5 = 0;

    /**
     * uvec8 s6.
     * @member {number} s6
     * @memberof uvec8
     * @instance
     */
    uvec8.prototype.s6 = 0;

    /**
     * uvec8 s7.
     * @member {number} s7
     * @memberof uvec8
     * @instance
     */
    uvec8.prototype.s7 = 0;

    /**
     * Encodes the specified uvec8 message. Does not implicitly {@link uvec8.verify|verify} messages.
     * @function encode
     * @memberof uvec8
     * @static
     * @param {Iuvec8} message uvec8 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    uvec8.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.s0);
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.s1);
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.s2);
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.s3);
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.s4);
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.s5);
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.s6);
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.s7);
        return writer;
    };

    /**
     * Decodes an uvec8 message from the specified reader or buffer.
     * @function decode
     * @memberof uvec8
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {uvec8} uvec8
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    uvec8.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.uvec8();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = reader.uint32();
                break;
            case 2:
                message.s1 = reader.uint32();
                break;
            case 3:
                message.s2 = reader.uint32();
                break;
            case 4:
                message.s3 = reader.uint32();
                break;
            case 5:
                message.s4 = reader.uint32();
                break;
            case 6:
                message.s5 = reader.uint32();
                break;
            case 7:
                message.s6 = reader.uint32();
                break;
            case 8:
                message.s7 = reader.uint32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return uvec8;
})();

export const vec9 = $root.vec9 = (() => {

    /**
     * Properties of a vec9.
     * @exports Ivec9
     * @interface Ivec9
     * @property {number|null} [s0] vec9 s0
     * @property {number|null} [s1] vec9 s1
     * @property {number|null} [s2] vec9 s2
     * @property {number|null} [s3] vec9 s3
     * @property {number|null} [s4] vec9 s4
     * @property {number|null} [s5] vec9 s5
     * @property {number|null} [s6] vec9 s6
     * @property {number|null} [s7] vec9 s7
     * @property {number|null} [s8] vec9 s8
     */

    /**
     * Constructs a new vec9.
     * @exports vec9
     * @classdesc Represents a vec9.
     * @implements Ivec9
     * @constructor
     * @param {Ivec9=} [properties] Properties to set
     */
    function vec9(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * vec9 s0.
     * @member {number} s0
     * @memberof vec9
     * @instance
     */
    vec9.prototype.s0 = 0;

    /**
     * vec9 s1.
     * @member {number} s1
     * @memberof vec9
     * @instance
     */
    vec9.prototype.s1 = 0;

    /**
     * vec9 s2.
     * @member {number} s2
     * @memberof vec9
     * @instance
     */
    vec9.prototype.s2 = 0;

    /**
     * vec9 s3.
     * @member {number} s3
     * @memberof vec9
     * @instance
     */
    vec9.prototype.s3 = 0;

    /**
     * vec9 s4.
     * @member {number} s4
     * @memberof vec9
     * @instance
     */
    vec9.prototype.s4 = 0;

    /**
     * vec9 s5.
     * @member {number} s5
     * @memberof vec9
     * @instance
     */
    vec9.prototype.s5 = 0;

    /**
     * vec9 s6.
     * @member {number} s6
     * @memberof vec9
     * @instance
     */
    vec9.prototype.s6 = 0;

    /**
     * vec9 s7.
     * @member {number} s7
     * @memberof vec9
     * @instance
     */
    vec9.prototype.s7 = 0;

    /**
     * vec9 s8.
     * @member {number} s8
     * @memberof vec9
     * @instance
     */
    vec9.prototype.s8 = 0;

    /**
     * Encodes the specified vec9 message. Does not implicitly {@link vec9.verify|verify} messages.
     * @function encode
     * @memberof vec9
     * @static
     * @param {Ivec9} message vec9 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    vec9.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            writer.uint32(/* id 1, wireType 1 =*/9).double(message.s0);
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            writer.uint32(/* id 2, wireType 1 =*/17).double(message.s1);
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            writer.uint32(/* id 3, wireType 1 =*/25).double(message.s2);
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            writer.uint32(/* id 4, wireType 1 =*/33).double(message.s3);
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            writer.uint32(/* id 5, wireType 1 =*/41).double(message.s4);
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            writer.uint32(/* id 6, wireType 1 =*/49).double(message.s5);
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            writer.uint32(/* id 7, wireType 1 =*/57).double(message.s6);
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            writer.uint32(/* id 8, wireType 1 =*/65).double(message.s7);
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            writer.uint32(/* id 9, wireType 1 =*/73).double(message.s8);
        return writer;
    };

    /**
     * Decodes a vec9 message from the specified reader or buffer.
     * @function decode
     * @memberof vec9
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {vec9} vec9
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    vec9.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.vec9();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = reader.double();
                break;
            case 2:
                message.s1 = reader.double();
                break;
            case 3:
                message.s2 = reader.double();
                break;
            case 4:
                message.s3 = reader.double();
                break;
            case 5:
                message.s4 = reader.double();
                break;
            case 6:
                message.s5 = reader.double();
                break;
            case 7:
                message.s6 = reader.double();
                break;
            case 8:
                message.s7 = reader.double();
                break;
            case 9:
                message.s8 = reader.double();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return vec9;
})();

export const fvec9 = $root.fvec9 = (() => {

    /**
     * Properties of a fvec9.
     * @exports Ifvec9
     * @interface Ifvec9
     * @property {number|null} [s0] fvec9 s0
     * @property {number|null} [s1] fvec9 s1
     * @property {number|null} [s2] fvec9 s2
     * @property {number|null} [s3] fvec9 s3
     * @property {number|null} [s4] fvec9 s4
     * @property {number|null} [s5] fvec9 s5
     * @property {number|null} [s6] fvec9 s6
     * @property {number|null} [s7] fvec9 s7
     * @property {number|null} [s8] fvec9 s8
     */

    /**
     * Constructs a new fvec9.
     * @exports fvec9
     * @classdesc Represents a fvec9.
     * @implements Ifvec9
     * @constructor
     * @param {Ifvec9=} [properties] Properties to set
     */
    function fvec9(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * fvec9 s0.
     * @member {number} s0
     * @memberof fvec9
     * @instance
     */
    fvec9.prototype.s0 = 0;

    /**
     * fvec9 s1.
     * @member {number} s1
     * @memberof fvec9
     * @instance
     */
    fvec9.prototype.s1 = 0;

    /**
     * fvec9 s2.
     * @member {number} s2
     * @memberof fvec9
     * @instance
     */
    fvec9.prototype.s2 = 0;

    /**
     * fvec9 s3.
     * @member {number} s3
     * @memberof fvec9
     * @instance
     */
    fvec9.prototype.s3 = 0;

    /**
     * fvec9 s4.
     * @member {number} s4
     * @memberof fvec9
     * @instance
     */
    fvec9.prototype.s4 = 0;

    /**
     * fvec9 s5.
     * @member {number} s5
     * @memberof fvec9
     * @instance
     */
    fvec9.prototype.s5 = 0;

    /**
     * fvec9 s6.
     * @member {number} s6
     * @memberof fvec9
     * @instance
     */
    fvec9.prototype.s6 = 0;

    /**
     * fvec9 s7.
     * @member {number} s7
     * @memberof fvec9
     * @instance
     */
    fvec9.prototype.s7 = 0;

    /**
     * fvec9 s8.
     * @member {number} s8
     * @memberof fvec9
     * @instance
     */
    fvec9.prototype.s8 = 0;

    /**
     * Encodes the specified fvec9 message. Does not implicitly {@link fvec9.verify|verify} messages.
     * @function encode
     * @memberof fvec9
     * @static
     * @param {Ifvec9} message fvec9 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    fvec9.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            writer.uint32(/* id 1, wireType 5 =*/13).float(message.s0);
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            writer.uint32(/* id 2, wireType 5 =*/21).float(message.s1);
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            writer.uint32(/* id 3, wireType 5 =*/29).float(message.s2);
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            writer.uint32(/* id 4, wireType 5 =*/37).float(message.s3);
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            writer.uint32(/* id 5, wireType 5 =*/45).float(message.s4);
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            writer.uint32(/* id 6, wireType 5 =*/53).float(message.s5);
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            writer.uint32(/* id 7, wireType 5 =*/61).float(message.s6);
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            writer.uint32(/* id 8, wireType 5 =*/69).float(message.s7);
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            writer.uint32(/* id 9, wireType 5 =*/77).float(message.s8);
        return writer;
    };

    /**
     * Decodes a fvec9 message from the specified reader or buffer.
     * @function decode
     * @memberof fvec9
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {fvec9} fvec9
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    fvec9.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.fvec9();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = reader.float();
                break;
            case 2:
                message.s1 = reader.float();
                break;
            case 3:
                message.s2 = reader.float();
                break;
            case 4:
                message.s3 = reader.float();
                break;
            case 5:
                message.s4 = reader.float();
                break;
            case 6:
                message.s5 = reader.float();
                break;
            case 7:
                message.s6 = reader.float();
                break;
            case 8:
                message.s7 = reader.float();
                break;
            case 9:
                message.s8 = reader.float();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return fvec9;
})();

export const ivec9 = $root.ivec9 = (() => {

    /**
     * Properties of an ivec9.
     * @exports Iivec9
     * @interface Iivec9
     * @property {number|null} [s0] ivec9 s0
     * @property {number|null} [s1] ivec9 s1
     * @property {number|null} [s2] ivec9 s2
     * @property {number|null} [s3] ivec9 s3
     * @property {number|null} [s4] ivec9 s4
     * @property {number|null} [s5] ivec9 s5
     * @property {number|null} [s6] ivec9 s6
     * @property {number|null} [s7] ivec9 s7
     * @property {number|null} [s8] ivec9 s8
     */

    /**
     * Constructs a new ivec9.
     * @exports ivec9
     * @classdesc Represents an ivec9.
     * @implements Iivec9
     * @constructor
     * @param {Iivec9=} [properties] Properties to set
     */
    function ivec9(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ivec9 s0.
     * @member {number} s0
     * @memberof ivec9
     * @instance
     */
    ivec9.prototype.s0 = 0;

    /**
     * ivec9 s1.
     * @member {number} s1
     * @memberof ivec9
     * @instance
     */
    ivec9.prototype.s1 = 0;

    /**
     * ivec9 s2.
     * @member {number} s2
     * @memberof ivec9
     * @instance
     */
    ivec9.prototype.s2 = 0;

    /**
     * ivec9 s3.
     * @member {number} s3
     * @memberof ivec9
     * @instance
     */
    ivec9.prototype.s3 = 0;

    /**
     * ivec9 s4.
     * @member {number} s4
     * @memberof ivec9
     * @instance
     */
    ivec9.prototype.s4 = 0;

    /**
     * ivec9 s5.
     * @member {number} s5
     * @memberof ivec9
     * @instance
     */
    ivec9.prototype.s5 = 0;

    /**
     * ivec9 s6.
     * @member {number} s6
     * @memberof ivec9
     * @instance
     */
    ivec9.prototype.s6 = 0;

    /**
     * ivec9 s7.
     * @member {number} s7
     * @memberof ivec9
     * @instance
     */
    ivec9.prototype.s7 = 0;

    /**
     * ivec9 s8.
     * @member {number} s8
     * @memberof ivec9
     * @instance
     */
    ivec9.prototype.s8 = 0;

    /**
     * Encodes the specified ivec9 message. Does not implicitly {@link ivec9.verify|verify} messages.
     * @function encode
     * @memberof ivec9
     * @static
     * @param {Iivec9} message ivec9 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ivec9.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            writer.uint32(/* id 1, wireType 0 =*/8).sint32(message.s0);
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            writer.uint32(/* id 2, wireType 0 =*/16).sint32(message.s1);
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            writer.uint32(/* id 3, wireType 0 =*/24).sint32(message.s2);
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            writer.uint32(/* id 4, wireType 0 =*/32).sint32(message.s3);
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            writer.uint32(/* id 5, wireType 0 =*/40).sint32(message.s4);
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            writer.uint32(/* id 6, wireType 0 =*/48).sint32(message.s5);
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            writer.uint32(/* id 7, wireType 0 =*/56).sint32(message.s6);
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            writer.uint32(/* id 8, wireType 0 =*/64).sint32(message.s7);
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            writer.uint32(/* id 9, wireType 0 =*/72).sint32(message.s8);
        return writer;
    };

    /**
     * Decodes an ivec9 message from the specified reader or buffer.
     * @function decode
     * @memberof ivec9
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ivec9} ivec9
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ivec9.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ivec9();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = reader.sint32();
                break;
            case 2:
                message.s1 = reader.sint32();
                break;
            case 3:
                message.s2 = reader.sint32();
                break;
            case 4:
                message.s3 = reader.sint32();
                break;
            case 5:
                message.s4 = reader.sint32();
                break;
            case 6:
                message.s5 = reader.sint32();
                break;
            case 7:
                message.s6 = reader.sint32();
                break;
            case 8:
                message.s7 = reader.sint32();
                break;
            case 9:
                message.s8 = reader.sint32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return ivec9;
})();

export const uvec9 = $root.uvec9 = (() => {

    /**
     * Properties of an uvec9.
     * @exports Iuvec9
     * @interface Iuvec9
     * @property {number|null} [s0] uvec9 s0
     * @property {number|null} [s1] uvec9 s1
     * @property {number|null} [s2] uvec9 s2
     * @property {number|null} [s3] uvec9 s3
     * @property {number|null} [s4] uvec9 s4
     * @property {number|null} [s5] uvec9 s5
     * @property {number|null} [s6] uvec9 s6
     * @property {number|null} [s7] uvec9 s7
     * @property {number|null} [s8] uvec9 s8
     */

    /**
     * Constructs a new uvec9.
     * @exports uvec9
     * @classdesc Represents an uvec9.
     * @implements Iuvec9
     * @constructor
     * @param {Iuvec9=} [properties] Properties to set
     */
    function uvec9(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * uvec9 s0.
     * @member {number} s0
     * @memberof uvec9
     * @instance
     */
    uvec9.prototype.s0 = 0;

    /**
     * uvec9 s1.
     * @member {number} s1
     * @memberof uvec9
     * @instance
     */
    uvec9.prototype.s1 = 0;

    /**
     * uvec9 s2.
     * @member {number} s2
     * @memberof uvec9
     * @instance
     */
    uvec9.prototype.s2 = 0;

    /**
     * uvec9 s3.
     * @member {number} s3
     * @memberof uvec9
     * @instance
     */
    uvec9.prototype.s3 = 0;

    /**
     * uvec9 s4.
     * @member {number} s4
     * @memberof uvec9
     * @instance
     */
    uvec9.prototype.s4 = 0;

    /**
     * uvec9 s5.
     * @member {number} s5
     * @memberof uvec9
     * @instance
     */
    uvec9.prototype.s5 = 0;

    /**
     * uvec9 s6.
     * @member {number} s6
     * @memberof uvec9
     * @instance
     */
    uvec9.prototype.s6 = 0;

    /**
     * uvec9 s7.
     * @member {number} s7
     * @memberof uvec9
     * @instance
     */
    uvec9.prototype.s7 = 0;

    /**
     * uvec9 s8.
     * @member {number} s8
     * @memberof uvec9
     * @instance
     */
    uvec9.prototype.s8 = 0;

    /**
     * Encodes the specified uvec9 message. Does not implicitly {@link uvec9.verify|verify} messages.
     * @function encode
     * @memberof uvec9
     * @static
     * @param {Iuvec9} message uvec9 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    uvec9.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.s0);
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.s1);
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.s2);
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.s3);
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.s4);
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.s5);
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.s6);
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.s7);
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.s8);
        return writer;
    };

    /**
     * Decodes an uvec9 message from the specified reader or buffer.
     * @function decode
     * @memberof uvec9
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {uvec9} uvec9
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    uvec9.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.uvec9();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = reader.uint32();
                break;
            case 2:
                message.s1 = reader.uint32();
                break;
            case 3:
                message.s2 = reader.uint32();
                break;
            case 4:
                message.s3 = reader.uint32();
                break;
            case 5:
                message.s4 = reader.uint32();
                break;
            case 6:
                message.s5 = reader.uint32();
                break;
            case 7:
                message.s6 = reader.uint32();
                break;
            case 8:
                message.s7 = reader.uint32();
                break;
            case 9:
                message.s8 = reader.uint32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return uvec9;
})();

export const vec10 = $root.vec10 = (() => {

    /**
     * Properties of a vec10.
     * @exports Ivec10
     * @interface Ivec10
     * @property {number|null} [s0] vec10 s0
     * @property {number|null} [s1] vec10 s1
     * @property {number|null} [s2] vec10 s2
     * @property {number|null} [s3] vec10 s3
     * @property {number|null} [s4] vec10 s4
     * @property {number|null} [s5] vec10 s5
     * @property {number|null} [s6] vec10 s6
     * @property {number|null} [s7] vec10 s7
     * @property {number|null} [s8] vec10 s8
     * @property {number|null} [s9] vec10 s9
     */

    /**
     * Constructs a new vec10.
     * @exports vec10
     * @classdesc Represents a vec10.
     * @implements Ivec10
     * @constructor
     * @param {Ivec10=} [properties] Properties to set
     */
    function vec10(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * vec10 s0.
     * @member {number} s0
     * @memberof vec10
     * @instance
     */
    vec10.prototype.s0 = 0;

    /**
     * vec10 s1.
     * @member {number} s1
     * @memberof vec10
     * @instance
     */
    vec10.prototype.s1 = 0;

    /**
     * vec10 s2.
     * @member {number} s2
     * @memberof vec10
     * @instance
     */
    vec10.prototype.s2 = 0;

    /**
     * vec10 s3.
     * @member {number} s3
     * @memberof vec10
     * @instance
     */
    vec10.prototype.s3 = 0;

    /**
     * vec10 s4.
     * @member {number} s4
     * @memberof vec10
     * @instance
     */
    vec10.prototype.s4 = 0;

    /**
     * vec10 s5.
     * @member {number} s5
     * @memberof vec10
     * @instance
     */
    vec10.prototype.s5 = 0;

    /**
     * vec10 s6.
     * @member {number} s6
     * @memberof vec10
     * @instance
     */
    vec10.prototype.s6 = 0;

    /**
     * vec10 s7.
     * @member {number} s7
     * @memberof vec10
     * @instance
     */
    vec10.prototype.s7 = 0;

    /**
     * vec10 s8.
     * @member {number} s8
     * @memberof vec10
     * @instance
     */
    vec10.prototype.s8 = 0;

    /**
     * vec10 s9.
     * @member {number} s9
     * @memberof vec10
     * @instance
     */
    vec10.prototype.s9 = 0;

    /**
     * Encodes the specified vec10 message. Does not implicitly {@link vec10.verify|verify} messages.
     * @function encode
     * @memberof vec10
     * @static
     * @param {Ivec10} message vec10 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    vec10.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            writer.uint32(/* id 1, wireType 1 =*/9).double(message.s0);
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            writer.uint32(/* id 2, wireType 1 =*/17).double(message.s1);
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            writer.uint32(/* id 3, wireType 1 =*/25).double(message.s2);
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            writer.uint32(/* id 4, wireType 1 =*/33).double(message.s3);
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            writer.uint32(/* id 5, wireType 1 =*/41).double(message.s4);
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            writer.uint32(/* id 6, wireType 1 =*/49).double(message.s5);
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            writer.uint32(/* id 7, wireType 1 =*/57).double(message.s6);
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            writer.uint32(/* id 8, wireType 1 =*/65).double(message.s7);
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            writer.uint32(/* id 9, wireType 1 =*/73).double(message.s8);
        if (message.s9 != null && Object.hasOwnProperty.call(message, "s9"))
            writer.uint32(/* id 10, wireType 1 =*/81).double(message.s9);
        return writer;
    };

    /**
     * Decodes a vec10 message from the specified reader or buffer.
     * @function decode
     * @memberof vec10
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {vec10} vec10
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    vec10.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.vec10();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = reader.double();
                break;
            case 2:
                message.s1 = reader.double();
                break;
            case 3:
                message.s2 = reader.double();
                break;
            case 4:
                message.s3 = reader.double();
                break;
            case 5:
                message.s4 = reader.double();
                break;
            case 6:
                message.s5 = reader.double();
                break;
            case 7:
                message.s6 = reader.double();
                break;
            case 8:
                message.s7 = reader.double();
                break;
            case 9:
                message.s8 = reader.double();
                break;
            case 10:
                message.s9 = reader.double();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return vec10;
})();

export const fvec10 = $root.fvec10 = (() => {

    /**
     * Properties of a fvec10.
     * @exports Ifvec10
     * @interface Ifvec10
     * @property {number|null} [s0] fvec10 s0
     * @property {number|null} [s1] fvec10 s1
     * @property {number|null} [s2] fvec10 s2
     * @property {number|null} [s3] fvec10 s3
     * @property {number|null} [s4] fvec10 s4
     * @property {number|null} [s5] fvec10 s5
     * @property {number|null} [s6] fvec10 s6
     * @property {number|null} [s7] fvec10 s7
     * @property {number|null} [s8] fvec10 s8
     * @property {number|null} [s9] fvec10 s9
     */

    /**
     * Constructs a new fvec10.
     * @exports fvec10
     * @classdesc Represents a fvec10.
     * @implements Ifvec10
     * @constructor
     * @param {Ifvec10=} [properties] Properties to set
     */
    function fvec10(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * fvec10 s0.
     * @member {number} s0
     * @memberof fvec10
     * @instance
     */
    fvec10.prototype.s0 = 0;

    /**
     * fvec10 s1.
     * @member {number} s1
     * @memberof fvec10
     * @instance
     */
    fvec10.prototype.s1 = 0;

    /**
     * fvec10 s2.
     * @member {number} s2
     * @memberof fvec10
     * @instance
     */
    fvec10.prototype.s2 = 0;

    /**
     * fvec10 s3.
     * @member {number} s3
     * @memberof fvec10
     * @instance
     */
    fvec10.prototype.s3 = 0;

    /**
     * fvec10 s4.
     * @member {number} s4
     * @memberof fvec10
     * @instance
     */
    fvec10.prototype.s4 = 0;

    /**
     * fvec10 s5.
     * @member {number} s5
     * @memberof fvec10
     * @instance
     */
    fvec10.prototype.s5 = 0;

    /**
     * fvec10 s6.
     * @member {number} s6
     * @memberof fvec10
     * @instance
     */
    fvec10.prototype.s6 = 0;

    /**
     * fvec10 s7.
     * @member {number} s7
     * @memberof fvec10
     * @instance
     */
    fvec10.prototype.s7 = 0;

    /**
     * fvec10 s8.
     * @member {number} s8
     * @memberof fvec10
     * @instance
     */
    fvec10.prototype.s8 = 0;

    /**
     * fvec10 s9.
     * @member {number} s9
     * @memberof fvec10
     * @instance
     */
    fvec10.prototype.s9 = 0;

    /**
     * Encodes the specified fvec10 message. Does not implicitly {@link fvec10.verify|verify} messages.
     * @function encode
     * @memberof fvec10
     * @static
     * @param {Ifvec10} message fvec10 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    fvec10.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            writer.uint32(/* id 1, wireType 5 =*/13).float(message.s0);
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            writer.uint32(/* id 2, wireType 5 =*/21).float(message.s1);
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            writer.uint32(/* id 3, wireType 5 =*/29).float(message.s2);
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            writer.uint32(/* id 4, wireType 5 =*/37).float(message.s3);
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            writer.uint32(/* id 5, wireType 5 =*/45).float(message.s4);
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            writer.uint32(/* id 6, wireType 5 =*/53).float(message.s5);
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            writer.uint32(/* id 7, wireType 5 =*/61).float(message.s6);
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            writer.uint32(/* id 8, wireType 5 =*/69).float(message.s7);
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            writer.uint32(/* id 9, wireType 5 =*/77).float(message.s8);
        if (message.s9 != null && Object.hasOwnProperty.call(message, "s9"))
            writer.uint32(/* id 10, wireType 5 =*/85).float(message.s9);
        return writer;
    };

    /**
     * Decodes a fvec10 message from the specified reader or buffer.
     * @function decode
     * @memberof fvec10
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {fvec10} fvec10
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    fvec10.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.fvec10();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = reader.float();
                break;
            case 2:
                message.s1 = reader.float();
                break;
            case 3:
                message.s2 = reader.float();
                break;
            case 4:
                message.s3 = reader.float();
                break;
            case 5:
                message.s4 = reader.float();
                break;
            case 6:
                message.s5 = reader.float();
                break;
            case 7:
                message.s6 = reader.float();
                break;
            case 8:
                message.s7 = reader.float();
                break;
            case 9:
                message.s8 = reader.float();
                break;
            case 10:
                message.s9 = reader.float();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return fvec10;
})();

export const ivec10 = $root.ivec10 = (() => {

    /**
     * Properties of an ivec10.
     * @exports Iivec10
     * @interface Iivec10
     * @property {number|null} [s0] ivec10 s0
     * @property {number|null} [s1] ivec10 s1
     * @property {number|null} [s2] ivec10 s2
     * @property {number|null} [s3] ivec10 s3
     * @property {number|null} [s4] ivec10 s4
     * @property {number|null} [s5] ivec10 s5
     * @property {number|null} [s6] ivec10 s6
     * @property {number|null} [s7] ivec10 s7
     * @property {number|null} [s8] ivec10 s8
     * @property {number|null} [s9] ivec10 s9
     */

    /**
     * Constructs a new ivec10.
     * @exports ivec10
     * @classdesc Represents an ivec10.
     * @implements Iivec10
     * @constructor
     * @param {Iivec10=} [properties] Properties to set
     */
    function ivec10(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ivec10 s0.
     * @member {number} s0
     * @memberof ivec10
     * @instance
     */
    ivec10.prototype.s0 = 0;

    /**
     * ivec10 s1.
     * @member {number} s1
     * @memberof ivec10
     * @instance
     */
    ivec10.prototype.s1 = 0;

    /**
     * ivec10 s2.
     * @member {number} s2
     * @memberof ivec10
     * @instance
     */
    ivec10.prototype.s2 = 0;

    /**
     * ivec10 s3.
     * @member {number} s3
     * @memberof ivec10
     * @instance
     */
    ivec10.prototype.s3 = 0;

    /**
     * ivec10 s4.
     * @member {number} s4
     * @memberof ivec10
     * @instance
     */
    ivec10.prototype.s4 = 0;

    /**
     * ivec10 s5.
     * @member {number} s5
     * @memberof ivec10
     * @instance
     */
    ivec10.prototype.s5 = 0;

    /**
     * ivec10 s6.
     * @member {number} s6
     * @memberof ivec10
     * @instance
     */
    ivec10.prototype.s6 = 0;

    /**
     * ivec10 s7.
     * @member {number} s7
     * @memberof ivec10
     * @instance
     */
    ivec10.prototype.s7 = 0;

    /**
     * ivec10 s8.
     * @member {number} s8
     * @memberof ivec10
     * @instance
     */
    ivec10.prototype.s8 = 0;

    /**
     * ivec10 s9.
     * @member {number} s9
     * @memberof ivec10
     * @instance
     */
    ivec10.prototype.s9 = 0;

    /**
     * Encodes the specified ivec10 message. Does not implicitly {@link ivec10.verify|verify} messages.
     * @function encode
     * @memberof ivec10
     * @static
     * @param {Iivec10} message ivec10 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ivec10.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            writer.uint32(/* id 1, wireType 0 =*/8).sint32(message.s0);
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            writer.uint32(/* id 2, wireType 0 =*/16).sint32(message.s1);
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            writer.uint32(/* id 3, wireType 0 =*/24).sint32(message.s2);
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            writer.uint32(/* id 4, wireType 0 =*/32).sint32(message.s3);
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            writer.uint32(/* id 5, wireType 0 =*/40).sint32(message.s4);
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            writer.uint32(/* id 6, wireType 0 =*/48).sint32(message.s5);
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            writer.uint32(/* id 7, wireType 0 =*/56).sint32(message.s6);
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            writer.uint32(/* id 8, wireType 0 =*/64).sint32(message.s7);
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            writer.uint32(/* id 9, wireType 0 =*/72).sint32(message.s8);
        if (message.s9 != null && Object.hasOwnProperty.call(message, "s9"))
            writer.uint32(/* id 10, wireType 0 =*/80).sint32(message.s9);
        return writer;
    };

    /**
     * Decodes an ivec10 message from the specified reader or buffer.
     * @function decode
     * @memberof ivec10
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ivec10} ivec10
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ivec10.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ivec10();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = reader.sint32();
                break;
            case 2:
                message.s1 = reader.sint32();
                break;
            case 3:
                message.s2 = reader.sint32();
                break;
            case 4:
                message.s3 = reader.sint32();
                break;
            case 5:
                message.s4 = reader.sint32();
                break;
            case 6:
                message.s5 = reader.sint32();
                break;
            case 7:
                message.s6 = reader.sint32();
                break;
            case 8:
                message.s7 = reader.sint32();
                break;
            case 9:
                message.s8 = reader.sint32();
                break;
            case 10:
                message.s9 = reader.sint32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return ivec10;
})();

export const uvec10 = $root.uvec10 = (() => {

    /**
     * Properties of an uvec10.
     * @exports Iuvec10
     * @interface Iuvec10
     * @property {number|null} [s0] uvec10 s0
     * @property {number|null} [s1] uvec10 s1
     * @property {number|null} [s2] uvec10 s2
     * @property {number|null} [s3] uvec10 s3
     * @property {number|null} [s4] uvec10 s4
     * @property {number|null} [s5] uvec10 s5
     * @property {number|null} [s6] uvec10 s6
     * @property {number|null} [s7] uvec10 s7
     * @property {number|null} [s8] uvec10 s8
     * @property {number|null} [s9] uvec10 s9
     */

    /**
     * Constructs a new uvec10.
     * @exports uvec10
     * @classdesc Represents an uvec10.
     * @implements Iuvec10
     * @constructor
     * @param {Iuvec10=} [properties] Properties to set
     */
    function uvec10(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * uvec10 s0.
     * @member {number} s0
     * @memberof uvec10
     * @instance
     */
    uvec10.prototype.s0 = 0;

    /**
     * uvec10 s1.
     * @member {number} s1
     * @memberof uvec10
     * @instance
     */
    uvec10.prototype.s1 = 0;

    /**
     * uvec10 s2.
     * @member {number} s2
     * @memberof uvec10
     * @instance
     */
    uvec10.prototype.s2 = 0;

    /**
     * uvec10 s3.
     * @member {number} s3
     * @memberof uvec10
     * @instance
     */
    uvec10.prototype.s3 = 0;

    /**
     * uvec10 s4.
     * @member {number} s4
     * @memberof uvec10
     * @instance
     */
    uvec10.prototype.s4 = 0;

    /**
     * uvec10 s5.
     * @member {number} s5
     * @memberof uvec10
     * @instance
     */
    uvec10.prototype.s5 = 0;

    /**
     * uvec10 s6.
     * @member {number} s6
     * @memberof uvec10
     * @instance
     */
    uvec10.prototype.s6 = 0;

    /**
     * uvec10 s7.
     * @member {number} s7
     * @memberof uvec10
     * @instance
     */
    uvec10.prototype.s7 = 0;

    /**
     * uvec10 s8.
     * @member {number} s8
     * @memberof uvec10
     * @instance
     */
    uvec10.prototype.s8 = 0;

    /**
     * uvec10 s9.
     * @member {number} s9
     * @memberof uvec10
     * @instance
     */
    uvec10.prototype.s9 = 0;

    /**
     * Encodes the specified uvec10 message. Does not implicitly {@link uvec10.verify|verify} messages.
     * @function encode
     * @memberof uvec10
     * @static
     * @param {Iuvec10} message uvec10 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    uvec10.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.s0);
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.s1);
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.s2);
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.s3);
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.s4);
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.s5);
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.s6);
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.s7);
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.s8);
        if (message.s9 != null && Object.hasOwnProperty.call(message, "s9"))
            writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.s9);
        return writer;
    };

    /**
     * Decodes an uvec10 message from the specified reader or buffer.
     * @function decode
     * @memberof uvec10
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {uvec10} uvec10
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    uvec10.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.uvec10();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = reader.uint32();
                break;
            case 2:
                message.s1 = reader.uint32();
                break;
            case 3:
                message.s2 = reader.uint32();
                break;
            case 4:
                message.s3 = reader.uint32();
                break;
            case 5:
                message.s4 = reader.uint32();
                break;
            case 6:
                message.s5 = reader.uint32();
                break;
            case 7:
                message.s6 = reader.uint32();
                break;
            case 8:
                message.s7 = reader.uint32();
                break;
            case 9:
                message.s8 = reader.uint32();
                break;
            case 10:
                message.s9 = reader.uint32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return uvec10;
})();

export const vec11 = $root.vec11 = (() => {

    /**
     * Properties of a vec11.
     * @exports Ivec11
     * @interface Ivec11
     * @property {number|null} [s0] vec11 s0
     * @property {number|null} [s1] vec11 s1
     * @property {number|null} [s2] vec11 s2
     * @property {number|null} [s3] vec11 s3
     * @property {number|null} [s4] vec11 s4
     * @property {number|null} [s5] vec11 s5
     * @property {number|null} [s6] vec11 s6
     * @property {number|null} [s7] vec11 s7
     * @property {number|null} [s8] vec11 s8
     * @property {number|null} [s9] vec11 s9
     * @property {number|null} [sa] vec11 sa
     */

    /**
     * Constructs a new vec11.
     * @exports vec11
     * @classdesc Represents a vec11.
     * @implements Ivec11
     * @constructor
     * @param {Ivec11=} [properties] Properties to set
     */
    function vec11(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * vec11 s0.
     * @member {number} s0
     * @memberof vec11
     * @instance
     */
    vec11.prototype.s0 = 0;

    /**
     * vec11 s1.
     * @member {number} s1
     * @memberof vec11
     * @instance
     */
    vec11.prototype.s1 = 0;

    /**
     * vec11 s2.
     * @member {number} s2
     * @memberof vec11
     * @instance
     */
    vec11.prototype.s2 = 0;

    /**
     * vec11 s3.
     * @member {number} s3
     * @memberof vec11
     * @instance
     */
    vec11.prototype.s3 = 0;

    /**
     * vec11 s4.
     * @member {number} s4
     * @memberof vec11
     * @instance
     */
    vec11.prototype.s4 = 0;

    /**
     * vec11 s5.
     * @member {number} s5
     * @memberof vec11
     * @instance
     */
    vec11.prototype.s5 = 0;

    /**
     * vec11 s6.
     * @member {number} s6
     * @memberof vec11
     * @instance
     */
    vec11.prototype.s6 = 0;

    /**
     * vec11 s7.
     * @member {number} s7
     * @memberof vec11
     * @instance
     */
    vec11.prototype.s7 = 0;

    /**
     * vec11 s8.
     * @member {number} s8
     * @memberof vec11
     * @instance
     */
    vec11.prototype.s8 = 0;

    /**
     * vec11 s9.
     * @member {number} s9
     * @memberof vec11
     * @instance
     */
    vec11.prototype.s9 = 0;

    /**
     * vec11 sa.
     * @member {number} sa
     * @memberof vec11
     * @instance
     */
    vec11.prototype.sa = 0;

    /**
     * Encodes the specified vec11 message. Does not implicitly {@link vec11.verify|verify} messages.
     * @function encode
     * @memberof vec11
     * @static
     * @param {Ivec11} message vec11 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    vec11.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            writer.uint32(/* id 1, wireType 1 =*/9).double(message.s0);
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            writer.uint32(/* id 2, wireType 1 =*/17).double(message.s1);
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            writer.uint32(/* id 3, wireType 1 =*/25).double(message.s2);
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            writer.uint32(/* id 4, wireType 1 =*/33).double(message.s3);
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            writer.uint32(/* id 5, wireType 1 =*/41).double(message.s4);
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            writer.uint32(/* id 6, wireType 1 =*/49).double(message.s5);
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            writer.uint32(/* id 7, wireType 1 =*/57).double(message.s6);
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            writer.uint32(/* id 8, wireType 1 =*/65).double(message.s7);
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            writer.uint32(/* id 9, wireType 1 =*/73).double(message.s8);
        if (message.s9 != null && Object.hasOwnProperty.call(message, "s9"))
            writer.uint32(/* id 10, wireType 1 =*/81).double(message.s9);
        if (message.sa != null && Object.hasOwnProperty.call(message, "sa"))
            writer.uint32(/* id 11, wireType 1 =*/89).double(message.sa);
        return writer;
    };

    /**
     * Decodes a vec11 message from the specified reader or buffer.
     * @function decode
     * @memberof vec11
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {vec11} vec11
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    vec11.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.vec11();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = reader.double();
                break;
            case 2:
                message.s1 = reader.double();
                break;
            case 3:
                message.s2 = reader.double();
                break;
            case 4:
                message.s3 = reader.double();
                break;
            case 5:
                message.s4 = reader.double();
                break;
            case 6:
                message.s5 = reader.double();
                break;
            case 7:
                message.s6 = reader.double();
                break;
            case 8:
                message.s7 = reader.double();
                break;
            case 9:
                message.s8 = reader.double();
                break;
            case 10:
                message.s9 = reader.double();
                break;
            case 11:
                message.sa = reader.double();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return vec11;
})();

export const fvec11 = $root.fvec11 = (() => {

    /**
     * Properties of a fvec11.
     * @exports Ifvec11
     * @interface Ifvec11
     * @property {number|null} [s0] fvec11 s0
     * @property {number|null} [s1] fvec11 s1
     * @property {number|null} [s2] fvec11 s2
     * @property {number|null} [s3] fvec11 s3
     * @property {number|null} [s4] fvec11 s4
     * @property {number|null} [s5] fvec11 s5
     * @property {number|null} [s6] fvec11 s6
     * @property {number|null} [s7] fvec11 s7
     * @property {number|null} [s8] fvec11 s8
     * @property {number|null} [s9] fvec11 s9
     * @property {number|null} [sa] fvec11 sa
     */

    /**
     * Constructs a new fvec11.
     * @exports fvec11
     * @classdesc Represents a fvec11.
     * @implements Ifvec11
     * @constructor
     * @param {Ifvec11=} [properties] Properties to set
     */
    function fvec11(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * fvec11 s0.
     * @member {number} s0
     * @memberof fvec11
     * @instance
     */
    fvec11.prototype.s0 = 0;

    /**
     * fvec11 s1.
     * @member {number} s1
     * @memberof fvec11
     * @instance
     */
    fvec11.prototype.s1 = 0;

    /**
     * fvec11 s2.
     * @member {number} s2
     * @memberof fvec11
     * @instance
     */
    fvec11.prototype.s2 = 0;

    /**
     * fvec11 s3.
     * @member {number} s3
     * @memberof fvec11
     * @instance
     */
    fvec11.prototype.s3 = 0;

    /**
     * fvec11 s4.
     * @member {number} s4
     * @memberof fvec11
     * @instance
     */
    fvec11.prototype.s4 = 0;

    /**
     * fvec11 s5.
     * @member {number} s5
     * @memberof fvec11
     * @instance
     */
    fvec11.prototype.s5 = 0;

    /**
     * fvec11 s6.
     * @member {number} s6
     * @memberof fvec11
     * @instance
     */
    fvec11.prototype.s6 = 0;

    /**
     * fvec11 s7.
     * @member {number} s7
     * @memberof fvec11
     * @instance
     */
    fvec11.prototype.s7 = 0;

    /**
     * fvec11 s8.
     * @member {number} s8
     * @memberof fvec11
     * @instance
     */
    fvec11.prototype.s8 = 0;

    /**
     * fvec11 s9.
     * @member {number} s9
     * @memberof fvec11
     * @instance
     */
    fvec11.prototype.s9 = 0;

    /**
     * fvec11 sa.
     * @member {number} sa
     * @memberof fvec11
     * @instance
     */
    fvec11.prototype.sa = 0;

    /**
     * Encodes the specified fvec11 message. Does not implicitly {@link fvec11.verify|verify} messages.
     * @function encode
     * @memberof fvec11
     * @static
     * @param {Ifvec11} message fvec11 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    fvec11.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            writer.uint32(/* id 1, wireType 5 =*/13).float(message.s0);
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            writer.uint32(/* id 2, wireType 5 =*/21).float(message.s1);
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            writer.uint32(/* id 3, wireType 5 =*/29).float(message.s2);
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            writer.uint32(/* id 4, wireType 5 =*/37).float(message.s3);
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            writer.uint32(/* id 5, wireType 5 =*/45).float(message.s4);
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            writer.uint32(/* id 6, wireType 5 =*/53).float(message.s5);
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            writer.uint32(/* id 7, wireType 5 =*/61).float(message.s6);
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            writer.uint32(/* id 8, wireType 5 =*/69).float(message.s7);
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            writer.uint32(/* id 9, wireType 5 =*/77).float(message.s8);
        if (message.s9 != null && Object.hasOwnProperty.call(message, "s9"))
            writer.uint32(/* id 10, wireType 5 =*/85).float(message.s9);
        if (message.sa != null && Object.hasOwnProperty.call(message, "sa"))
            writer.uint32(/* id 11, wireType 5 =*/93).float(message.sa);
        return writer;
    };

    /**
     * Decodes a fvec11 message from the specified reader or buffer.
     * @function decode
     * @memberof fvec11
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {fvec11} fvec11
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    fvec11.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.fvec11();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = reader.float();
                break;
            case 2:
                message.s1 = reader.float();
                break;
            case 3:
                message.s2 = reader.float();
                break;
            case 4:
                message.s3 = reader.float();
                break;
            case 5:
                message.s4 = reader.float();
                break;
            case 6:
                message.s5 = reader.float();
                break;
            case 7:
                message.s6 = reader.float();
                break;
            case 8:
                message.s7 = reader.float();
                break;
            case 9:
                message.s8 = reader.float();
                break;
            case 10:
                message.s9 = reader.float();
                break;
            case 11:
                message.sa = reader.float();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return fvec11;
})();

export const ivec11 = $root.ivec11 = (() => {

    /**
     * Properties of an ivec11.
     * @exports Iivec11
     * @interface Iivec11
     * @property {number|null} [s0] ivec11 s0
     * @property {number|null} [s1] ivec11 s1
     * @property {number|null} [s2] ivec11 s2
     * @property {number|null} [s3] ivec11 s3
     * @property {number|null} [s4] ivec11 s4
     * @property {number|null} [s5] ivec11 s5
     * @property {number|null} [s6] ivec11 s6
     * @property {number|null} [s7] ivec11 s7
     * @property {number|null} [s8] ivec11 s8
     * @property {number|null} [s9] ivec11 s9
     * @property {number|null} [sa] ivec11 sa
     */

    /**
     * Constructs a new ivec11.
     * @exports ivec11
     * @classdesc Represents an ivec11.
     * @implements Iivec11
     * @constructor
     * @param {Iivec11=} [properties] Properties to set
     */
    function ivec11(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ivec11 s0.
     * @member {number} s0
     * @memberof ivec11
     * @instance
     */
    ivec11.prototype.s0 = 0;

    /**
     * ivec11 s1.
     * @member {number} s1
     * @memberof ivec11
     * @instance
     */
    ivec11.prototype.s1 = 0;

    /**
     * ivec11 s2.
     * @member {number} s2
     * @memberof ivec11
     * @instance
     */
    ivec11.prototype.s2 = 0;

    /**
     * ivec11 s3.
     * @member {number} s3
     * @memberof ivec11
     * @instance
     */
    ivec11.prototype.s3 = 0;

    /**
     * ivec11 s4.
     * @member {number} s4
     * @memberof ivec11
     * @instance
     */
    ivec11.prototype.s4 = 0;

    /**
     * ivec11 s5.
     * @member {number} s5
     * @memberof ivec11
     * @instance
     */
    ivec11.prototype.s5 = 0;

    /**
     * ivec11 s6.
     * @member {number} s6
     * @memberof ivec11
     * @instance
     */
    ivec11.prototype.s6 = 0;

    /**
     * ivec11 s7.
     * @member {number} s7
     * @memberof ivec11
     * @instance
     */
    ivec11.prototype.s7 = 0;

    /**
     * ivec11 s8.
     * @member {number} s8
     * @memberof ivec11
     * @instance
     */
    ivec11.prototype.s8 = 0;

    /**
     * ivec11 s9.
     * @member {number} s9
     * @memberof ivec11
     * @instance
     */
    ivec11.prototype.s9 = 0;

    /**
     * ivec11 sa.
     * @member {number} sa
     * @memberof ivec11
     * @instance
     */
    ivec11.prototype.sa = 0;

    /**
     * Encodes the specified ivec11 message. Does not implicitly {@link ivec11.verify|verify} messages.
     * @function encode
     * @memberof ivec11
     * @static
     * @param {Iivec11} message ivec11 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ivec11.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            writer.uint32(/* id 1, wireType 0 =*/8).sint32(message.s0);
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            writer.uint32(/* id 2, wireType 0 =*/16).sint32(message.s1);
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            writer.uint32(/* id 3, wireType 0 =*/24).sint32(message.s2);
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            writer.uint32(/* id 4, wireType 0 =*/32).sint32(message.s3);
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            writer.uint32(/* id 5, wireType 0 =*/40).sint32(message.s4);
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            writer.uint32(/* id 6, wireType 0 =*/48).sint32(message.s5);
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            writer.uint32(/* id 7, wireType 0 =*/56).sint32(message.s6);
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            writer.uint32(/* id 8, wireType 0 =*/64).sint32(message.s7);
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            writer.uint32(/* id 9, wireType 0 =*/72).sint32(message.s8);
        if (message.s9 != null && Object.hasOwnProperty.call(message, "s9"))
            writer.uint32(/* id 10, wireType 0 =*/80).sint32(message.s9);
        if (message.sa != null && Object.hasOwnProperty.call(message, "sa"))
            writer.uint32(/* id 11, wireType 0 =*/88).sint32(message.sa);
        return writer;
    };

    /**
     * Decodes an ivec11 message from the specified reader or buffer.
     * @function decode
     * @memberof ivec11
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ivec11} ivec11
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ivec11.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ivec11();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = reader.sint32();
                break;
            case 2:
                message.s1 = reader.sint32();
                break;
            case 3:
                message.s2 = reader.sint32();
                break;
            case 4:
                message.s3 = reader.sint32();
                break;
            case 5:
                message.s4 = reader.sint32();
                break;
            case 6:
                message.s5 = reader.sint32();
                break;
            case 7:
                message.s6 = reader.sint32();
                break;
            case 8:
                message.s7 = reader.sint32();
                break;
            case 9:
                message.s8 = reader.sint32();
                break;
            case 10:
                message.s9 = reader.sint32();
                break;
            case 11:
                message.sa = reader.sint32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return ivec11;
})();

export const uvec11 = $root.uvec11 = (() => {

    /**
     * Properties of an uvec11.
     * @exports Iuvec11
     * @interface Iuvec11
     * @property {number|null} [s0] uvec11 s0
     * @property {number|null} [s1] uvec11 s1
     * @property {number|null} [s2] uvec11 s2
     * @property {number|null} [s3] uvec11 s3
     * @property {number|null} [s4] uvec11 s4
     * @property {number|null} [s5] uvec11 s5
     * @property {number|null} [s6] uvec11 s6
     * @property {number|null} [s7] uvec11 s7
     * @property {number|null} [s8] uvec11 s8
     * @property {number|null} [s9] uvec11 s9
     * @property {number|null} [sa] uvec11 sa
     */

    /**
     * Constructs a new uvec11.
     * @exports uvec11
     * @classdesc Represents an uvec11.
     * @implements Iuvec11
     * @constructor
     * @param {Iuvec11=} [properties] Properties to set
     */
    function uvec11(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * uvec11 s0.
     * @member {number} s0
     * @memberof uvec11
     * @instance
     */
    uvec11.prototype.s0 = 0;

    /**
     * uvec11 s1.
     * @member {number} s1
     * @memberof uvec11
     * @instance
     */
    uvec11.prototype.s1 = 0;

    /**
     * uvec11 s2.
     * @member {number} s2
     * @memberof uvec11
     * @instance
     */
    uvec11.prototype.s2 = 0;

    /**
     * uvec11 s3.
     * @member {number} s3
     * @memberof uvec11
     * @instance
     */
    uvec11.prototype.s3 = 0;

    /**
     * uvec11 s4.
     * @member {number} s4
     * @memberof uvec11
     * @instance
     */
    uvec11.prototype.s4 = 0;

    /**
     * uvec11 s5.
     * @member {number} s5
     * @memberof uvec11
     * @instance
     */
    uvec11.prototype.s5 = 0;

    /**
     * uvec11 s6.
     * @member {number} s6
     * @memberof uvec11
     * @instance
     */
    uvec11.prototype.s6 = 0;

    /**
     * uvec11 s7.
     * @member {number} s7
     * @memberof uvec11
     * @instance
     */
    uvec11.prototype.s7 = 0;

    /**
     * uvec11 s8.
     * @member {number} s8
     * @memberof uvec11
     * @instance
     */
    uvec11.prototype.s8 = 0;

    /**
     * uvec11 s9.
     * @member {number} s9
     * @memberof uvec11
     * @instance
     */
    uvec11.prototype.s9 = 0;

    /**
     * uvec11 sa.
     * @member {number} sa
     * @memberof uvec11
     * @instance
     */
    uvec11.prototype.sa = 0;

    /**
     * Encodes the specified uvec11 message. Does not implicitly {@link uvec11.verify|verify} messages.
     * @function encode
     * @memberof uvec11
     * @static
     * @param {Iuvec11} message uvec11 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    uvec11.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.s0);
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.s1);
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.s2);
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.s3);
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.s4);
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.s5);
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.s6);
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.s7);
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.s8);
        if (message.s9 != null && Object.hasOwnProperty.call(message, "s9"))
            writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.s9);
        if (message.sa != null && Object.hasOwnProperty.call(message, "sa"))
            writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.sa);
        return writer;
    };

    /**
     * Decodes an uvec11 message from the specified reader or buffer.
     * @function decode
     * @memberof uvec11
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {uvec11} uvec11
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    uvec11.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.uvec11();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = reader.uint32();
                break;
            case 2:
                message.s1 = reader.uint32();
                break;
            case 3:
                message.s2 = reader.uint32();
                break;
            case 4:
                message.s3 = reader.uint32();
                break;
            case 5:
                message.s4 = reader.uint32();
                break;
            case 6:
                message.s5 = reader.uint32();
                break;
            case 7:
                message.s6 = reader.uint32();
                break;
            case 8:
                message.s7 = reader.uint32();
                break;
            case 9:
                message.s8 = reader.uint32();
                break;
            case 10:
                message.s9 = reader.uint32();
                break;
            case 11:
                message.sa = reader.uint32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return uvec11;
})();

export const vec12 = $root.vec12 = (() => {

    /**
     * Properties of a vec12.
     * @exports Ivec12
     * @interface Ivec12
     * @property {number|null} [s0] vec12 s0
     * @property {number|null} [s1] vec12 s1
     * @property {number|null} [s2] vec12 s2
     * @property {number|null} [s3] vec12 s3
     * @property {number|null} [s4] vec12 s4
     * @property {number|null} [s5] vec12 s5
     * @property {number|null} [s6] vec12 s6
     * @property {number|null} [s7] vec12 s7
     * @property {number|null} [s8] vec12 s8
     * @property {number|null} [s9] vec12 s9
     * @property {number|null} [sa] vec12 sa
     * @property {number|null} [sb] vec12 sb
     */

    /**
     * Constructs a new vec12.
     * @exports vec12
     * @classdesc Represents a vec12.
     * @implements Ivec12
     * @constructor
     * @param {Ivec12=} [properties] Properties to set
     */
    function vec12(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * vec12 s0.
     * @member {number} s0
     * @memberof vec12
     * @instance
     */
    vec12.prototype.s0 = 0;

    /**
     * vec12 s1.
     * @member {number} s1
     * @memberof vec12
     * @instance
     */
    vec12.prototype.s1 = 0;

    /**
     * vec12 s2.
     * @member {number} s2
     * @memberof vec12
     * @instance
     */
    vec12.prototype.s2 = 0;

    /**
     * vec12 s3.
     * @member {number} s3
     * @memberof vec12
     * @instance
     */
    vec12.prototype.s3 = 0;

    /**
     * vec12 s4.
     * @member {number} s4
     * @memberof vec12
     * @instance
     */
    vec12.prototype.s4 = 0;

    /**
     * vec12 s5.
     * @member {number} s5
     * @memberof vec12
     * @instance
     */
    vec12.prototype.s5 = 0;

    /**
     * vec12 s6.
     * @member {number} s6
     * @memberof vec12
     * @instance
     */
    vec12.prototype.s6 = 0;

    /**
     * vec12 s7.
     * @member {number} s7
     * @memberof vec12
     * @instance
     */
    vec12.prototype.s7 = 0;

    /**
     * vec12 s8.
     * @member {number} s8
     * @memberof vec12
     * @instance
     */
    vec12.prototype.s8 = 0;

    /**
     * vec12 s9.
     * @member {number} s9
     * @memberof vec12
     * @instance
     */
    vec12.prototype.s9 = 0;

    /**
     * vec12 sa.
     * @member {number} sa
     * @memberof vec12
     * @instance
     */
    vec12.prototype.sa = 0;

    /**
     * vec12 sb.
     * @member {number} sb
     * @memberof vec12
     * @instance
     */
    vec12.prototype.sb = 0;

    /**
     * Encodes the specified vec12 message. Does not implicitly {@link vec12.verify|verify} messages.
     * @function encode
     * @memberof vec12
     * @static
     * @param {Ivec12} message vec12 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    vec12.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            writer.uint32(/* id 1, wireType 1 =*/9).double(message.s0);
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            writer.uint32(/* id 2, wireType 1 =*/17).double(message.s1);
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            writer.uint32(/* id 3, wireType 1 =*/25).double(message.s2);
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            writer.uint32(/* id 4, wireType 1 =*/33).double(message.s3);
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            writer.uint32(/* id 5, wireType 1 =*/41).double(message.s4);
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            writer.uint32(/* id 6, wireType 1 =*/49).double(message.s5);
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            writer.uint32(/* id 7, wireType 1 =*/57).double(message.s6);
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            writer.uint32(/* id 8, wireType 1 =*/65).double(message.s7);
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            writer.uint32(/* id 9, wireType 1 =*/73).double(message.s8);
        if (message.s9 != null && Object.hasOwnProperty.call(message, "s9"))
            writer.uint32(/* id 10, wireType 1 =*/81).double(message.s9);
        if (message.sa != null && Object.hasOwnProperty.call(message, "sa"))
            writer.uint32(/* id 11, wireType 1 =*/89).double(message.sa);
        if (message.sb != null && Object.hasOwnProperty.call(message, "sb"))
            writer.uint32(/* id 12, wireType 1 =*/97).double(message.sb);
        return writer;
    };

    /**
     * Decodes a vec12 message from the specified reader or buffer.
     * @function decode
     * @memberof vec12
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {vec12} vec12
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    vec12.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.vec12();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = reader.double();
                break;
            case 2:
                message.s1 = reader.double();
                break;
            case 3:
                message.s2 = reader.double();
                break;
            case 4:
                message.s3 = reader.double();
                break;
            case 5:
                message.s4 = reader.double();
                break;
            case 6:
                message.s5 = reader.double();
                break;
            case 7:
                message.s6 = reader.double();
                break;
            case 8:
                message.s7 = reader.double();
                break;
            case 9:
                message.s8 = reader.double();
                break;
            case 10:
                message.s9 = reader.double();
                break;
            case 11:
                message.sa = reader.double();
                break;
            case 12:
                message.sb = reader.double();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return vec12;
})();

export const fvec12 = $root.fvec12 = (() => {

    /**
     * Properties of a fvec12.
     * @exports Ifvec12
     * @interface Ifvec12
     * @property {number|null} [s0] fvec12 s0
     * @property {number|null} [s1] fvec12 s1
     * @property {number|null} [s2] fvec12 s2
     * @property {number|null} [s3] fvec12 s3
     * @property {number|null} [s4] fvec12 s4
     * @property {number|null} [s5] fvec12 s5
     * @property {number|null} [s6] fvec12 s6
     * @property {number|null} [s7] fvec12 s7
     * @property {number|null} [s8] fvec12 s8
     * @property {number|null} [s9] fvec12 s9
     * @property {number|null} [sa] fvec12 sa
     * @property {number|null} [sb] fvec12 sb
     */

    /**
     * Constructs a new fvec12.
     * @exports fvec12
     * @classdesc Represents a fvec12.
     * @implements Ifvec12
     * @constructor
     * @param {Ifvec12=} [properties] Properties to set
     */
    function fvec12(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * fvec12 s0.
     * @member {number} s0
     * @memberof fvec12
     * @instance
     */
    fvec12.prototype.s0 = 0;

    /**
     * fvec12 s1.
     * @member {number} s1
     * @memberof fvec12
     * @instance
     */
    fvec12.prototype.s1 = 0;

    /**
     * fvec12 s2.
     * @member {number} s2
     * @memberof fvec12
     * @instance
     */
    fvec12.prototype.s2 = 0;

    /**
     * fvec12 s3.
     * @member {number} s3
     * @memberof fvec12
     * @instance
     */
    fvec12.prototype.s3 = 0;

    /**
     * fvec12 s4.
     * @member {number} s4
     * @memberof fvec12
     * @instance
     */
    fvec12.prototype.s4 = 0;

    /**
     * fvec12 s5.
     * @member {number} s5
     * @memberof fvec12
     * @instance
     */
    fvec12.prototype.s5 = 0;

    /**
     * fvec12 s6.
     * @member {number} s6
     * @memberof fvec12
     * @instance
     */
    fvec12.prototype.s6 = 0;

    /**
     * fvec12 s7.
     * @member {number} s7
     * @memberof fvec12
     * @instance
     */
    fvec12.prototype.s7 = 0;

    /**
     * fvec12 s8.
     * @member {number} s8
     * @memberof fvec12
     * @instance
     */
    fvec12.prototype.s8 = 0;

    /**
     * fvec12 s9.
     * @member {number} s9
     * @memberof fvec12
     * @instance
     */
    fvec12.prototype.s9 = 0;

    /**
     * fvec12 sa.
     * @member {number} sa
     * @memberof fvec12
     * @instance
     */
    fvec12.prototype.sa = 0;

    /**
     * fvec12 sb.
     * @member {number} sb
     * @memberof fvec12
     * @instance
     */
    fvec12.prototype.sb = 0;

    /**
     * Encodes the specified fvec12 message. Does not implicitly {@link fvec12.verify|verify} messages.
     * @function encode
     * @memberof fvec12
     * @static
     * @param {Ifvec12} message fvec12 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    fvec12.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            writer.uint32(/* id 1, wireType 5 =*/13).float(message.s0);
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            writer.uint32(/* id 2, wireType 5 =*/21).float(message.s1);
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            writer.uint32(/* id 3, wireType 5 =*/29).float(message.s2);
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            writer.uint32(/* id 4, wireType 5 =*/37).float(message.s3);
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            writer.uint32(/* id 5, wireType 5 =*/45).float(message.s4);
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            writer.uint32(/* id 6, wireType 5 =*/53).float(message.s5);
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            writer.uint32(/* id 7, wireType 5 =*/61).float(message.s6);
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            writer.uint32(/* id 8, wireType 5 =*/69).float(message.s7);
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            writer.uint32(/* id 9, wireType 5 =*/77).float(message.s8);
        if (message.s9 != null && Object.hasOwnProperty.call(message, "s9"))
            writer.uint32(/* id 10, wireType 5 =*/85).float(message.s9);
        if (message.sa != null && Object.hasOwnProperty.call(message, "sa"))
            writer.uint32(/* id 11, wireType 5 =*/93).float(message.sa);
        if (message.sb != null && Object.hasOwnProperty.call(message, "sb"))
            writer.uint32(/* id 12, wireType 5 =*/101).float(message.sb);
        return writer;
    };

    /**
     * Decodes a fvec12 message from the specified reader or buffer.
     * @function decode
     * @memberof fvec12
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {fvec12} fvec12
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    fvec12.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.fvec12();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = reader.float();
                break;
            case 2:
                message.s1 = reader.float();
                break;
            case 3:
                message.s2 = reader.float();
                break;
            case 4:
                message.s3 = reader.float();
                break;
            case 5:
                message.s4 = reader.float();
                break;
            case 6:
                message.s5 = reader.float();
                break;
            case 7:
                message.s6 = reader.float();
                break;
            case 8:
                message.s7 = reader.float();
                break;
            case 9:
                message.s8 = reader.float();
                break;
            case 10:
                message.s9 = reader.float();
                break;
            case 11:
                message.sa = reader.float();
                break;
            case 12:
                message.sb = reader.float();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return fvec12;
})();

export const ivec12 = $root.ivec12 = (() => {

    /**
     * Properties of an ivec12.
     * @exports Iivec12
     * @interface Iivec12
     * @property {number|null} [s0] ivec12 s0
     * @property {number|null} [s1] ivec12 s1
     * @property {number|null} [s2] ivec12 s2
     * @property {number|null} [s3] ivec12 s3
     * @property {number|null} [s4] ivec12 s4
     * @property {number|null} [s5] ivec12 s5
     * @property {number|null} [s6] ivec12 s6
     * @property {number|null} [s7] ivec12 s7
     * @property {number|null} [s8] ivec12 s8
     * @property {number|null} [s9] ivec12 s9
     * @property {number|null} [sa] ivec12 sa
     * @property {number|null} [sb] ivec12 sb
     */

    /**
     * Constructs a new ivec12.
     * @exports ivec12
     * @classdesc Represents an ivec12.
     * @implements Iivec12
     * @constructor
     * @param {Iivec12=} [properties] Properties to set
     */
    function ivec12(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ivec12 s0.
     * @member {number} s0
     * @memberof ivec12
     * @instance
     */
    ivec12.prototype.s0 = 0;

    /**
     * ivec12 s1.
     * @member {number} s1
     * @memberof ivec12
     * @instance
     */
    ivec12.prototype.s1 = 0;

    /**
     * ivec12 s2.
     * @member {number} s2
     * @memberof ivec12
     * @instance
     */
    ivec12.prototype.s2 = 0;

    /**
     * ivec12 s3.
     * @member {number} s3
     * @memberof ivec12
     * @instance
     */
    ivec12.prototype.s3 = 0;

    /**
     * ivec12 s4.
     * @member {number} s4
     * @memberof ivec12
     * @instance
     */
    ivec12.prototype.s4 = 0;

    /**
     * ivec12 s5.
     * @member {number} s5
     * @memberof ivec12
     * @instance
     */
    ivec12.prototype.s5 = 0;

    /**
     * ivec12 s6.
     * @member {number} s6
     * @memberof ivec12
     * @instance
     */
    ivec12.prototype.s6 = 0;

    /**
     * ivec12 s7.
     * @member {number} s7
     * @memberof ivec12
     * @instance
     */
    ivec12.prototype.s7 = 0;

    /**
     * ivec12 s8.
     * @member {number} s8
     * @memberof ivec12
     * @instance
     */
    ivec12.prototype.s8 = 0;

    /**
     * ivec12 s9.
     * @member {number} s9
     * @memberof ivec12
     * @instance
     */
    ivec12.prototype.s9 = 0;

    /**
     * ivec12 sa.
     * @member {number} sa
     * @memberof ivec12
     * @instance
     */
    ivec12.prototype.sa = 0;

    /**
     * ivec12 sb.
     * @member {number} sb
     * @memberof ivec12
     * @instance
     */
    ivec12.prototype.sb = 0;

    /**
     * Encodes the specified ivec12 message. Does not implicitly {@link ivec12.verify|verify} messages.
     * @function encode
     * @memberof ivec12
     * @static
     * @param {Iivec12} message ivec12 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ivec12.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            writer.uint32(/* id 1, wireType 0 =*/8).sint32(message.s0);
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            writer.uint32(/* id 2, wireType 0 =*/16).sint32(message.s1);
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            writer.uint32(/* id 3, wireType 0 =*/24).sint32(message.s2);
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            writer.uint32(/* id 4, wireType 0 =*/32).sint32(message.s3);
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            writer.uint32(/* id 5, wireType 0 =*/40).sint32(message.s4);
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            writer.uint32(/* id 6, wireType 0 =*/48).sint32(message.s5);
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            writer.uint32(/* id 7, wireType 0 =*/56).sint32(message.s6);
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            writer.uint32(/* id 8, wireType 0 =*/64).sint32(message.s7);
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            writer.uint32(/* id 9, wireType 0 =*/72).sint32(message.s8);
        if (message.s9 != null && Object.hasOwnProperty.call(message, "s9"))
            writer.uint32(/* id 10, wireType 0 =*/80).sint32(message.s9);
        if (message.sa != null && Object.hasOwnProperty.call(message, "sa"))
            writer.uint32(/* id 11, wireType 0 =*/88).sint32(message.sa);
        if (message.sb != null && Object.hasOwnProperty.call(message, "sb"))
            writer.uint32(/* id 12, wireType 0 =*/96).sint32(message.sb);
        return writer;
    };

    /**
     * Decodes an ivec12 message from the specified reader or buffer.
     * @function decode
     * @memberof ivec12
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ivec12} ivec12
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ivec12.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ivec12();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = reader.sint32();
                break;
            case 2:
                message.s1 = reader.sint32();
                break;
            case 3:
                message.s2 = reader.sint32();
                break;
            case 4:
                message.s3 = reader.sint32();
                break;
            case 5:
                message.s4 = reader.sint32();
                break;
            case 6:
                message.s5 = reader.sint32();
                break;
            case 7:
                message.s6 = reader.sint32();
                break;
            case 8:
                message.s7 = reader.sint32();
                break;
            case 9:
                message.s8 = reader.sint32();
                break;
            case 10:
                message.s9 = reader.sint32();
                break;
            case 11:
                message.sa = reader.sint32();
                break;
            case 12:
                message.sb = reader.sint32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return ivec12;
})();

export const uvec12 = $root.uvec12 = (() => {

    /**
     * Properties of an uvec12.
     * @exports Iuvec12
     * @interface Iuvec12
     * @property {number|null} [s0] uvec12 s0
     * @property {number|null} [s1] uvec12 s1
     * @property {number|null} [s2] uvec12 s2
     * @property {number|null} [s3] uvec12 s3
     * @property {number|null} [s4] uvec12 s4
     * @property {number|null} [s5] uvec12 s5
     * @property {number|null} [s6] uvec12 s6
     * @property {number|null} [s7] uvec12 s7
     * @property {number|null} [s8] uvec12 s8
     * @property {number|null} [s9] uvec12 s9
     * @property {number|null} [sa] uvec12 sa
     * @property {number|null} [sb] uvec12 sb
     */

    /**
     * Constructs a new uvec12.
     * @exports uvec12
     * @classdesc Represents an uvec12.
     * @implements Iuvec12
     * @constructor
     * @param {Iuvec12=} [properties] Properties to set
     */
    function uvec12(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * uvec12 s0.
     * @member {number} s0
     * @memberof uvec12
     * @instance
     */
    uvec12.prototype.s0 = 0;

    /**
     * uvec12 s1.
     * @member {number} s1
     * @memberof uvec12
     * @instance
     */
    uvec12.prototype.s1 = 0;

    /**
     * uvec12 s2.
     * @member {number} s2
     * @memberof uvec12
     * @instance
     */
    uvec12.prototype.s2 = 0;

    /**
     * uvec12 s3.
     * @member {number} s3
     * @memberof uvec12
     * @instance
     */
    uvec12.prototype.s3 = 0;

    /**
     * uvec12 s4.
     * @member {number} s4
     * @memberof uvec12
     * @instance
     */
    uvec12.prototype.s4 = 0;

    /**
     * uvec12 s5.
     * @member {number} s5
     * @memberof uvec12
     * @instance
     */
    uvec12.prototype.s5 = 0;

    /**
     * uvec12 s6.
     * @member {number} s6
     * @memberof uvec12
     * @instance
     */
    uvec12.prototype.s6 = 0;

    /**
     * uvec12 s7.
     * @member {number} s7
     * @memberof uvec12
     * @instance
     */
    uvec12.prototype.s7 = 0;

    /**
     * uvec12 s8.
     * @member {number} s8
     * @memberof uvec12
     * @instance
     */
    uvec12.prototype.s8 = 0;

    /**
     * uvec12 s9.
     * @member {number} s9
     * @memberof uvec12
     * @instance
     */
    uvec12.prototype.s9 = 0;

    /**
     * uvec12 sa.
     * @member {number} sa
     * @memberof uvec12
     * @instance
     */
    uvec12.prototype.sa = 0;

    /**
     * uvec12 sb.
     * @member {number} sb
     * @memberof uvec12
     * @instance
     */
    uvec12.prototype.sb = 0;

    /**
     * Encodes the specified uvec12 message. Does not implicitly {@link uvec12.verify|verify} messages.
     * @function encode
     * @memberof uvec12
     * @static
     * @param {Iuvec12} message uvec12 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    uvec12.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.s0);
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.s1);
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.s2);
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.s3);
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.s4);
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.s5);
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.s6);
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.s7);
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.s8);
        if (message.s9 != null && Object.hasOwnProperty.call(message, "s9"))
            writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.s9);
        if (message.sa != null && Object.hasOwnProperty.call(message, "sa"))
            writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.sa);
        if (message.sb != null && Object.hasOwnProperty.call(message, "sb"))
            writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.sb);
        return writer;
    };

    /**
     * Decodes an uvec12 message from the specified reader or buffer.
     * @function decode
     * @memberof uvec12
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {uvec12} uvec12
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    uvec12.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.uvec12();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = reader.uint32();
                break;
            case 2:
                message.s1 = reader.uint32();
                break;
            case 3:
                message.s2 = reader.uint32();
                break;
            case 4:
                message.s3 = reader.uint32();
                break;
            case 5:
                message.s4 = reader.uint32();
                break;
            case 6:
                message.s5 = reader.uint32();
                break;
            case 7:
                message.s6 = reader.uint32();
                break;
            case 8:
                message.s7 = reader.uint32();
                break;
            case 9:
                message.s8 = reader.uint32();
                break;
            case 10:
                message.s9 = reader.uint32();
                break;
            case 11:
                message.sa = reader.uint32();
                break;
            case 12:
                message.sb = reader.uint32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return uvec12;
})();

export const vec13 = $root.vec13 = (() => {

    /**
     * Properties of a vec13.
     * @exports Ivec13
     * @interface Ivec13
     * @property {number|null} [s0] vec13 s0
     * @property {number|null} [s1] vec13 s1
     * @property {number|null} [s2] vec13 s2
     * @property {number|null} [s3] vec13 s3
     * @property {number|null} [s4] vec13 s4
     * @property {number|null} [s5] vec13 s5
     * @property {number|null} [s6] vec13 s6
     * @property {number|null} [s7] vec13 s7
     * @property {number|null} [s8] vec13 s8
     * @property {number|null} [s9] vec13 s9
     * @property {number|null} [sa] vec13 sa
     * @property {number|null} [sb] vec13 sb
     * @property {number|null} [sc] vec13 sc
     */

    /**
     * Constructs a new vec13.
     * @exports vec13
     * @classdesc Represents a vec13.
     * @implements Ivec13
     * @constructor
     * @param {Ivec13=} [properties] Properties to set
     */
    function vec13(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * vec13 s0.
     * @member {number} s0
     * @memberof vec13
     * @instance
     */
    vec13.prototype.s0 = 0;

    /**
     * vec13 s1.
     * @member {number} s1
     * @memberof vec13
     * @instance
     */
    vec13.prototype.s1 = 0;

    /**
     * vec13 s2.
     * @member {number} s2
     * @memberof vec13
     * @instance
     */
    vec13.prototype.s2 = 0;

    /**
     * vec13 s3.
     * @member {number} s3
     * @memberof vec13
     * @instance
     */
    vec13.prototype.s3 = 0;

    /**
     * vec13 s4.
     * @member {number} s4
     * @memberof vec13
     * @instance
     */
    vec13.prototype.s4 = 0;

    /**
     * vec13 s5.
     * @member {number} s5
     * @memberof vec13
     * @instance
     */
    vec13.prototype.s5 = 0;

    /**
     * vec13 s6.
     * @member {number} s6
     * @memberof vec13
     * @instance
     */
    vec13.prototype.s6 = 0;

    /**
     * vec13 s7.
     * @member {number} s7
     * @memberof vec13
     * @instance
     */
    vec13.prototype.s7 = 0;

    /**
     * vec13 s8.
     * @member {number} s8
     * @memberof vec13
     * @instance
     */
    vec13.prototype.s8 = 0;

    /**
     * vec13 s9.
     * @member {number} s9
     * @memberof vec13
     * @instance
     */
    vec13.prototype.s9 = 0;

    /**
     * vec13 sa.
     * @member {number} sa
     * @memberof vec13
     * @instance
     */
    vec13.prototype.sa = 0;

    /**
     * vec13 sb.
     * @member {number} sb
     * @memberof vec13
     * @instance
     */
    vec13.prototype.sb = 0;

    /**
     * vec13 sc.
     * @member {number} sc
     * @memberof vec13
     * @instance
     */
    vec13.prototype.sc = 0;

    /**
     * Encodes the specified vec13 message. Does not implicitly {@link vec13.verify|verify} messages.
     * @function encode
     * @memberof vec13
     * @static
     * @param {Ivec13} message vec13 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    vec13.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            writer.uint32(/* id 1, wireType 1 =*/9).double(message.s0);
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            writer.uint32(/* id 2, wireType 1 =*/17).double(message.s1);
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            writer.uint32(/* id 3, wireType 1 =*/25).double(message.s2);
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            writer.uint32(/* id 4, wireType 1 =*/33).double(message.s3);
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            writer.uint32(/* id 5, wireType 1 =*/41).double(message.s4);
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            writer.uint32(/* id 6, wireType 1 =*/49).double(message.s5);
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            writer.uint32(/* id 7, wireType 1 =*/57).double(message.s6);
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            writer.uint32(/* id 8, wireType 1 =*/65).double(message.s7);
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            writer.uint32(/* id 9, wireType 1 =*/73).double(message.s8);
        if (message.s9 != null && Object.hasOwnProperty.call(message, "s9"))
            writer.uint32(/* id 10, wireType 1 =*/81).double(message.s9);
        if (message.sa != null && Object.hasOwnProperty.call(message, "sa"))
            writer.uint32(/* id 11, wireType 1 =*/89).double(message.sa);
        if (message.sb != null && Object.hasOwnProperty.call(message, "sb"))
            writer.uint32(/* id 12, wireType 1 =*/97).double(message.sb);
        if (message.sc != null && Object.hasOwnProperty.call(message, "sc"))
            writer.uint32(/* id 13, wireType 1 =*/105).double(message.sc);
        return writer;
    };

    /**
     * Decodes a vec13 message from the specified reader or buffer.
     * @function decode
     * @memberof vec13
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {vec13} vec13
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    vec13.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.vec13();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = reader.double();
                break;
            case 2:
                message.s1 = reader.double();
                break;
            case 3:
                message.s2 = reader.double();
                break;
            case 4:
                message.s3 = reader.double();
                break;
            case 5:
                message.s4 = reader.double();
                break;
            case 6:
                message.s5 = reader.double();
                break;
            case 7:
                message.s6 = reader.double();
                break;
            case 8:
                message.s7 = reader.double();
                break;
            case 9:
                message.s8 = reader.double();
                break;
            case 10:
                message.s9 = reader.double();
                break;
            case 11:
                message.sa = reader.double();
                break;
            case 12:
                message.sb = reader.double();
                break;
            case 13:
                message.sc = reader.double();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return vec13;
})();

export const fvec13 = $root.fvec13 = (() => {

    /**
     * Properties of a fvec13.
     * @exports Ifvec13
     * @interface Ifvec13
     * @property {number|null} [s0] fvec13 s0
     * @property {number|null} [s1] fvec13 s1
     * @property {number|null} [s2] fvec13 s2
     * @property {number|null} [s3] fvec13 s3
     * @property {number|null} [s4] fvec13 s4
     * @property {number|null} [s5] fvec13 s5
     * @property {number|null} [s6] fvec13 s6
     * @property {number|null} [s7] fvec13 s7
     * @property {number|null} [s8] fvec13 s8
     * @property {number|null} [s9] fvec13 s9
     * @property {number|null} [sa] fvec13 sa
     * @property {number|null} [sb] fvec13 sb
     * @property {number|null} [sc] fvec13 sc
     */

    /**
     * Constructs a new fvec13.
     * @exports fvec13
     * @classdesc Represents a fvec13.
     * @implements Ifvec13
     * @constructor
     * @param {Ifvec13=} [properties] Properties to set
     */
    function fvec13(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * fvec13 s0.
     * @member {number} s0
     * @memberof fvec13
     * @instance
     */
    fvec13.prototype.s0 = 0;

    /**
     * fvec13 s1.
     * @member {number} s1
     * @memberof fvec13
     * @instance
     */
    fvec13.prototype.s1 = 0;

    /**
     * fvec13 s2.
     * @member {number} s2
     * @memberof fvec13
     * @instance
     */
    fvec13.prototype.s2 = 0;

    /**
     * fvec13 s3.
     * @member {number} s3
     * @memberof fvec13
     * @instance
     */
    fvec13.prototype.s3 = 0;

    /**
     * fvec13 s4.
     * @member {number} s4
     * @memberof fvec13
     * @instance
     */
    fvec13.prototype.s4 = 0;

    /**
     * fvec13 s5.
     * @member {number} s5
     * @memberof fvec13
     * @instance
     */
    fvec13.prototype.s5 = 0;

    /**
     * fvec13 s6.
     * @member {number} s6
     * @memberof fvec13
     * @instance
     */
    fvec13.prototype.s6 = 0;

    /**
     * fvec13 s7.
     * @member {number} s7
     * @memberof fvec13
     * @instance
     */
    fvec13.prototype.s7 = 0;

    /**
     * fvec13 s8.
     * @member {number} s8
     * @memberof fvec13
     * @instance
     */
    fvec13.prototype.s8 = 0;

    /**
     * fvec13 s9.
     * @member {number} s9
     * @memberof fvec13
     * @instance
     */
    fvec13.prototype.s9 = 0;

    /**
     * fvec13 sa.
     * @member {number} sa
     * @memberof fvec13
     * @instance
     */
    fvec13.prototype.sa = 0;

    /**
     * fvec13 sb.
     * @member {number} sb
     * @memberof fvec13
     * @instance
     */
    fvec13.prototype.sb = 0;

    /**
     * fvec13 sc.
     * @member {number} sc
     * @memberof fvec13
     * @instance
     */
    fvec13.prototype.sc = 0;

    /**
     * Encodes the specified fvec13 message. Does not implicitly {@link fvec13.verify|verify} messages.
     * @function encode
     * @memberof fvec13
     * @static
     * @param {Ifvec13} message fvec13 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    fvec13.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            writer.uint32(/* id 1, wireType 5 =*/13).float(message.s0);
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            writer.uint32(/* id 2, wireType 5 =*/21).float(message.s1);
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            writer.uint32(/* id 3, wireType 5 =*/29).float(message.s2);
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            writer.uint32(/* id 4, wireType 5 =*/37).float(message.s3);
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            writer.uint32(/* id 5, wireType 5 =*/45).float(message.s4);
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            writer.uint32(/* id 6, wireType 5 =*/53).float(message.s5);
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            writer.uint32(/* id 7, wireType 5 =*/61).float(message.s6);
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            writer.uint32(/* id 8, wireType 5 =*/69).float(message.s7);
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            writer.uint32(/* id 9, wireType 5 =*/77).float(message.s8);
        if (message.s9 != null && Object.hasOwnProperty.call(message, "s9"))
            writer.uint32(/* id 10, wireType 5 =*/85).float(message.s9);
        if (message.sa != null && Object.hasOwnProperty.call(message, "sa"))
            writer.uint32(/* id 11, wireType 5 =*/93).float(message.sa);
        if (message.sb != null && Object.hasOwnProperty.call(message, "sb"))
            writer.uint32(/* id 12, wireType 5 =*/101).float(message.sb);
        if (message.sc != null && Object.hasOwnProperty.call(message, "sc"))
            writer.uint32(/* id 13, wireType 5 =*/109).float(message.sc);
        return writer;
    };

    /**
     * Decodes a fvec13 message from the specified reader or buffer.
     * @function decode
     * @memberof fvec13
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {fvec13} fvec13
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    fvec13.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.fvec13();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = reader.float();
                break;
            case 2:
                message.s1 = reader.float();
                break;
            case 3:
                message.s2 = reader.float();
                break;
            case 4:
                message.s3 = reader.float();
                break;
            case 5:
                message.s4 = reader.float();
                break;
            case 6:
                message.s5 = reader.float();
                break;
            case 7:
                message.s6 = reader.float();
                break;
            case 8:
                message.s7 = reader.float();
                break;
            case 9:
                message.s8 = reader.float();
                break;
            case 10:
                message.s9 = reader.float();
                break;
            case 11:
                message.sa = reader.float();
                break;
            case 12:
                message.sb = reader.float();
                break;
            case 13:
                message.sc = reader.float();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return fvec13;
})();

export const ivec13 = $root.ivec13 = (() => {

    /**
     * Properties of an ivec13.
     * @exports Iivec13
     * @interface Iivec13
     * @property {number|null} [s0] ivec13 s0
     * @property {number|null} [s1] ivec13 s1
     * @property {number|null} [s2] ivec13 s2
     * @property {number|null} [s3] ivec13 s3
     * @property {number|null} [s4] ivec13 s4
     * @property {number|null} [s5] ivec13 s5
     * @property {number|null} [s6] ivec13 s6
     * @property {number|null} [s7] ivec13 s7
     * @property {number|null} [s8] ivec13 s8
     * @property {number|null} [s9] ivec13 s9
     * @property {number|null} [sa] ivec13 sa
     * @property {number|null} [sb] ivec13 sb
     * @property {number|null} [sc] ivec13 sc
     */

    /**
     * Constructs a new ivec13.
     * @exports ivec13
     * @classdesc Represents an ivec13.
     * @implements Iivec13
     * @constructor
     * @param {Iivec13=} [properties] Properties to set
     */
    function ivec13(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ivec13 s0.
     * @member {number} s0
     * @memberof ivec13
     * @instance
     */
    ivec13.prototype.s0 = 0;

    /**
     * ivec13 s1.
     * @member {number} s1
     * @memberof ivec13
     * @instance
     */
    ivec13.prototype.s1 = 0;

    /**
     * ivec13 s2.
     * @member {number} s2
     * @memberof ivec13
     * @instance
     */
    ivec13.prototype.s2 = 0;

    /**
     * ivec13 s3.
     * @member {number} s3
     * @memberof ivec13
     * @instance
     */
    ivec13.prototype.s3 = 0;

    /**
     * ivec13 s4.
     * @member {number} s4
     * @memberof ivec13
     * @instance
     */
    ivec13.prototype.s4 = 0;

    /**
     * ivec13 s5.
     * @member {number} s5
     * @memberof ivec13
     * @instance
     */
    ivec13.prototype.s5 = 0;

    /**
     * ivec13 s6.
     * @member {number} s6
     * @memberof ivec13
     * @instance
     */
    ivec13.prototype.s6 = 0;

    /**
     * ivec13 s7.
     * @member {number} s7
     * @memberof ivec13
     * @instance
     */
    ivec13.prototype.s7 = 0;

    /**
     * ivec13 s8.
     * @member {number} s8
     * @memberof ivec13
     * @instance
     */
    ivec13.prototype.s8 = 0;

    /**
     * ivec13 s9.
     * @member {number} s9
     * @memberof ivec13
     * @instance
     */
    ivec13.prototype.s9 = 0;

    /**
     * ivec13 sa.
     * @member {number} sa
     * @memberof ivec13
     * @instance
     */
    ivec13.prototype.sa = 0;

    /**
     * ivec13 sb.
     * @member {number} sb
     * @memberof ivec13
     * @instance
     */
    ivec13.prototype.sb = 0;

    /**
     * ivec13 sc.
     * @member {number} sc
     * @memberof ivec13
     * @instance
     */
    ivec13.prototype.sc = 0;

    /**
     * Encodes the specified ivec13 message. Does not implicitly {@link ivec13.verify|verify} messages.
     * @function encode
     * @memberof ivec13
     * @static
     * @param {Iivec13} message ivec13 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ivec13.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            writer.uint32(/* id 1, wireType 0 =*/8).sint32(message.s0);
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            writer.uint32(/* id 2, wireType 0 =*/16).sint32(message.s1);
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            writer.uint32(/* id 3, wireType 0 =*/24).sint32(message.s2);
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            writer.uint32(/* id 4, wireType 0 =*/32).sint32(message.s3);
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            writer.uint32(/* id 5, wireType 0 =*/40).sint32(message.s4);
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            writer.uint32(/* id 6, wireType 0 =*/48).sint32(message.s5);
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            writer.uint32(/* id 7, wireType 0 =*/56).sint32(message.s6);
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            writer.uint32(/* id 8, wireType 0 =*/64).sint32(message.s7);
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            writer.uint32(/* id 9, wireType 0 =*/72).sint32(message.s8);
        if (message.s9 != null && Object.hasOwnProperty.call(message, "s9"))
            writer.uint32(/* id 10, wireType 0 =*/80).sint32(message.s9);
        if (message.sa != null && Object.hasOwnProperty.call(message, "sa"))
            writer.uint32(/* id 11, wireType 0 =*/88).sint32(message.sa);
        if (message.sb != null && Object.hasOwnProperty.call(message, "sb"))
            writer.uint32(/* id 12, wireType 0 =*/96).sint32(message.sb);
        if (message.sc != null && Object.hasOwnProperty.call(message, "sc"))
            writer.uint32(/* id 13, wireType 0 =*/104).sint32(message.sc);
        return writer;
    };

    /**
     * Decodes an ivec13 message from the specified reader or buffer.
     * @function decode
     * @memberof ivec13
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ivec13} ivec13
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ivec13.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ivec13();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = reader.sint32();
                break;
            case 2:
                message.s1 = reader.sint32();
                break;
            case 3:
                message.s2 = reader.sint32();
                break;
            case 4:
                message.s3 = reader.sint32();
                break;
            case 5:
                message.s4 = reader.sint32();
                break;
            case 6:
                message.s5 = reader.sint32();
                break;
            case 7:
                message.s6 = reader.sint32();
                break;
            case 8:
                message.s7 = reader.sint32();
                break;
            case 9:
                message.s8 = reader.sint32();
                break;
            case 10:
                message.s9 = reader.sint32();
                break;
            case 11:
                message.sa = reader.sint32();
                break;
            case 12:
                message.sb = reader.sint32();
                break;
            case 13:
                message.sc = reader.sint32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return ivec13;
})();

export const uvec13 = $root.uvec13 = (() => {

    /**
     * Properties of an uvec13.
     * @exports Iuvec13
     * @interface Iuvec13
     * @property {number|null} [s0] uvec13 s0
     * @property {number|null} [s1] uvec13 s1
     * @property {number|null} [s2] uvec13 s2
     * @property {number|null} [s3] uvec13 s3
     * @property {number|null} [s4] uvec13 s4
     * @property {number|null} [s5] uvec13 s5
     * @property {number|null} [s6] uvec13 s6
     * @property {number|null} [s7] uvec13 s7
     * @property {number|null} [s8] uvec13 s8
     * @property {number|null} [s9] uvec13 s9
     * @property {number|null} [sa] uvec13 sa
     * @property {number|null} [sb] uvec13 sb
     * @property {number|null} [sc] uvec13 sc
     */

    /**
     * Constructs a new uvec13.
     * @exports uvec13
     * @classdesc Represents an uvec13.
     * @implements Iuvec13
     * @constructor
     * @param {Iuvec13=} [properties] Properties to set
     */
    function uvec13(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * uvec13 s0.
     * @member {number} s0
     * @memberof uvec13
     * @instance
     */
    uvec13.prototype.s0 = 0;

    /**
     * uvec13 s1.
     * @member {number} s1
     * @memberof uvec13
     * @instance
     */
    uvec13.prototype.s1 = 0;

    /**
     * uvec13 s2.
     * @member {number} s2
     * @memberof uvec13
     * @instance
     */
    uvec13.prototype.s2 = 0;

    /**
     * uvec13 s3.
     * @member {number} s3
     * @memberof uvec13
     * @instance
     */
    uvec13.prototype.s3 = 0;

    /**
     * uvec13 s4.
     * @member {number} s4
     * @memberof uvec13
     * @instance
     */
    uvec13.prototype.s4 = 0;

    /**
     * uvec13 s5.
     * @member {number} s5
     * @memberof uvec13
     * @instance
     */
    uvec13.prototype.s5 = 0;

    /**
     * uvec13 s6.
     * @member {number} s6
     * @memberof uvec13
     * @instance
     */
    uvec13.prototype.s6 = 0;

    /**
     * uvec13 s7.
     * @member {number} s7
     * @memberof uvec13
     * @instance
     */
    uvec13.prototype.s7 = 0;

    /**
     * uvec13 s8.
     * @member {number} s8
     * @memberof uvec13
     * @instance
     */
    uvec13.prototype.s8 = 0;

    /**
     * uvec13 s9.
     * @member {number} s9
     * @memberof uvec13
     * @instance
     */
    uvec13.prototype.s9 = 0;

    /**
     * uvec13 sa.
     * @member {number} sa
     * @memberof uvec13
     * @instance
     */
    uvec13.prototype.sa = 0;

    /**
     * uvec13 sb.
     * @member {number} sb
     * @memberof uvec13
     * @instance
     */
    uvec13.prototype.sb = 0;

    /**
     * uvec13 sc.
     * @member {number} sc
     * @memberof uvec13
     * @instance
     */
    uvec13.prototype.sc = 0;

    /**
     * Encodes the specified uvec13 message. Does not implicitly {@link uvec13.verify|verify} messages.
     * @function encode
     * @memberof uvec13
     * @static
     * @param {Iuvec13} message uvec13 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    uvec13.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.s0);
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.s1);
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.s2);
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.s3);
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.s4);
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.s5);
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.s6);
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.s7);
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.s8);
        if (message.s9 != null && Object.hasOwnProperty.call(message, "s9"))
            writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.s9);
        if (message.sa != null && Object.hasOwnProperty.call(message, "sa"))
            writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.sa);
        if (message.sb != null && Object.hasOwnProperty.call(message, "sb"))
            writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.sb);
        if (message.sc != null && Object.hasOwnProperty.call(message, "sc"))
            writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.sc);
        return writer;
    };

    /**
     * Decodes an uvec13 message from the specified reader or buffer.
     * @function decode
     * @memberof uvec13
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {uvec13} uvec13
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    uvec13.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.uvec13();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = reader.uint32();
                break;
            case 2:
                message.s1 = reader.uint32();
                break;
            case 3:
                message.s2 = reader.uint32();
                break;
            case 4:
                message.s3 = reader.uint32();
                break;
            case 5:
                message.s4 = reader.uint32();
                break;
            case 6:
                message.s5 = reader.uint32();
                break;
            case 7:
                message.s6 = reader.uint32();
                break;
            case 8:
                message.s7 = reader.uint32();
                break;
            case 9:
                message.s8 = reader.uint32();
                break;
            case 10:
                message.s9 = reader.uint32();
                break;
            case 11:
                message.sa = reader.uint32();
                break;
            case 12:
                message.sb = reader.uint32();
                break;
            case 13:
                message.sc = reader.uint32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return uvec13;
})();

export const vec14 = $root.vec14 = (() => {

    /**
     * Properties of a vec14.
     * @exports Ivec14
     * @interface Ivec14
     * @property {number|null} [s0] vec14 s0
     * @property {number|null} [s1] vec14 s1
     * @property {number|null} [s2] vec14 s2
     * @property {number|null} [s3] vec14 s3
     * @property {number|null} [s4] vec14 s4
     * @property {number|null} [s5] vec14 s5
     * @property {number|null} [s6] vec14 s6
     * @property {number|null} [s7] vec14 s7
     * @property {number|null} [s8] vec14 s8
     * @property {number|null} [s9] vec14 s9
     * @property {number|null} [sa] vec14 sa
     * @property {number|null} [sb] vec14 sb
     * @property {number|null} [sc] vec14 sc
     * @property {number|null} [sd] vec14 sd
     */

    /**
     * Constructs a new vec14.
     * @exports vec14
     * @classdesc Represents a vec14.
     * @implements Ivec14
     * @constructor
     * @param {Ivec14=} [properties] Properties to set
     */
    function vec14(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * vec14 s0.
     * @member {number} s0
     * @memberof vec14
     * @instance
     */
    vec14.prototype.s0 = 0;

    /**
     * vec14 s1.
     * @member {number} s1
     * @memberof vec14
     * @instance
     */
    vec14.prototype.s1 = 0;

    /**
     * vec14 s2.
     * @member {number} s2
     * @memberof vec14
     * @instance
     */
    vec14.prototype.s2 = 0;

    /**
     * vec14 s3.
     * @member {number} s3
     * @memberof vec14
     * @instance
     */
    vec14.prototype.s3 = 0;

    /**
     * vec14 s4.
     * @member {number} s4
     * @memberof vec14
     * @instance
     */
    vec14.prototype.s4 = 0;

    /**
     * vec14 s5.
     * @member {number} s5
     * @memberof vec14
     * @instance
     */
    vec14.prototype.s5 = 0;

    /**
     * vec14 s6.
     * @member {number} s6
     * @memberof vec14
     * @instance
     */
    vec14.prototype.s6 = 0;

    /**
     * vec14 s7.
     * @member {number} s7
     * @memberof vec14
     * @instance
     */
    vec14.prototype.s7 = 0;

    /**
     * vec14 s8.
     * @member {number} s8
     * @memberof vec14
     * @instance
     */
    vec14.prototype.s8 = 0;

    /**
     * vec14 s9.
     * @member {number} s9
     * @memberof vec14
     * @instance
     */
    vec14.prototype.s9 = 0;

    /**
     * vec14 sa.
     * @member {number} sa
     * @memberof vec14
     * @instance
     */
    vec14.prototype.sa = 0;

    /**
     * vec14 sb.
     * @member {number} sb
     * @memberof vec14
     * @instance
     */
    vec14.prototype.sb = 0;

    /**
     * vec14 sc.
     * @member {number} sc
     * @memberof vec14
     * @instance
     */
    vec14.prototype.sc = 0;

    /**
     * vec14 sd.
     * @member {number} sd
     * @memberof vec14
     * @instance
     */
    vec14.prototype.sd = 0;

    /**
     * Encodes the specified vec14 message. Does not implicitly {@link vec14.verify|verify} messages.
     * @function encode
     * @memberof vec14
     * @static
     * @param {Ivec14} message vec14 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    vec14.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            writer.uint32(/* id 1, wireType 1 =*/9).double(message.s0);
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            writer.uint32(/* id 2, wireType 1 =*/17).double(message.s1);
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            writer.uint32(/* id 3, wireType 1 =*/25).double(message.s2);
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            writer.uint32(/* id 4, wireType 1 =*/33).double(message.s3);
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            writer.uint32(/* id 5, wireType 1 =*/41).double(message.s4);
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            writer.uint32(/* id 6, wireType 1 =*/49).double(message.s5);
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            writer.uint32(/* id 7, wireType 1 =*/57).double(message.s6);
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            writer.uint32(/* id 8, wireType 1 =*/65).double(message.s7);
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            writer.uint32(/* id 9, wireType 1 =*/73).double(message.s8);
        if (message.s9 != null && Object.hasOwnProperty.call(message, "s9"))
            writer.uint32(/* id 10, wireType 1 =*/81).double(message.s9);
        if (message.sa != null && Object.hasOwnProperty.call(message, "sa"))
            writer.uint32(/* id 11, wireType 1 =*/89).double(message.sa);
        if (message.sb != null && Object.hasOwnProperty.call(message, "sb"))
            writer.uint32(/* id 12, wireType 1 =*/97).double(message.sb);
        if (message.sc != null && Object.hasOwnProperty.call(message, "sc"))
            writer.uint32(/* id 13, wireType 1 =*/105).double(message.sc);
        if (message.sd != null && Object.hasOwnProperty.call(message, "sd"))
            writer.uint32(/* id 14, wireType 1 =*/113).double(message.sd);
        return writer;
    };

    /**
     * Decodes a vec14 message from the specified reader or buffer.
     * @function decode
     * @memberof vec14
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {vec14} vec14
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    vec14.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.vec14();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = reader.double();
                break;
            case 2:
                message.s1 = reader.double();
                break;
            case 3:
                message.s2 = reader.double();
                break;
            case 4:
                message.s3 = reader.double();
                break;
            case 5:
                message.s4 = reader.double();
                break;
            case 6:
                message.s5 = reader.double();
                break;
            case 7:
                message.s6 = reader.double();
                break;
            case 8:
                message.s7 = reader.double();
                break;
            case 9:
                message.s8 = reader.double();
                break;
            case 10:
                message.s9 = reader.double();
                break;
            case 11:
                message.sa = reader.double();
                break;
            case 12:
                message.sb = reader.double();
                break;
            case 13:
                message.sc = reader.double();
                break;
            case 14:
                message.sd = reader.double();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return vec14;
})();

export const fvec14 = $root.fvec14 = (() => {

    /**
     * Properties of a fvec14.
     * @exports Ifvec14
     * @interface Ifvec14
     * @property {number|null} [s0] fvec14 s0
     * @property {number|null} [s1] fvec14 s1
     * @property {number|null} [s2] fvec14 s2
     * @property {number|null} [s3] fvec14 s3
     * @property {number|null} [s4] fvec14 s4
     * @property {number|null} [s5] fvec14 s5
     * @property {number|null} [s6] fvec14 s6
     * @property {number|null} [s7] fvec14 s7
     * @property {number|null} [s8] fvec14 s8
     * @property {number|null} [s9] fvec14 s9
     * @property {number|null} [sa] fvec14 sa
     * @property {number|null} [sb] fvec14 sb
     * @property {number|null} [sc] fvec14 sc
     * @property {number|null} [sd] fvec14 sd
     */

    /**
     * Constructs a new fvec14.
     * @exports fvec14
     * @classdesc Represents a fvec14.
     * @implements Ifvec14
     * @constructor
     * @param {Ifvec14=} [properties] Properties to set
     */
    function fvec14(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * fvec14 s0.
     * @member {number} s0
     * @memberof fvec14
     * @instance
     */
    fvec14.prototype.s0 = 0;

    /**
     * fvec14 s1.
     * @member {number} s1
     * @memberof fvec14
     * @instance
     */
    fvec14.prototype.s1 = 0;

    /**
     * fvec14 s2.
     * @member {number} s2
     * @memberof fvec14
     * @instance
     */
    fvec14.prototype.s2 = 0;

    /**
     * fvec14 s3.
     * @member {number} s3
     * @memberof fvec14
     * @instance
     */
    fvec14.prototype.s3 = 0;

    /**
     * fvec14 s4.
     * @member {number} s4
     * @memberof fvec14
     * @instance
     */
    fvec14.prototype.s4 = 0;

    /**
     * fvec14 s5.
     * @member {number} s5
     * @memberof fvec14
     * @instance
     */
    fvec14.prototype.s5 = 0;

    /**
     * fvec14 s6.
     * @member {number} s6
     * @memberof fvec14
     * @instance
     */
    fvec14.prototype.s6 = 0;

    /**
     * fvec14 s7.
     * @member {number} s7
     * @memberof fvec14
     * @instance
     */
    fvec14.prototype.s7 = 0;

    /**
     * fvec14 s8.
     * @member {number} s8
     * @memberof fvec14
     * @instance
     */
    fvec14.prototype.s8 = 0;

    /**
     * fvec14 s9.
     * @member {number} s9
     * @memberof fvec14
     * @instance
     */
    fvec14.prototype.s9 = 0;

    /**
     * fvec14 sa.
     * @member {number} sa
     * @memberof fvec14
     * @instance
     */
    fvec14.prototype.sa = 0;

    /**
     * fvec14 sb.
     * @member {number} sb
     * @memberof fvec14
     * @instance
     */
    fvec14.prototype.sb = 0;

    /**
     * fvec14 sc.
     * @member {number} sc
     * @memberof fvec14
     * @instance
     */
    fvec14.prototype.sc = 0;

    /**
     * fvec14 sd.
     * @member {number} sd
     * @memberof fvec14
     * @instance
     */
    fvec14.prototype.sd = 0;

    /**
     * Encodes the specified fvec14 message. Does not implicitly {@link fvec14.verify|verify} messages.
     * @function encode
     * @memberof fvec14
     * @static
     * @param {Ifvec14} message fvec14 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    fvec14.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            writer.uint32(/* id 1, wireType 5 =*/13).float(message.s0);
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            writer.uint32(/* id 2, wireType 5 =*/21).float(message.s1);
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            writer.uint32(/* id 3, wireType 5 =*/29).float(message.s2);
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            writer.uint32(/* id 4, wireType 5 =*/37).float(message.s3);
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            writer.uint32(/* id 5, wireType 5 =*/45).float(message.s4);
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            writer.uint32(/* id 6, wireType 5 =*/53).float(message.s5);
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            writer.uint32(/* id 7, wireType 5 =*/61).float(message.s6);
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            writer.uint32(/* id 8, wireType 5 =*/69).float(message.s7);
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            writer.uint32(/* id 9, wireType 5 =*/77).float(message.s8);
        if (message.s9 != null && Object.hasOwnProperty.call(message, "s9"))
            writer.uint32(/* id 10, wireType 5 =*/85).float(message.s9);
        if (message.sa != null && Object.hasOwnProperty.call(message, "sa"))
            writer.uint32(/* id 11, wireType 5 =*/93).float(message.sa);
        if (message.sb != null && Object.hasOwnProperty.call(message, "sb"))
            writer.uint32(/* id 12, wireType 5 =*/101).float(message.sb);
        if (message.sc != null && Object.hasOwnProperty.call(message, "sc"))
            writer.uint32(/* id 13, wireType 5 =*/109).float(message.sc);
        if (message.sd != null && Object.hasOwnProperty.call(message, "sd"))
            writer.uint32(/* id 14, wireType 5 =*/117).float(message.sd);
        return writer;
    };

    /**
     * Decodes a fvec14 message from the specified reader or buffer.
     * @function decode
     * @memberof fvec14
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {fvec14} fvec14
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    fvec14.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.fvec14();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = reader.float();
                break;
            case 2:
                message.s1 = reader.float();
                break;
            case 3:
                message.s2 = reader.float();
                break;
            case 4:
                message.s3 = reader.float();
                break;
            case 5:
                message.s4 = reader.float();
                break;
            case 6:
                message.s5 = reader.float();
                break;
            case 7:
                message.s6 = reader.float();
                break;
            case 8:
                message.s7 = reader.float();
                break;
            case 9:
                message.s8 = reader.float();
                break;
            case 10:
                message.s9 = reader.float();
                break;
            case 11:
                message.sa = reader.float();
                break;
            case 12:
                message.sb = reader.float();
                break;
            case 13:
                message.sc = reader.float();
                break;
            case 14:
                message.sd = reader.float();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return fvec14;
})();

export const ivec14 = $root.ivec14 = (() => {

    /**
     * Properties of an ivec14.
     * @exports Iivec14
     * @interface Iivec14
     * @property {number|null} [s0] ivec14 s0
     * @property {number|null} [s1] ivec14 s1
     * @property {number|null} [s2] ivec14 s2
     * @property {number|null} [s3] ivec14 s3
     * @property {number|null} [s4] ivec14 s4
     * @property {number|null} [s5] ivec14 s5
     * @property {number|null} [s6] ivec14 s6
     * @property {number|null} [s7] ivec14 s7
     * @property {number|null} [s8] ivec14 s8
     * @property {number|null} [s9] ivec14 s9
     * @property {number|null} [sa] ivec14 sa
     * @property {number|null} [sb] ivec14 sb
     * @property {number|null} [sc] ivec14 sc
     * @property {number|null} [sd] ivec14 sd
     */

    /**
     * Constructs a new ivec14.
     * @exports ivec14
     * @classdesc Represents an ivec14.
     * @implements Iivec14
     * @constructor
     * @param {Iivec14=} [properties] Properties to set
     */
    function ivec14(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ivec14 s0.
     * @member {number} s0
     * @memberof ivec14
     * @instance
     */
    ivec14.prototype.s0 = 0;

    /**
     * ivec14 s1.
     * @member {number} s1
     * @memberof ivec14
     * @instance
     */
    ivec14.prototype.s1 = 0;

    /**
     * ivec14 s2.
     * @member {number} s2
     * @memberof ivec14
     * @instance
     */
    ivec14.prototype.s2 = 0;

    /**
     * ivec14 s3.
     * @member {number} s3
     * @memberof ivec14
     * @instance
     */
    ivec14.prototype.s3 = 0;

    /**
     * ivec14 s4.
     * @member {number} s4
     * @memberof ivec14
     * @instance
     */
    ivec14.prototype.s4 = 0;

    /**
     * ivec14 s5.
     * @member {number} s5
     * @memberof ivec14
     * @instance
     */
    ivec14.prototype.s5 = 0;

    /**
     * ivec14 s6.
     * @member {number} s6
     * @memberof ivec14
     * @instance
     */
    ivec14.prototype.s6 = 0;

    /**
     * ivec14 s7.
     * @member {number} s7
     * @memberof ivec14
     * @instance
     */
    ivec14.prototype.s7 = 0;

    /**
     * ivec14 s8.
     * @member {number} s8
     * @memberof ivec14
     * @instance
     */
    ivec14.prototype.s8 = 0;

    /**
     * ivec14 s9.
     * @member {number} s9
     * @memberof ivec14
     * @instance
     */
    ivec14.prototype.s9 = 0;

    /**
     * ivec14 sa.
     * @member {number} sa
     * @memberof ivec14
     * @instance
     */
    ivec14.prototype.sa = 0;

    /**
     * ivec14 sb.
     * @member {number} sb
     * @memberof ivec14
     * @instance
     */
    ivec14.prototype.sb = 0;

    /**
     * ivec14 sc.
     * @member {number} sc
     * @memberof ivec14
     * @instance
     */
    ivec14.prototype.sc = 0;

    /**
     * ivec14 sd.
     * @member {number} sd
     * @memberof ivec14
     * @instance
     */
    ivec14.prototype.sd = 0;

    /**
     * Encodes the specified ivec14 message. Does not implicitly {@link ivec14.verify|verify} messages.
     * @function encode
     * @memberof ivec14
     * @static
     * @param {Iivec14} message ivec14 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ivec14.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            writer.uint32(/* id 1, wireType 0 =*/8).sint32(message.s0);
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            writer.uint32(/* id 2, wireType 0 =*/16).sint32(message.s1);
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            writer.uint32(/* id 3, wireType 0 =*/24).sint32(message.s2);
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            writer.uint32(/* id 4, wireType 0 =*/32).sint32(message.s3);
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            writer.uint32(/* id 5, wireType 0 =*/40).sint32(message.s4);
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            writer.uint32(/* id 6, wireType 0 =*/48).sint32(message.s5);
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            writer.uint32(/* id 7, wireType 0 =*/56).sint32(message.s6);
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            writer.uint32(/* id 8, wireType 0 =*/64).sint32(message.s7);
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            writer.uint32(/* id 9, wireType 0 =*/72).sint32(message.s8);
        if (message.s9 != null && Object.hasOwnProperty.call(message, "s9"))
            writer.uint32(/* id 10, wireType 0 =*/80).sint32(message.s9);
        if (message.sa != null && Object.hasOwnProperty.call(message, "sa"))
            writer.uint32(/* id 11, wireType 0 =*/88).sint32(message.sa);
        if (message.sb != null && Object.hasOwnProperty.call(message, "sb"))
            writer.uint32(/* id 12, wireType 0 =*/96).sint32(message.sb);
        if (message.sc != null && Object.hasOwnProperty.call(message, "sc"))
            writer.uint32(/* id 13, wireType 0 =*/104).sint32(message.sc);
        if (message.sd != null && Object.hasOwnProperty.call(message, "sd"))
            writer.uint32(/* id 14, wireType 0 =*/112).sint32(message.sd);
        return writer;
    };

    /**
     * Decodes an ivec14 message from the specified reader or buffer.
     * @function decode
     * @memberof ivec14
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ivec14} ivec14
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ivec14.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ivec14();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = reader.sint32();
                break;
            case 2:
                message.s1 = reader.sint32();
                break;
            case 3:
                message.s2 = reader.sint32();
                break;
            case 4:
                message.s3 = reader.sint32();
                break;
            case 5:
                message.s4 = reader.sint32();
                break;
            case 6:
                message.s5 = reader.sint32();
                break;
            case 7:
                message.s6 = reader.sint32();
                break;
            case 8:
                message.s7 = reader.sint32();
                break;
            case 9:
                message.s8 = reader.sint32();
                break;
            case 10:
                message.s9 = reader.sint32();
                break;
            case 11:
                message.sa = reader.sint32();
                break;
            case 12:
                message.sb = reader.sint32();
                break;
            case 13:
                message.sc = reader.sint32();
                break;
            case 14:
                message.sd = reader.sint32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return ivec14;
})();

export const uvec14 = $root.uvec14 = (() => {

    /**
     * Properties of an uvec14.
     * @exports Iuvec14
     * @interface Iuvec14
     * @property {number|null} [s0] uvec14 s0
     * @property {number|null} [s1] uvec14 s1
     * @property {number|null} [s2] uvec14 s2
     * @property {number|null} [s3] uvec14 s3
     * @property {number|null} [s4] uvec14 s4
     * @property {number|null} [s5] uvec14 s5
     * @property {number|null} [s6] uvec14 s6
     * @property {number|null} [s7] uvec14 s7
     * @property {number|null} [s8] uvec14 s8
     * @property {number|null} [s9] uvec14 s9
     * @property {number|null} [sa] uvec14 sa
     * @property {number|null} [sb] uvec14 sb
     * @property {number|null} [sc] uvec14 sc
     * @property {number|null} [sd] uvec14 sd
     */

    /**
     * Constructs a new uvec14.
     * @exports uvec14
     * @classdesc Represents an uvec14.
     * @implements Iuvec14
     * @constructor
     * @param {Iuvec14=} [properties] Properties to set
     */
    function uvec14(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * uvec14 s0.
     * @member {number} s0
     * @memberof uvec14
     * @instance
     */
    uvec14.prototype.s0 = 0;

    /**
     * uvec14 s1.
     * @member {number} s1
     * @memberof uvec14
     * @instance
     */
    uvec14.prototype.s1 = 0;

    /**
     * uvec14 s2.
     * @member {number} s2
     * @memberof uvec14
     * @instance
     */
    uvec14.prototype.s2 = 0;

    /**
     * uvec14 s3.
     * @member {number} s3
     * @memberof uvec14
     * @instance
     */
    uvec14.prototype.s3 = 0;

    /**
     * uvec14 s4.
     * @member {number} s4
     * @memberof uvec14
     * @instance
     */
    uvec14.prototype.s4 = 0;

    /**
     * uvec14 s5.
     * @member {number} s5
     * @memberof uvec14
     * @instance
     */
    uvec14.prototype.s5 = 0;

    /**
     * uvec14 s6.
     * @member {number} s6
     * @memberof uvec14
     * @instance
     */
    uvec14.prototype.s6 = 0;

    /**
     * uvec14 s7.
     * @member {number} s7
     * @memberof uvec14
     * @instance
     */
    uvec14.prototype.s7 = 0;

    /**
     * uvec14 s8.
     * @member {number} s8
     * @memberof uvec14
     * @instance
     */
    uvec14.prototype.s8 = 0;

    /**
     * uvec14 s9.
     * @member {number} s9
     * @memberof uvec14
     * @instance
     */
    uvec14.prototype.s9 = 0;

    /**
     * uvec14 sa.
     * @member {number} sa
     * @memberof uvec14
     * @instance
     */
    uvec14.prototype.sa = 0;

    /**
     * uvec14 sb.
     * @member {number} sb
     * @memberof uvec14
     * @instance
     */
    uvec14.prototype.sb = 0;

    /**
     * uvec14 sc.
     * @member {number} sc
     * @memberof uvec14
     * @instance
     */
    uvec14.prototype.sc = 0;

    /**
     * uvec14 sd.
     * @member {number} sd
     * @memberof uvec14
     * @instance
     */
    uvec14.prototype.sd = 0;

    /**
     * Encodes the specified uvec14 message. Does not implicitly {@link uvec14.verify|verify} messages.
     * @function encode
     * @memberof uvec14
     * @static
     * @param {Iuvec14} message uvec14 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    uvec14.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.s0);
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.s1);
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.s2);
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.s3);
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.s4);
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.s5);
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.s6);
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.s7);
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.s8);
        if (message.s9 != null && Object.hasOwnProperty.call(message, "s9"))
            writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.s9);
        if (message.sa != null && Object.hasOwnProperty.call(message, "sa"))
            writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.sa);
        if (message.sb != null && Object.hasOwnProperty.call(message, "sb"))
            writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.sb);
        if (message.sc != null && Object.hasOwnProperty.call(message, "sc"))
            writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.sc);
        if (message.sd != null && Object.hasOwnProperty.call(message, "sd"))
            writer.uint32(/* id 14, wireType 0 =*/112).uint32(message.sd);
        return writer;
    };

    /**
     * Decodes an uvec14 message from the specified reader or buffer.
     * @function decode
     * @memberof uvec14
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {uvec14} uvec14
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    uvec14.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.uvec14();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = reader.uint32();
                break;
            case 2:
                message.s1 = reader.uint32();
                break;
            case 3:
                message.s2 = reader.uint32();
                break;
            case 4:
                message.s3 = reader.uint32();
                break;
            case 5:
                message.s4 = reader.uint32();
                break;
            case 6:
                message.s5 = reader.uint32();
                break;
            case 7:
                message.s6 = reader.uint32();
                break;
            case 8:
                message.s7 = reader.uint32();
                break;
            case 9:
                message.s8 = reader.uint32();
                break;
            case 10:
                message.s9 = reader.uint32();
                break;
            case 11:
                message.sa = reader.uint32();
                break;
            case 12:
                message.sb = reader.uint32();
                break;
            case 13:
                message.sc = reader.uint32();
                break;
            case 14:
                message.sd = reader.uint32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return uvec14;
})();

export const vec15 = $root.vec15 = (() => {

    /**
     * Properties of a vec15.
     * @exports Ivec15
     * @interface Ivec15
     * @property {number|null} [s0] vec15 s0
     * @property {number|null} [s1] vec15 s1
     * @property {number|null} [s2] vec15 s2
     * @property {number|null} [s3] vec15 s3
     * @property {number|null} [s4] vec15 s4
     * @property {number|null} [s5] vec15 s5
     * @property {number|null} [s6] vec15 s6
     * @property {number|null} [s7] vec15 s7
     * @property {number|null} [s8] vec15 s8
     * @property {number|null} [s9] vec15 s9
     * @property {number|null} [sa] vec15 sa
     * @property {number|null} [sb] vec15 sb
     * @property {number|null} [sc] vec15 sc
     * @property {number|null} [sd] vec15 sd
     * @property {number|null} [se] vec15 se
     */

    /**
     * Constructs a new vec15.
     * @exports vec15
     * @classdesc Represents a vec15.
     * @implements Ivec15
     * @constructor
     * @param {Ivec15=} [properties] Properties to set
     */
    function vec15(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * vec15 s0.
     * @member {number} s0
     * @memberof vec15
     * @instance
     */
    vec15.prototype.s0 = 0;

    /**
     * vec15 s1.
     * @member {number} s1
     * @memberof vec15
     * @instance
     */
    vec15.prototype.s1 = 0;

    /**
     * vec15 s2.
     * @member {number} s2
     * @memberof vec15
     * @instance
     */
    vec15.prototype.s2 = 0;

    /**
     * vec15 s3.
     * @member {number} s3
     * @memberof vec15
     * @instance
     */
    vec15.prototype.s3 = 0;

    /**
     * vec15 s4.
     * @member {number} s4
     * @memberof vec15
     * @instance
     */
    vec15.prototype.s4 = 0;

    /**
     * vec15 s5.
     * @member {number} s5
     * @memberof vec15
     * @instance
     */
    vec15.prototype.s5 = 0;

    /**
     * vec15 s6.
     * @member {number} s6
     * @memberof vec15
     * @instance
     */
    vec15.prototype.s6 = 0;

    /**
     * vec15 s7.
     * @member {number} s7
     * @memberof vec15
     * @instance
     */
    vec15.prototype.s7 = 0;

    /**
     * vec15 s8.
     * @member {number} s8
     * @memberof vec15
     * @instance
     */
    vec15.prototype.s8 = 0;

    /**
     * vec15 s9.
     * @member {number} s9
     * @memberof vec15
     * @instance
     */
    vec15.prototype.s9 = 0;

    /**
     * vec15 sa.
     * @member {number} sa
     * @memberof vec15
     * @instance
     */
    vec15.prototype.sa = 0;

    /**
     * vec15 sb.
     * @member {number} sb
     * @memberof vec15
     * @instance
     */
    vec15.prototype.sb = 0;

    /**
     * vec15 sc.
     * @member {number} sc
     * @memberof vec15
     * @instance
     */
    vec15.prototype.sc = 0;

    /**
     * vec15 sd.
     * @member {number} sd
     * @memberof vec15
     * @instance
     */
    vec15.prototype.sd = 0;

    /**
     * vec15 se.
     * @member {number} se
     * @memberof vec15
     * @instance
     */
    vec15.prototype.se = 0;

    /**
     * Encodes the specified vec15 message. Does not implicitly {@link vec15.verify|verify} messages.
     * @function encode
     * @memberof vec15
     * @static
     * @param {Ivec15} message vec15 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    vec15.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            writer.uint32(/* id 1, wireType 1 =*/9).double(message.s0);
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            writer.uint32(/* id 2, wireType 1 =*/17).double(message.s1);
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            writer.uint32(/* id 3, wireType 1 =*/25).double(message.s2);
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            writer.uint32(/* id 4, wireType 1 =*/33).double(message.s3);
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            writer.uint32(/* id 5, wireType 1 =*/41).double(message.s4);
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            writer.uint32(/* id 6, wireType 1 =*/49).double(message.s5);
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            writer.uint32(/* id 7, wireType 1 =*/57).double(message.s6);
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            writer.uint32(/* id 8, wireType 1 =*/65).double(message.s7);
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            writer.uint32(/* id 9, wireType 1 =*/73).double(message.s8);
        if (message.s9 != null && Object.hasOwnProperty.call(message, "s9"))
            writer.uint32(/* id 10, wireType 1 =*/81).double(message.s9);
        if (message.sa != null && Object.hasOwnProperty.call(message, "sa"))
            writer.uint32(/* id 11, wireType 1 =*/89).double(message.sa);
        if (message.sb != null && Object.hasOwnProperty.call(message, "sb"))
            writer.uint32(/* id 12, wireType 1 =*/97).double(message.sb);
        if (message.sc != null && Object.hasOwnProperty.call(message, "sc"))
            writer.uint32(/* id 13, wireType 1 =*/105).double(message.sc);
        if (message.sd != null && Object.hasOwnProperty.call(message, "sd"))
            writer.uint32(/* id 14, wireType 1 =*/113).double(message.sd);
        if (message.se != null && Object.hasOwnProperty.call(message, "se"))
            writer.uint32(/* id 15, wireType 1 =*/121).double(message.se);
        return writer;
    };

    /**
     * Decodes a vec15 message from the specified reader or buffer.
     * @function decode
     * @memberof vec15
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {vec15} vec15
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    vec15.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.vec15();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = reader.double();
                break;
            case 2:
                message.s1 = reader.double();
                break;
            case 3:
                message.s2 = reader.double();
                break;
            case 4:
                message.s3 = reader.double();
                break;
            case 5:
                message.s4 = reader.double();
                break;
            case 6:
                message.s5 = reader.double();
                break;
            case 7:
                message.s6 = reader.double();
                break;
            case 8:
                message.s7 = reader.double();
                break;
            case 9:
                message.s8 = reader.double();
                break;
            case 10:
                message.s9 = reader.double();
                break;
            case 11:
                message.sa = reader.double();
                break;
            case 12:
                message.sb = reader.double();
                break;
            case 13:
                message.sc = reader.double();
                break;
            case 14:
                message.sd = reader.double();
                break;
            case 15:
                message.se = reader.double();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return vec15;
})();

export const fvec15 = $root.fvec15 = (() => {

    /**
     * Properties of a fvec15.
     * @exports Ifvec15
     * @interface Ifvec15
     * @property {number|null} [s0] fvec15 s0
     * @property {number|null} [s1] fvec15 s1
     * @property {number|null} [s2] fvec15 s2
     * @property {number|null} [s3] fvec15 s3
     * @property {number|null} [s4] fvec15 s4
     * @property {number|null} [s5] fvec15 s5
     * @property {number|null} [s6] fvec15 s6
     * @property {number|null} [s7] fvec15 s7
     * @property {number|null} [s8] fvec15 s8
     * @property {number|null} [s9] fvec15 s9
     * @property {number|null} [sa] fvec15 sa
     * @property {number|null} [sb] fvec15 sb
     * @property {number|null} [sc] fvec15 sc
     * @property {number|null} [sd] fvec15 sd
     * @property {number|null} [se] fvec15 se
     */

    /**
     * Constructs a new fvec15.
     * @exports fvec15
     * @classdesc Represents a fvec15.
     * @implements Ifvec15
     * @constructor
     * @param {Ifvec15=} [properties] Properties to set
     */
    function fvec15(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * fvec15 s0.
     * @member {number} s0
     * @memberof fvec15
     * @instance
     */
    fvec15.prototype.s0 = 0;

    /**
     * fvec15 s1.
     * @member {number} s1
     * @memberof fvec15
     * @instance
     */
    fvec15.prototype.s1 = 0;

    /**
     * fvec15 s2.
     * @member {number} s2
     * @memberof fvec15
     * @instance
     */
    fvec15.prototype.s2 = 0;

    /**
     * fvec15 s3.
     * @member {number} s3
     * @memberof fvec15
     * @instance
     */
    fvec15.prototype.s3 = 0;

    /**
     * fvec15 s4.
     * @member {number} s4
     * @memberof fvec15
     * @instance
     */
    fvec15.prototype.s4 = 0;

    /**
     * fvec15 s5.
     * @member {number} s5
     * @memberof fvec15
     * @instance
     */
    fvec15.prototype.s5 = 0;

    /**
     * fvec15 s6.
     * @member {number} s6
     * @memberof fvec15
     * @instance
     */
    fvec15.prototype.s6 = 0;

    /**
     * fvec15 s7.
     * @member {number} s7
     * @memberof fvec15
     * @instance
     */
    fvec15.prototype.s7 = 0;

    /**
     * fvec15 s8.
     * @member {number} s8
     * @memberof fvec15
     * @instance
     */
    fvec15.prototype.s8 = 0;

    /**
     * fvec15 s9.
     * @member {number} s9
     * @memberof fvec15
     * @instance
     */
    fvec15.prototype.s9 = 0;

    /**
     * fvec15 sa.
     * @member {number} sa
     * @memberof fvec15
     * @instance
     */
    fvec15.prototype.sa = 0;

    /**
     * fvec15 sb.
     * @member {number} sb
     * @memberof fvec15
     * @instance
     */
    fvec15.prototype.sb = 0;

    /**
     * fvec15 sc.
     * @member {number} sc
     * @memberof fvec15
     * @instance
     */
    fvec15.prototype.sc = 0;

    /**
     * fvec15 sd.
     * @member {number} sd
     * @memberof fvec15
     * @instance
     */
    fvec15.prototype.sd = 0;

    /**
     * fvec15 se.
     * @member {number} se
     * @memberof fvec15
     * @instance
     */
    fvec15.prototype.se = 0;

    /**
     * Encodes the specified fvec15 message. Does not implicitly {@link fvec15.verify|verify} messages.
     * @function encode
     * @memberof fvec15
     * @static
     * @param {Ifvec15} message fvec15 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    fvec15.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            writer.uint32(/* id 1, wireType 5 =*/13).float(message.s0);
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            writer.uint32(/* id 2, wireType 5 =*/21).float(message.s1);
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            writer.uint32(/* id 3, wireType 5 =*/29).float(message.s2);
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            writer.uint32(/* id 4, wireType 5 =*/37).float(message.s3);
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            writer.uint32(/* id 5, wireType 5 =*/45).float(message.s4);
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            writer.uint32(/* id 6, wireType 5 =*/53).float(message.s5);
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            writer.uint32(/* id 7, wireType 5 =*/61).float(message.s6);
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            writer.uint32(/* id 8, wireType 5 =*/69).float(message.s7);
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            writer.uint32(/* id 9, wireType 5 =*/77).float(message.s8);
        if (message.s9 != null && Object.hasOwnProperty.call(message, "s9"))
            writer.uint32(/* id 10, wireType 5 =*/85).float(message.s9);
        if (message.sa != null && Object.hasOwnProperty.call(message, "sa"))
            writer.uint32(/* id 11, wireType 5 =*/93).float(message.sa);
        if (message.sb != null && Object.hasOwnProperty.call(message, "sb"))
            writer.uint32(/* id 12, wireType 5 =*/101).float(message.sb);
        if (message.sc != null && Object.hasOwnProperty.call(message, "sc"))
            writer.uint32(/* id 13, wireType 5 =*/109).float(message.sc);
        if (message.sd != null && Object.hasOwnProperty.call(message, "sd"))
            writer.uint32(/* id 14, wireType 5 =*/117).float(message.sd);
        if (message.se != null && Object.hasOwnProperty.call(message, "se"))
            writer.uint32(/* id 15, wireType 5 =*/125).float(message.se);
        return writer;
    };

    /**
     * Decodes a fvec15 message from the specified reader or buffer.
     * @function decode
     * @memberof fvec15
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {fvec15} fvec15
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    fvec15.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.fvec15();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = reader.float();
                break;
            case 2:
                message.s1 = reader.float();
                break;
            case 3:
                message.s2 = reader.float();
                break;
            case 4:
                message.s3 = reader.float();
                break;
            case 5:
                message.s4 = reader.float();
                break;
            case 6:
                message.s5 = reader.float();
                break;
            case 7:
                message.s6 = reader.float();
                break;
            case 8:
                message.s7 = reader.float();
                break;
            case 9:
                message.s8 = reader.float();
                break;
            case 10:
                message.s9 = reader.float();
                break;
            case 11:
                message.sa = reader.float();
                break;
            case 12:
                message.sb = reader.float();
                break;
            case 13:
                message.sc = reader.float();
                break;
            case 14:
                message.sd = reader.float();
                break;
            case 15:
                message.se = reader.float();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return fvec15;
})();

export const ivec15 = $root.ivec15 = (() => {

    /**
     * Properties of an ivec15.
     * @exports Iivec15
     * @interface Iivec15
     * @property {number|null} [s0] ivec15 s0
     * @property {number|null} [s1] ivec15 s1
     * @property {number|null} [s2] ivec15 s2
     * @property {number|null} [s3] ivec15 s3
     * @property {number|null} [s4] ivec15 s4
     * @property {number|null} [s5] ivec15 s5
     * @property {number|null} [s6] ivec15 s6
     * @property {number|null} [s7] ivec15 s7
     * @property {number|null} [s8] ivec15 s8
     * @property {number|null} [s9] ivec15 s9
     * @property {number|null} [sa] ivec15 sa
     * @property {number|null} [sb] ivec15 sb
     * @property {number|null} [sc] ivec15 sc
     * @property {number|null} [sd] ivec15 sd
     * @property {number|null} [se] ivec15 se
     */

    /**
     * Constructs a new ivec15.
     * @exports ivec15
     * @classdesc Represents an ivec15.
     * @implements Iivec15
     * @constructor
     * @param {Iivec15=} [properties] Properties to set
     */
    function ivec15(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ivec15 s0.
     * @member {number} s0
     * @memberof ivec15
     * @instance
     */
    ivec15.prototype.s0 = 0;

    /**
     * ivec15 s1.
     * @member {number} s1
     * @memberof ivec15
     * @instance
     */
    ivec15.prototype.s1 = 0;

    /**
     * ivec15 s2.
     * @member {number} s2
     * @memberof ivec15
     * @instance
     */
    ivec15.prototype.s2 = 0;

    /**
     * ivec15 s3.
     * @member {number} s3
     * @memberof ivec15
     * @instance
     */
    ivec15.prototype.s3 = 0;

    /**
     * ivec15 s4.
     * @member {number} s4
     * @memberof ivec15
     * @instance
     */
    ivec15.prototype.s4 = 0;

    /**
     * ivec15 s5.
     * @member {number} s5
     * @memberof ivec15
     * @instance
     */
    ivec15.prototype.s5 = 0;

    /**
     * ivec15 s6.
     * @member {number} s6
     * @memberof ivec15
     * @instance
     */
    ivec15.prototype.s6 = 0;

    /**
     * ivec15 s7.
     * @member {number} s7
     * @memberof ivec15
     * @instance
     */
    ivec15.prototype.s7 = 0;

    /**
     * ivec15 s8.
     * @member {number} s8
     * @memberof ivec15
     * @instance
     */
    ivec15.prototype.s8 = 0;

    /**
     * ivec15 s9.
     * @member {number} s9
     * @memberof ivec15
     * @instance
     */
    ivec15.prototype.s9 = 0;

    /**
     * ivec15 sa.
     * @member {number} sa
     * @memberof ivec15
     * @instance
     */
    ivec15.prototype.sa = 0;

    /**
     * ivec15 sb.
     * @member {number} sb
     * @memberof ivec15
     * @instance
     */
    ivec15.prototype.sb = 0;

    /**
     * ivec15 sc.
     * @member {number} sc
     * @memberof ivec15
     * @instance
     */
    ivec15.prototype.sc = 0;

    /**
     * ivec15 sd.
     * @member {number} sd
     * @memberof ivec15
     * @instance
     */
    ivec15.prototype.sd = 0;

    /**
     * ivec15 se.
     * @member {number} se
     * @memberof ivec15
     * @instance
     */
    ivec15.prototype.se = 0;

    /**
     * Encodes the specified ivec15 message. Does not implicitly {@link ivec15.verify|verify} messages.
     * @function encode
     * @memberof ivec15
     * @static
     * @param {Iivec15} message ivec15 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ivec15.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            writer.uint32(/* id 1, wireType 0 =*/8).sint32(message.s0);
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            writer.uint32(/* id 2, wireType 0 =*/16).sint32(message.s1);
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            writer.uint32(/* id 3, wireType 0 =*/24).sint32(message.s2);
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            writer.uint32(/* id 4, wireType 0 =*/32).sint32(message.s3);
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            writer.uint32(/* id 5, wireType 0 =*/40).sint32(message.s4);
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            writer.uint32(/* id 6, wireType 0 =*/48).sint32(message.s5);
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            writer.uint32(/* id 7, wireType 0 =*/56).sint32(message.s6);
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            writer.uint32(/* id 8, wireType 0 =*/64).sint32(message.s7);
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            writer.uint32(/* id 9, wireType 0 =*/72).sint32(message.s8);
        if (message.s9 != null && Object.hasOwnProperty.call(message, "s9"))
            writer.uint32(/* id 10, wireType 0 =*/80).sint32(message.s9);
        if (message.sa != null && Object.hasOwnProperty.call(message, "sa"))
            writer.uint32(/* id 11, wireType 0 =*/88).sint32(message.sa);
        if (message.sb != null && Object.hasOwnProperty.call(message, "sb"))
            writer.uint32(/* id 12, wireType 0 =*/96).sint32(message.sb);
        if (message.sc != null && Object.hasOwnProperty.call(message, "sc"))
            writer.uint32(/* id 13, wireType 0 =*/104).sint32(message.sc);
        if (message.sd != null && Object.hasOwnProperty.call(message, "sd"))
            writer.uint32(/* id 14, wireType 0 =*/112).sint32(message.sd);
        if (message.se != null && Object.hasOwnProperty.call(message, "se"))
            writer.uint32(/* id 15, wireType 0 =*/120).sint32(message.se);
        return writer;
    };

    /**
     * Decodes an ivec15 message from the specified reader or buffer.
     * @function decode
     * @memberof ivec15
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ivec15} ivec15
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ivec15.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ivec15();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = reader.sint32();
                break;
            case 2:
                message.s1 = reader.sint32();
                break;
            case 3:
                message.s2 = reader.sint32();
                break;
            case 4:
                message.s3 = reader.sint32();
                break;
            case 5:
                message.s4 = reader.sint32();
                break;
            case 6:
                message.s5 = reader.sint32();
                break;
            case 7:
                message.s6 = reader.sint32();
                break;
            case 8:
                message.s7 = reader.sint32();
                break;
            case 9:
                message.s8 = reader.sint32();
                break;
            case 10:
                message.s9 = reader.sint32();
                break;
            case 11:
                message.sa = reader.sint32();
                break;
            case 12:
                message.sb = reader.sint32();
                break;
            case 13:
                message.sc = reader.sint32();
                break;
            case 14:
                message.sd = reader.sint32();
                break;
            case 15:
                message.se = reader.sint32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return ivec15;
})();

export const uvec15 = $root.uvec15 = (() => {

    /**
     * Properties of an uvec15.
     * @exports Iuvec15
     * @interface Iuvec15
     * @property {number|null} [s0] uvec15 s0
     * @property {number|null} [s1] uvec15 s1
     * @property {number|null} [s2] uvec15 s2
     * @property {number|null} [s3] uvec15 s3
     * @property {number|null} [s4] uvec15 s4
     * @property {number|null} [s5] uvec15 s5
     * @property {number|null} [s6] uvec15 s6
     * @property {number|null} [s7] uvec15 s7
     * @property {number|null} [s8] uvec15 s8
     * @property {number|null} [s9] uvec15 s9
     * @property {number|null} [sa] uvec15 sa
     * @property {number|null} [sb] uvec15 sb
     * @property {number|null} [sc] uvec15 sc
     * @property {number|null} [sd] uvec15 sd
     * @property {number|null} [se] uvec15 se
     */

    /**
     * Constructs a new uvec15.
     * @exports uvec15
     * @classdesc Represents an uvec15.
     * @implements Iuvec15
     * @constructor
     * @param {Iuvec15=} [properties] Properties to set
     */
    function uvec15(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * uvec15 s0.
     * @member {number} s0
     * @memberof uvec15
     * @instance
     */
    uvec15.prototype.s0 = 0;

    /**
     * uvec15 s1.
     * @member {number} s1
     * @memberof uvec15
     * @instance
     */
    uvec15.prototype.s1 = 0;

    /**
     * uvec15 s2.
     * @member {number} s2
     * @memberof uvec15
     * @instance
     */
    uvec15.prototype.s2 = 0;

    /**
     * uvec15 s3.
     * @member {number} s3
     * @memberof uvec15
     * @instance
     */
    uvec15.prototype.s3 = 0;

    /**
     * uvec15 s4.
     * @member {number} s4
     * @memberof uvec15
     * @instance
     */
    uvec15.prototype.s4 = 0;

    /**
     * uvec15 s5.
     * @member {number} s5
     * @memberof uvec15
     * @instance
     */
    uvec15.prototype.s5 = 0;

    /**
     * uvec15 s6.
     * @member {number} s6
     * @memberof uvec15
     * @instance
     */
    uvec15.prototype.s6 = 0;

    /**
     * uvec15 s7.
     * @member {number} s7
     * @memberof uvec15
     * @instance
     */
    uvec15.prototype.s7 = 0;

    /**
     * uvec15 s8.
     * @member {number} s8
     * @memberof uvec15
     * @instance
     */
    uvec15.prototype.s8 = 0;

    /**
     * uvec15 s9.
     * @member {number} s9
     * @memberof uvec15
     * @instance
     */
    uvec15.prototype.s9 = 0;

    /**
     * uvec15 sa.
     * @member {number} sa
     * @memberof uvec15
     * @instance
     */
    uvec15.prototype.sa = 0;

    /**
     * uvec15 sb.
     * @member {number} sb
     * @memberof uvec15
     * @instance
     */
    uvec15.prototype.sb = 0;

    /**
     * uvec15 sc.
     * @member {number} sc
     * @memberof uvec15
     * @instance
     */
    uvec15.prototype.sc = 0;

    /**
     * uvec15 sd.
     * @member {number} sd
     * @memberof uvec15
     * @instance
     */
    uvec15.prototype.sd = 0;

    /**
     * uvec15 se.
     * @member {number} se
     * @memberof uvec15
     * @instance
     */
    uvec15.prototype.se = 0;

    /**
     * Encodes the specified uvec15 message. Does not implicitly {@link uvec15.verify|verify} messages.
     * @function encode
     * @memberof uvec15
     * @static
     * @param {Iuvec15} message uvec15 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    uvec15.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.s0);
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.s1);
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.s2);
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.s3);
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.s4);
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.s5);
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.s6);
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.s7);
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.s8);
        if (message.s9 != null && Object.hasOwnProperty.call(message, "s9"))
            writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.s9);
        if (message.sa != null && Object.hasOwnProperty.call(message, "sa"))
            writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.sa);
        if (message.sb != null && Object.hasOwnProperty.call(message, "sb"))
            writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.sb);
        if (message.sc != null && Object.hasOwnProperty.call(message, "sc"))
            writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.sc);
        if (message.sd != null && Object.hasOwnProperty.call(message, "sd"))
            writer.uint32(/* id 14, wireType 0 =*/112).uint32(message.sd);
        if (message.se != null && Object.hasOwnProperty.call(message, "se"))
            writer.uint32(/* id 15, wireType 0 =*/120).uint32(message.se);
        return writer;
    };

    /**
     * Decodes an uvec15 message from the specified reader or buffer.
     * @function decode
     * @memberof uvec15
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {uvec15} uvec15
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    uvec15.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.uvec15();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = reader.uint32();
                break;
            case 2:
                message.s1 = reader.uint32();
                break;
            case 3:
                message.s2 = reader.uint32();
                break;
            case 4:
                message.s3 = reader.uint32();
                break;
            case 5:
                message.s4 = reader.uint32();
                break;
            case 6:
                message.s5 = reader.uint32();
                break;
            case 7:
                message.s6 = reader.uint32();
                break;
            case 8:
                message.s7 = reader.uint32();
                break;
            case 9:
                message.s8 = reader.uint32();
                break;
            case 10:
                message.s9 = reader.uint32();
                break;
            case 11:
                message.sa = reader.uint32();
                break;
            case 12:
                message.sb = reader.uint32();
                break;
            case 13:
                message.sc = reader.uint32();
                break;
            case 14:
                message.sd = reader.uint32();
                break;
            case 15:
                message.se = reader.uint32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return uvec15;
})();

export const vec16 = $root.vec16 = (() => {

    /**
     * Properties of a vec16.
     * @exports Ivec16
     * @interface Ivec16
     * @property {number|null} [s0] vec16 s0
     * @property {number|null} [s1] vec16 s1
     * @property {number|null} [s2] vec16 s2
     * @property {number|null} [s3] vec16 s3
     * @property {number|null} [s4] vec16 s4
     * @property {number|null} [s5] vec16 s5
     * @property {number|null} [s6] vec16 s6
     * @property {number|null} [s7] vec16 s7
     * @property {number|null} [s8] vec16 s8
     * @property {number|null} [s9] vec16 s9
     * @property {number|null} [sa] vec16 sa
     * @property {number|null} [sb] vec16 sb
     * @property {number|null} [sc] vec16 sc
     * @property {number|null} [sd] vec16 sd
     * @property {number|null} [se] vec16 se
     * @property {number|null} [sf] vec16 sf
     */

    /**
     * Constructs a new vec16.
     * @exports vec16
     * @classdesc Represents a vec16.
     * @implements Ivec16
     * @constructor
     * @param {Ivec16=} [properties] Properties to set
     */
    function vec16(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * vec16 s0.
     * @member {number} s0
     * @memberof vec16
     * @instance
     */
    vec16.prototype.s0 = 0;

    /**
     * vec16 s1.
     * @member {number} s1
     * @memberof vec16
     * @instance
     */
    vec16.prototype.s1 = 0;

    /**
     * vec16 s2.
     * @member {number} s2
     * @memberof vec16
     * @instance
     */
    vec16.prototype.s2 = 0;

    /**
     * vec16 s3.
     * @member {number} s3
     * @memberof vec16
     * @instance
     */
    vec16.prototype.s3 = 0;

    /**
     * vec16 s4.
     * @member {number} s4
     * @memberof vec16
     * @instance
     */
    vec16.prototype.s4 = 0;

    /**
     * vec16 s5.
     * @member {number} s5
     * @memberof vec16
     * @instance
     */
    vec16.prototype.s5 = 0;

    /**
     * vec16 s6.
     * @member {number} s6
     * @memberof vec16
     * @instance
     */
    vec16.prototype.s6 = 0;

    /**
     * vec16 s7.
     * @member {number} s7
     * @memberof vec16
     * @instance
     */
    vec16.prototype.s7 = 0;

    /**
     * vec16 s8.
     * @member {number} s8
     * @memberof vec16
     * @instance
     */
    vec16.prototype.s8 = 0;

    /**
     * vec16 s9.
     * @member {number} s9
     * @memberof vec16
     * @instance
     */
    vec16.prototype.s9 = 0;

    /**
     * vec16 sa.
     * @member {number} sa
     * @memberof vec16
     * @instance
     */
    vec16.prototype.sa = 0;

    /**
     * vec16 sb.
     * @member {number} sb
     * @memberof vec16
     * @instance
     */
    vec16.prototype.sb = 0;

    /**
     * vec16 sc.
     * @member {number} sc
     * @memberof vec16
     * @instance
     */
    vec16.prototype.sc = 0;

    /**
     * vec16 sd.
     * @member {number} sd
     * @memberof vec16
     * @instance
     */
    vec16.prototype.sd = 0;

    /**
     * vec16 se.
     * @member {number} se
     * @memberof vec16
     * @instance
     */
    vec16.prototype.se = 0;

    /**
     * vec16 sf.
     * @member {number} sf
     * @memberof vec16
     * @instance
     */
    vec16.prototype.sf = 0;

    /**
     * Encodes the specified vec16 message. Does not implicitly {@link vec16.verify|verify} messages.
     * @function encode
     * @memberof vec16
     * @static
     * @param {Ivec16} message vec16 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    vec16.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            writer.uint32(/* id 1, wireType 1 =*/9).double(message.s0);
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            writer.uint32(/* id 2, wireType 1 =*/17).double(message.s1);
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            writer.uint32(/* id 3, wireType 1 =*/25).double(message.s2);
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            writer.uint32(/* id 4, wireType 1 =*/33).double(message.s3);
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            writer.uint32(/* id 5, wireType 1 =*/41).double(message.s4);
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            writer.uint32(/* id 6, wireType 1 =*/49).double(message.s5);
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            writer.uint32(/* id 7, wireType 1 =*/57).double(message.s6);
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            writer.uint32(/* id 8, wireType 1 =*/65).double(message.s7);
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            writer.uint32(/* id 9, wireType 1 =*/73).double(message.s8);
        if (message.s9 != null && Object.hasOwnProperty.call(message, "s9"))
            writer.uint32(/* id 10, wireType 1 =*/81).double(message.s9);
        if (message.sa != null && Object.hasOwnProperty.call(message, "sa"))
            writer.uint32(/* id 11, wireType 1 =*/89).double(message.sa);
        if (message.sb != null && Object.hasOwnProperty.call(message, "sb"))
            writer.uint32(/* id 12, wireType 1 =*/97).double(message.sb);
        if (message.sc != null && Object.hasOwnProperty.call(message, "sc"))
            writer.uint32(/* id 13, wireType 1 =*/105).double(message.sc);
        if (message.sd != null && Object.hasOwnProperty.call(message, "sd"))
            writer.uint32(/* id 14, wireType 1 =*/113).double(message.sd);
        if (message.se != null && Object.hasOwnProperty.call(message, "se"))
            writer.uint32(/* id 15, wireType 1 =*/121).double(message.se);
        if (message.sf != null && Object.hasOwnProperty.call(message, "sf"))
            writer.uint32(/* id 16, wireType 1 =*/129).double(message.sf);
        return writer;
    };

    /**
     * Decodes a vec16 message from the specified reader or buffer.
     * @function decode
     * @memberof vec16
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {vec16} vec16
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    vec16.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.vec16();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = reader.double();
                break;
            case 2:
                message.s1 = reader.double();
                break;
            case 3:
                message.s2 = reader.double();
                break;
            case 4:
                message.s3 = reader.double();
                break;
            case 5:
                message.s4 = reader.double();
                break;
            case 6:
                message.s5 = reader.double();
                break;
            case 7:
                message.s6 = reader.double();
                break;
            case 8:
                message.s7 = reader.double();
                break;
            case 9:
                message.s8 = reader.double();
                break;
            case 10:
                message.s9 = reader.double();
                break;
            case 11:
                message.sa = reader.double();
                break;
            case 12:
                message.sb = reader.double();
                break;
            case 13:
                message.sc = reader.double();
                break;
            case 14:
                message.sd = reader.double();
                break;
            case 15:
                message.se = reader.double();
                break;
            case 16:
                message.sf = reader.double();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return vec16;
})();

export const fvec16 = $root.fvec16 = (() => {

    /**
     * Properties of a fvec16.
     * @exports Ifvec16
     * @interface Ifvec16
     * @property {number|null} [s0] fvec16 s0
     * @property {number|null} [s1] fvec16 s1
     * @property {number|null} [s2] fvec16 s2
     * @property {number|null} [s3] fvec16 s3
     * @property {number|null} [s4] fvec16 s4
     * @property {number|null} [s5] fvec16 s5
     * @property {number|null} [s6] fvec16 s6
     * @property {number|null} [s7] fvec16 s7
     * @property {number|null} [s8] fvec16 s8
     * @property {number|null} [s9] fvec16 s9
     * @property {number|null} [sa] fvec16 sa
     * @property {number|null} [sb] fvec16 sb
     * @property {number|null} [sc] fvec16 sc
     * @property {number|null} [sd] fvec16 sd
     * @property {number|null} [se] fvec16 se
     * @property {number|null} [sf] fvec16 sf
     */

    /**
     * Constructs a new fvec16.
     * @exports fvec16
     * @classdesc Represents a fvec16.
     * @implements Ifvec16
     * @constructor
     * @param {Ifvec16=} [properties] Properties to set
     */
    function fvec16(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * fvec16 s0.
     * @member {number} s0
     * @memberof fvec16
     * @instance
     */
    fvec16.prototype.s0 = 0;

    /**
     * fvec16 s1.
     * @member {number} s1
     * @memberof fvec16
     * @instance
     */
    fvec16.prototype.s1 = 0;

    /**
     * fvec16 s2.
     * @member {number} s2
     * @memberof fvec16
     * @instance
     */
    fvec16.prototype.s2 = 0;

    /**
     * fvec16 s3.
     * @member {number} s3
     * @memberof fvec16
     * @instance
     */
    fvec16.prototype.s3 = 0;

    /**
     * fvec16 s4.
     * @member {number} s4
     * @memberof fvec16
     * @instance
     */
    fvec16.prototype.s4 = 0;

    /**
     * fvec16 s5.
     * @member {number} s5
     * @memberof fvec16
     * @instance
     */
    fvec16.prototype.s5 = 0;

    /**
     * fvec16 s6.
     * @member {number} s6
     * @memberof fvec16
     * @instance
     */
    fvec16.prototype.s6 = 0;

    /**
     * fvec16 s7.
     * @member {number} s7
     * @memberof fvec16
     * @instance
     */
    fvec16.prototype.s7 = 0;

    /**
     * fvec16 s8.
     * @member {number} s8
     * @memberof fvec16
     * @instance
     */
    fvec16.prototype.s8 = 0;

    /**
     * fvec16 s9.
     * @member {number} s9
     * @memberof fvec16
     * @instance
     */
    fvec16.prototype.s9 = 0;

    /**
     * fvec16 sa.
     * @member {number} sa
     * @memberof fvec16
     * @instance
     */
    fvec16.prototype.sa = 0;

    /**
     * fvec16 sb.
     * @member {number} sb
     * @memberof fvec16
     * @instance
     */
    fvec16.prototype.sb = 0;

    /**
     * fvec16 sc.
     * @member {number} sc
     * @memberof fvec16
     * @instance
     */
    fvec16.prototype.sc = 0;

    /**
     * fvec16 sd.
     * @member {number} sd
     * @memberof fvec16
     * @instance
     */
    fvec16.prototype.sd = 0;

    /**
     * fvec16 se.
     * @member {number} se
     * @memberof fvec16
     * @instance
     */
    fvec16.prototype.se = 0;

    /**
     * fvec16 sf.
     * @member {number} sf
     * @memberof fvec16
     * @instance
     */
    fvec16.prototype.sf = 0;

    /**
     * Encodes the specified fvec16 message. Does not implicitly {@link fvec16.verify|verify} messages.
     * @function encode
     * @memberof fvec16
     * @static
     * @param {Ifvec16} message fvec16 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    fvec16.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            writer.uint32(/* id 1, wireType 5 =*/13).float(message.s0);
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            writer.uint32(/* id 2, wireType 5 =*/21).float(message.s1);
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            writer.uint32(/* id 3, wireType 5 =*/29).float(message.s2);
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            writer.uint32(/* id 4, wireType 5 =*/37).float(message.s3);
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            writer.uint32(/* id 5, wireType 5 =*/45).float(message.s4);
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            writer.uint32(/* id 6, wireType 5 =*/53).float(message.s5);
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            writer.uint32(/* id 7, wireType 5 =*/61).float(message.s6);
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            writer.uint32(/* id 8, wireType 5 =*/69).float(message.s7);
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            writer.uint32(/* id 9, wireType 5 =*/77).float(message.s8);
        if (message.s9 != null && Object.hasOwnProperty.call(message, "s9"))
            writer.uint32(/* id 10, wireType 5 =*/85).float(message.s9);
        if (message.sa != null && Object.hasOwnProperty.call(message, "sa"))
            writer.uint32(/* id 11, wireType 5 =*/93).float(message.sa);
        if (message.sb != null && Object.hasOwnProperty.call(message, "sb"))
            writer.uint32(/* id 12, wireType 5 =*/101).float(message.sb);
        if (message.sc != null && Object.hasOwnProperty.call(message, "sc"))
            writer.uint32(/* id 13, wireType 5 =*/109).float(message.sc);
        if (message.sd != null && Object.hasOwnProperty.call(message, "sd"))
            writer.uint32(/* id 14, wireType 5 =*/117).float(message.sd);
        if (message.se != null && Object.hasOwnProperty.call(message, "se"))
            writer.uint32(/* id 15, wireType 5 =*/125).float(message.se);
        if (message.sf != null && Object.hasOwnProperty.call(message, "sf"))
            writer.uint32(/* id 16, wireType 5 =*/133).float(message.sf);
        return writer;
    };

    /**
     * Decodes a fvec16 message from the specified reader or buffer.
     * @function decode
     * @memberof fvec16
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {fvec16} fvec16
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    fvec16.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.fvec16();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = reader.float();
                break;
            case 2:
                message.s1 = reader.float();
                break;
            case 3:
                message.s2 = reader.float();
                break;
            case 4:
                message.s3 = reader.float();
                break;
            case 5:
                message.s4 = reader.float();
                break;
            case 6:
                message.s5 = reader.float();
                break;
            case 7:
                message.s6 = reader.float();
                break;
            case 8:
                message.s7 = reader.float();
                break;
            case 9:
                message.s8 = reader.float();
                break;
            case 10:
                message.s9 = reader.float();
                break;
            case 11:
                message.sa = reader.float();
                break;
            case 12:
                message.sb = reader.float();
                break;
            case 13:
                message.sc = reader.float();
                break;
            case 14:
                message.sd = reader.float();
                break;
            case 15:
                message.se = reader.float();
                break;
            case 16:
                message.sf = reader.float();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return fvec16;
})();

export const ivec16 = $root.ivec16 = (() => {

    /**
     * Properties of an ivec16.
     * @exports Iivec16
     * @interface Iivec16
     * @property {number|null} [s0] ivec16 s0
     * @property {number|null} [s1] ivec16 s1
     * @property {number|null} [s2] ivec16 s2
     * @property {number|null} [s3] ivec16 s3
     * @property {number|null} [s4] ivec16 s4
     * @property {number|null} [s5] ivec16 s5
     * @property {number|null} [s6] ivec16 s6
     * @property {number|null} [s7] ivec16 s7
     * @property {number|null} [s8] ivec16 s8
     * @property {number|null} [s9] ivec16 s9
     * @property {number|null} [sa] ivec16 sa
     * @property {number|null} [sb] ivec16 sb
     * @property {number|null} [sc] ivec16 sc
     * @property {number|null} [sd] ivec16 sd
     * @property {number|null} [se] ivec16 se
     * @property {number|null} [sf] ivec16 sf
     */

    /**
     * Constructs a new ivec16.
     * @exports ivec16
     * @classdesc Represents an ivec16.
     * @implements Iivec16
     * @constructor
     * @param {Iivec16=} [properties] Properties to set
     */
    function ivec16(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ivec16 s0.
     * @member {number} s0
     * @memberof ivec16
     * @instance
     */
    ivec16.prototype.s0 = 0;

    /**
     * ivec16 s1.
     * @member {number} s1
     * @memberof ivec16
     * @instance
     */
    ivec16.prototype.s1 = 0;

    /**
     * ivec16 s2.
     * @member {number} s2
     * @memberof ivec16
     * @instance
     */
    ivec16.prototype.s2 = 0;

    /**
     * ivec16 s3.
     * @member {number} s3
     * @memberof ivec16
     * @instance
     */
    ivec16.prototype.s3 = 0;

    /**
     * ivec16 s4.
     * @member {number} s4
     * @memberof ivec16
     * @instance
     */
    ivec16.prototype.s4 = 0;

    /**
     * ivec16 s5.
     * @member {number} s5
     * @memberof ivec16
     * @instance
     */
    ivec16.prototype.s5 = 0;

    /**
     * ivec16 s6.
     * @member {number} s6
     * @memberof ivec16
     * @instance
     */
    ivec16.prototype.s6 = 0;

    /**
     * ivec16 s7.
     * @member {number} s7
     * @memberof ivec16
     * @instance
     */
    ivec16.prototype.s7 = 0;

    /**
     * ivec16 s8.
     * @member {number} s8
     * @memberof ivec16
     * @instance
     */
    ivec16.prototype.s8 = 0;

    /**
     * ivec16 s9.
     * @member {number} s9
     * @memberof ivec16
     * @instance
     */
    ivec16.prototype.s9 = 0;

    /**
     * ivec16 sa.
     * @member {number} sa
     * @memberof ivec16
     * @instance
     */
    ivec16.prototype.sa = 0;

    /**
     * ivec16 sb.
     * @member {number} sb
     * @memberof ivec16
     * @instance
     */
    ivec16.prototype.sb = 0;

    /**
     * ivec16 sc.
     * @member {number} sc
     * @memberof ivec16
     * @instance
     */
    ivec16.prototype.sc = 0;

    /**
     * ivec16 sd.
     * @member {number} sd
     * @memberof ivec16
     * @instance
     */
    ivec16.prototype.sd = 0;

    /**
     * ivec16 se.
     * @member {number} se
     * @memberof ivec16
     * @instance
     */
    ivec16.prototype.se = 0;

    /**
     * ivec16 sf.
     * @member {number} sf
     * @memberof ivec16
     * @instance
     */
    ivec16.prototype.sf = 0;

    /**
     * Encodes the specified ivec16 message. Does not implicitly {@link ivec16.verify|verify} messages.
     * @function encode
     * @memberof ivec16
     * @static
     * @param {Iivec16} message ivec16 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ivec16.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            writer.uint32(/* id 1, wireType 0 =*/8).sint32(message.s0);
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            writer.uint32(/* id 2, wireType 0 =*/16).sint32(message.s1);
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            writer.uint32(/* id 3, wireType 0 =*/24).sint32(message.s2);
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            writer.uint32(/* id 4, wireType 0 =*/32).sint32(message.s3);
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            writer.uint32(/* id 5, wireType 0 =*/40).sint32(message.s4);
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            writer.uint32(/* id 6, wireType 0 =*/48).sint32(message.s5);
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            writer.uint32(/* id 7, wireType 0 =*/56).sint32(message.s6);
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            writer.uint32(/* id 8, wireType 0 =*/64).sint32(message.s7);
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            writer.uint32(/* id 9, wireType 0 =*/72).sint32(message.s8);
        if (message.s9 != null && Object.hasOwnProperty.call(message, "s9"))
            writer.uint32(/* id 10, wireType 0 =*/80).sint32(message.s9);
        if (message.sa != null && Object.hasOwnProperty.call(message, "sa"))
            writer.uint32(/* id 11, wireType 0 =*/88).sint32(message.sa);
        if (message.sb != null && Object.hasOwnProperty.call(message, "sb"))
            writer.uint32(/* id 12, wireType 0 =*/96).sint32(message.sb);
        if (message.sc != null && Object.hasOwnProperty.call(message, "sc"))
            writer.uint32(/* id 13, wireType 0 =*/104).sint32(message.sc);
        if (message.sd != null && Object.hasOwnProperty.call(message, "sd"))
            writer.uint32(/* id 14, wireType 0 =*/112).sint32(message.sd);
        if (message.se != null && Object.hasOwnProperty.call(message, "se"))
            writer.uint32(/* id 15, wireType 0 =*/120).sint32(message.se);
        if (message.sf != null && Object.hasOwnProperty.call(message, "sf"))
            writer.uint32(/* id 16, wireType 0 =*/128).sint32(message.sf);
        return writer;
    };

    /**
     * Decodes an ivec16 message from the specified reader or buffer.
     * @function decode
     * @memberof ivec16
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ivec16} ivec16
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ivec16.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ivec16();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = reader.sint32();
                break;
            case 2:
                message.s1 = reader.sint32();
                break;
            case 3:
                message.s2 = reader.sint32();
                break;
            case 4:
                message.s3 = reader.sint32();
                break;
            case 5:
                message.s4 = reader.sint32();
                break;
            case 6:
                message.s5 = reader.sint32();
                break;
            case 7:
                message.s6 = reader.sint32();
                break;
            case 8:
                message.s7 = reader.sint32();
                break;
            case 9:
                message.s8 = reader.sint32();
                break;
            case 10:
                message.s9 = reader.sint32();
                break;
            case 11:
                message.sa = reader.sint32();
                break;
            case 12:
                message.sb = reader.sint32();
                break;
            case 13:
                message.sc = reader.sint32();
                break;
            case 14:
                message.sd = reader.sint32();
                break;
            case 15:
                message.se = reader.sint32();
                break;
            case 16:
                message.sf = reader.sint32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return ivec16;
})();

export const uvec16 = $root.uvec16 = (() => {

    /**
     * Properties of an uvec16.
     * @exports Iuvec16
     * @interface Iuvec16
     * @property {number|null} [s0] uvec16 s0
     * @property {number|null} [s1] uvec16 s1
     * @property {number|null} [s2] uvec16 s2
     * @property {number|null} [s3] uvec16 s3
     * @property {number|null} [s4] uvec16 s4
     * @property {number|null} [s5] uvec16 s5
     * @property {number|null} [s6] uvec16 s6
     * @property {number|null} [s7] uvec16 s7
     * @property {number|null} [s8] uvec16 s8
     * @property {number|null} [s9] uvec16 s9
     * @property {number|null} [sa] uvec16 sa
     * @property {number|null} [sb] uvec16 sb
     * @property {number|null} [sc] uvec16 sc
     * @property {number|null} [sd] uvec16 sd
     * @property {number|null} [se] uvec16 se
     * @property {number|null} [sf] uvec16 sf
     */

    /**
     * Constructs a new uvec16.
     * @exports uvec16
     * @classdesc Represents an uvec16.
     * @implements Iuvec16
     * @constructor
     * @param {Iuvec16=} [properties] Properties to set
     */
    function uvec16(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * uvec16 s0.
     * @member {number} s0
     * @memberof uvec16
     * @instance
     */
    uvec16.prototype.s0 = 0;

    /**
     * uvec16 s1.
     * @member {number} s1
     * @memberof uvec16
     * @instance
     */
    uvec16.prototype.s1 = 0;

    /**
     * uvec16 s2.
     * @member {number} s2
     * @memberof uvec16
     * @instance
     */
    uvec16.prototype.s2 = 0;

    /**
     * uvec16 s3.
     * @member {number} s3
     * @memberof uvec16
     * @instance
     */
    uvec16.prototype.s3 = 0;

    /**
     * uvec16 s4.
     * @member {number} s4
     * @memberof uvec16
     * @instance
     */
    uvec16.prototype.s4 = 0;

    /**
     * uvec16 s5.
     * @member {number} s5
     * @memberof uvec16
     * @instance
     */
    uvec16.prototype.s5 = 0;

    /**
     * uvec16 s6.
     * @member {number} s6
     * @memberof uvec16
     * @instance
     */
    uvec16.prototype.s6 = 0;

    /**
     * uvec16 s7.
     * @member {number} s7
     * @memberof uvec16
     * @instance
     */
    uvec16.prototype.s7 = 0;

    /**
     * uvec16 s8.
     * @member {number} s8
     * @memberof uvec16
     * @instance
     */
    uvec16.prototype.s8 = 0;

    /**
     * uvec16 s9.
     * @member {number} s9
     * @memberof uvec16
     * @instance
     */
    uvec16.prototype.s9 = 0;

    /**
     * uvec16 sa.
     * @member {number} sa
     * @memberof uvec16
     * @instance
     */
    uvec16.prototype.sa = 0;

    /**
     * uvec16 sb.
     * @member {number} sb
     * @memberof uvec16
     * @instance
     */
    uvec16.prototype.sb = 0;

    /**
     * uvec16 sc.
     * @member {number} sc
     * @memberof uvec16
     * @instance
     */
    uvec16.prototype.sc = 0;

    /**
     * uvec16 sd.
     * @member {number} sd
     * @memberof uvec16
     * @instance
     */
    uvec16.prototype.sd = 0;

    /**
     * uvec16 se.
     * @member {number} se
     * @memberof uvec16
     * @instance
     */
    uvec16.prototype.se = 0;

    /**
     * uvec16 sf.
     * @member {number} sf
     * @memberof uvec16
     * @instance
     */
    uvec16.prototype.sf = 0;

    /**
     * Encodes the specified uvec16 message. Does not implicitly {@link uvec16.verify|verify} messages.
     * @function encode
     * @memberof uvec16
     * @static
     * @param {Iuvec16} message uvec16 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    uvec16.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.s0);
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.s1);
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.s2);
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.s3);
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.s4);
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.s5);
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.s6);
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.s7);
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.s8);
        if (message.s9 != null && Object.hasOwnProperty.call(message, "s9"))
            writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.s9);
        if (message.sa != null && Object.hasOwnProperty.call(message, "sa"))
            writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.sa);
        if (message.sb != null && Object.hasOwnProperty.call(message, "sb"))
            writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.sb);
        if (message.sc != null && Object.hasOwnProperty.call(message, "sc"))
            writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.sc);
        if (message.sd != null && Object.hasOwnProperty.call(message, "sd"))
            writer.uint32(/* id 14, wireType 0 =*/112).uint32(message.sd);
        if (message.se != null && Object.hasOwnProperty.call(message, "se"))
            writer.uint32(/* id 15, wireType 0 =*/120).uint32(message.se);
        if (message.sf != null && Object.hasOwnProperty.call(message, "sf"))
            writer.uint32(/* id 16, wireType 0 =*/128).uint32(message.sf);
        return writer;
    };

    /**
     * Decodes an uvec16 message from the specified reader or buffer.
     * @function decode
     * @memberof uvec16
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {uvec16} uvec16
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    uvec16.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.uvec16();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = reader.uint32();
                break;
            case 2:
                message.s1 = reader.uint32();
                break;
            case 3:
                message.s2 = reader.uint32();
                break;
            case 4:
                message.s3 = reader.uint32();
                break;
            case 5:
                message.s4 = reader.uint32();
                break;
            case 6:
                message.s5 = reader.uint32();
                break;
            case 7:
                message.s6 = reader.uint32();
                break;
            case 8:
                message.s7 = reader.uint32();
                break;
            case 9:
                message.s8 = reader.uint32();
                break;
            case 10:
                message.s9 = reader.uint32();
                break;
            case 11:
                message.sa = reader.uint32();
                break;
            case 12:
                message.sb = reader.uint32();
                break;
            case 13:
                message.sc = reader.uint32();
                break;
            case 14:
                message.sd = reader.uint32();
                break;
            case 15:
                message.se = reader.uint32();
                break;
            case 16:
                message.sf = reader.uint32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return uvec16;
})();

export const mat = $root.mat = (() => {

    /**
     * Properties of a mat.
     * @exports Imat
     * @interface Imat
     * @property {number|null} [rows] mat rows
     * @property {number|null} [cols] mat cols
     * @property {Array.<number>|null} [v] mat v
     */

    /**
     * Constructs a new mat.
     * @exports mat
     * @classdesc Represents a mat.
     * @implements Imat
     * @constructor
     * @param {Imat=} [properties] Properties to set
     */
    function mat(properties) {
        this.v = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * mat rows.
     * @member {number} rows
     * @memberof mat
     * @instance
     */
    mat.prototype.rows = 0;

    /**
     * mat cols.
     * @member {number} cols
     * @memberof mat
     * @instance
     */
    mat.prototype.cols = 0;

    /**
     * mat v.
     * @member {Array.<number>} v
     * @memberof mat
     * @instance
     */
    mat.prototype.v = $util.emptyArray;

    /**
     * Encodes the specified mat message. Does not implicitly {@link mat.verify|verify} messages.
     * @function encode
     * @memberof mat
     * @static
     * @param {Imat} message mat message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    mat.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.rows != null && Object.hasOwnProperty.call(message, "rows"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.rows);
        if (message.cols != null && Object.hasOwnProperty.call(message, "cols"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.cols);
        if (message.v != null && message.v.length) {
            writer.uint32(/* id 3, wireType 2 =*/26).fork();
            for (let i = 0; i < message.v.length; ++i)
                writer.double(message.v[i]);
            writer.ldelim();
        }
        return writer;
    };

    /**
     * Decodes a mat message from the specified reader or buffer.
     * @function decode
     * @memberof mat
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {mat} mat
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    mat.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mat();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.rows = reader.uint32();
                break;
            case 2:
                message.cols = reader.uint32();
                break;
            case 3:
                if (!(message.v && message.v.length))
                    message.v = [];
                if ((tag & 7) === 2) {
                    let end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                        message.v.push(reader.double());
                } else
                    message.v.push(reader.double());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return mat;
})();

export const fmat = $root.fmat = (() => {

    /**
     * Properties of a fmat.
     * @exports Ifmat
     * @interface Ifmat
     * @property {number|null} [rows] fmat rows
     * @property {number|null} [cols] fmat cols
     * @property {Array.<number>|null} [v] fmat v
     */

    /**
     * Constructs a new fmat.
     * @exports fmat
     * @classdesc Represents a fmat.
     * @implements Ifmat
     * @constructor
     * @param {Ifmat=} [properties] Properties to set
     */
    function fmat(properties) {
        this.v = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * fmat rows.
     * @member {number} rows
     * @memberof fmat
     * @instance
     */
    fmat.prototype.rows = 0;

    /**
     * fmat cols.
     * @member {number} cols
     * @memberof fmat
     * @instance
     */
    fmat.prototype.cols = 0;

    /**
     * fmat v.
     * @member {Array.<number>} v
     * @memberof fmat
     * @instance
     */
    fmat.prototype.v = $util.emptyArray;

    /**
     * Encodes the specified fmat message. Does not implicitly {@link fmat.verify|verify} messages.
     * @function encode
     * @memberof fmat
     * @static
     * @param {Ifmat} message fmat message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    fmat.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.rows != null && Object.hasOwnProperty.call(message, "rows"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.rows);
        if (message.cols != null && Object.hasOwnProperty.call(message, "cols"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.cols);
        if (message.v != null && message.v.length) {
            writer.uint32(/* id 3, wireType 2 =*/26).fork();
            for (let i = 0; i < message.v.length; ++i)
                writer.float(message.v[i]);
            writer.ldelim();
        }
        return writer;
    };

    /**
     * Decodes a fmat message from the specified reader or buffer.
     * @function decode
     * @memberof fmat
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {fmat} fmat
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    fmat.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.fmat();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.rows = reader.uint32();
                break;
            case 2:
                message.cols = reader.uint32();
                break;
            case 3:
                if (!(message.v && message.v.length))
                    message.v = [];
                if ((tag & 7) === 2) {
                    let end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                        message.v.push(reader.float());
                } else
                    message.v.push(reader.float());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return fmat;
})();

export const imat = $root.imat = (() => {

    /**
     * Properties of an imat.
     * @exports Iimat
     * @interface Iimat
     * @property {number|null} [rows] imat rows
     * @property {number|null} [cols] imat cols
     * @property {Array.<number>|null} [v] imat v
     */

    /**
     * Constructs a new imat.
     * @exports imat
     * @classdesc Represents an imat.
     * @implements Iimat
     * @constructor
     * @param {Iimat=} [properties] Properties to set
     */
    function imat(properties) {
        this.v = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * imat rows.
     * @member {number} rows
     * @memberof imat
     * @instance
     */
    imat.prototype.rows = 0;

    /**
     * imat cols.
     * @member {number} cols
     * @memberof imat
     * @instance
     */
    imat.prototype.cols = 0;

    /**
     * imat v.
     * @member {Array.<number>} v
     * @memberof imat
     * @instance
     */
    imat.prototype.v = $util.emptyArray;

    /**
     * Encodes the specified imat message. Does not implicitly {@link imat.verify|verify} messages.
     * @function encode
     * @memberof imat
     * @static
     * @param {Iimat} message imat message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    imat.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.rows != null && Object.hasOwnProperty.call(message, "rows"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.rows);
        if (message.cols != null && Object.hasOwnProperty.call(message, "cols"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.cols);
        if (message.v != null && message.v.length) {
            writer.uint32(/* id 3, wireType 2 =*/26).fork();
            for (let i = 0; i < message.v.length; ++i)
                writer.sfixed32(message.v[i]);
            writer.ldelim();
        }
        return writer;
    };

    /**
     * Decodes an imat message from the specified reader or buffer.
     * @function decode
     * @memberof imat
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {imat} imat
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    imat.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.imat();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.rows = reader.uint32();
                break;
            case 2:
                message.cols = reader.uint32();
                break;
            case 3:
                if (!(message.v && message.v.length))
                    message.v = [];
                if ((tag & 7) === 2) {
                    let end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                        message.v.push(reader.sfixed32());
                } else
                    message.v.push(reader.sfixed32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return imat;
})();

export const umat = $root.umat = (() => {

    /**
     * Properties of an umat.
     * @exports Iumat
     * @interface Iumat
     * @property {number|null} [rows] umat rows
     * @property {number|null} [cols] umat cols
     * @property {Array.<number>|null} [v] umat v
     */

    /**
     * Constructs a new umat.
     * @exports umat
     * @classdesc Represents an umat.
     * @implements Iumat
     * @constructor
     * @param {Iumat=} [properties] Properties to set
     */
    function umat(properties) {
        this.v = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * umat rows.
     * @member {number} rows
     * @memberof umat
     * @instance
     */
    umat.prototype.rows = 0;

    /**
     * umat cols.
     * @member {number} cols
     * @memberof umat
     * @instance
     */
    umat.prototype.cols = 0;

    /**
     * umat v.
     * @member {Array.<number>} v
     * @memberof umat
     * @instance
     */
    umat.prototype.v = $util.emptyArray;

    /**
     * Encodes the specified umat message. Does not implicitly {@link umat.verify|verify} messages.
     * @function encode
     * @memberof umat
     * @static
     * @param {Iumat} message umat message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    umat.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.rows != null && Object.hasOwnProperty.call(message, "rows"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.rows);
        if (message.cols != null && Object.hasOwnProperty.call(message, "cols"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.cols);
        if (message.v != null && message.v.length) {
            writer.uint32(/* id 3, wireType 2 =*/26).fork();
            for (let i = 0; i < message.v.length; ++i)
                writer.fixed32(message.v[i]);
            writer.ldelim();
        }
        return writer;
    };

    /**
     * Decodes an umat message from the specified reader or buffer.
     * @function decode
     * @memberof umat
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {umat} umat
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    umat.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.umat();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.rows = reader.uint32();
                break;
            case 2:
                message.cols = reader.uint32();
                break;
            case 3:
                if (!(message.v && message.v.length))
                    message.v = [];
                if ((tag & 7) === 2) {
                    let end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                        message.v.push(reader.fixed32());
                } else
                    message.v.push(reader.fixed32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return umat;
})();

export const cmat = $root.cmat = (() => {

    /**
     * Properties of a cmat.
     * @exports Icmat
     * @interface Icmat
     * @property {number|null} [rows] cmat rows
     * @property {number|null} [cols] cmat cols
     * @property {Uint8Array|null} [v] cmat v
     */

    /**
     * Constructs a new cmat.
     * @exports cmat
     * @classdesc Represents a cmat.
     * @implements Icmat
     * @constructor
     * @param {Icmat=} [properties] Properties to set
     */
    function cmat(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * cmat rows.
     * @member {number} rows
     * @memberof cmat
     * @instance
     */
    cmat.prototype.rows = 0;

    /**
     * cmat cols.
     * @member {number} cols
     * @memberof cmat
     * @instance
     */
    cmat.prototype.cols = 0;

    /**
     * cmat v.
     * @member {Uint8Array} v
     * @memberof cmat
     * @instance
     */
    cmat.prototype.v = $util.newBuffer([]);

    /**
     * Encodes the specified cmat message. Does not implicitly {@link cmat.verify|verify} messages.
     * @function encode
     * @memberof cmat
     * @static
     * @param {Icmat} message cmat message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    cmat.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.rows != null && Object.hasOwnProperty.call(message, "rows"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.rows);
        if (message.cols != null && Object.hasOwnProperty.call(message, "cols"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.cols);
        if (message.v != null && Object.hasOwnProperty.call(message, "v"))
            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.v);
        return writer;
    };

    /**
     * Decodes a cmat message from the specified reader or buffer.
     * @function decode
     * @memberof cmat
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {cmat} cmat
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    cmat.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cmat();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.rows = reader.uint32();
                break;
            case 2:
                message.cols = reader.uint32();
                break;
            case 3:
                message.v = reader.bytes();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return cmat;
})();

export const mat2 = $root.mat2 = (() => {

    /**
     * Properties of a mat2.
     * @exports Imat2
     * @interface Imat2
     * @property {Ivec2|null} [x] mat2 x
     * @property {Ivec2|null} [y] mat2 y
     */

    /**
     * Constructs a new mat2.
     * @exports mat2
     * @classdesc Represents a mat2.
     * @implements Imat2
     * @constructor
     * @param {Imat2=} [properties] Properties to set
     */
    function mat2(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * mat2 x.
     * @member {Ivec2|null|undefined} x
     * @memberof mat2
     * @instance
     */
    mat2.prototype.x = null;

    /**
     * mat2 y.
     * @member {Ivec2|null|undefined} y
     * @memberof mat2
     * @instance
     */
    mat2.prototype.y = null;

    /**
     * Encodes the specified mat2 message. Does not implicitly {@link mat2.verify|verify} messages.
     * @function encode
     * @memberof mat2
     * @static
     * @param {Imat2} message mat2 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    mat2.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.x != null && Object.hasOwnProperty.call(message, "x"))
            $root.vec2.encode(message.x, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.y != null && Object.hasOwnProperty.call(message, "y"))
            $root.vec2.encode(message.y, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Decodes a mat2 message from the specified reader or buffer.
     * @function decode
     * @memberof mat2
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {mat2} mat2
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    mat2.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mat2();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.x = $root.vec2.decode(reader, reader.uint32());
                break;
            case 2:
                message.y = $root.vec2.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return mat2;
})();

export const fmat2 = $root.fmat2 = (() => {

    /**
     * Properties of a fmat2.
     * @exports Ifmat2
     * @interface Ifmat2
     * @property {Ifvec2|null} [x] fmat2 x
     * @property {Ifvec2|null} [y] fmat2 y
     */

    /**
     * Constructs a new fmat2.
     * @exports fmat2
     * @classdesc Represents a fmat2.
     * @implements Ifmat2
     * @constructor
     * @param {Ifmat2=} [properties] Properties to set
     */
    function fmat2(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * fmat2 x.
     * @member {Ifvec2|null|undefined} x
     * @memberof fmat2
     * @instance
     */
    fmat2.prototype.x = null;

    /**
     * fmat2 y.
     * @member {Ifvec2|null|undefined} y
     * @memberof fmat2
     * @instance
     */
    fmat2.prototype.y = null;

    /**
     * Encodes the specified fmat2 message. Does not implicitly {@link fmat2.verify|verify} messages.
     * @function encode
     * @memberof fmat2
     * @static
     * @param {Ifmat2} message fmat2 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    fmat2.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.x != null && Object.hasOwnProperty.call(message, "x"))
            $root.fvec2.encode(message.x, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.y != null && Object.hasOwnProperty.call(message, "y"))
            $root.fvec2.encode(message.y, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Decodes a fmat2 message from the specified reader or buffer.
     * @function decode
     * @memberof fmat2
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {fmat2} fmat2
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    fmat2.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.fmat2();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.x = $root.fvec2.decode(reader, reader.uint32());
                break;
            case 2:
                message.y = $root.fvec2.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return fmat2;
})();

export const imat2 = $root.imat2 = (() => {

    /**
     * Properties of an imat2.
     * @exports Iimat2
     * @interface Iimat2
     * @property {Iivec2|null} [x] imat2 x
     * @property {Iivec2|null} [y] imat2 y
     */

    /**
     * Constructs a new imat2.
     * @exports imat2
     * @classdesc Represents an imat2.
     * @implements Iimat2
     * @constructor
     * @param {Iimat2=} [properties] Properties to set
     */
    function imat2(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * imat2 x.
     * @member {Iivec2|null|undefined} x
     * @memberof imat2
     * @instance
     */
    imat2.prototype.x = null;

    /**
     * imat2 y.
     * @member {Iivec2|null|undefined} y
     * @memberof imat2
     * @instance
     */
    imat2.prototype.y = null;

    /**
     * Encodes the specified imat2 message. Does not implicitly {@link imat2.verify|verify} messages.
     * @function encode
     * @memberof imat2
     * @static
     * @param {Iimat2} message imat2 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    imat2.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.x != null && Object.hasOwnProperty.call(message, "x"))
            $root.ivec2.encode(message.x, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.y != null && Object.hasOwnProperty.call(message, "y"))
            $root.ivec2.encode(message.y, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Decodes an imat2 message from the specified reader or buffer.
     * @function decode
     * @memberof imat2
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {imat2} imat2
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    imat2.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.imat2();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.x = $root.ivec2.decode(reader, reader.uint32());
                break;
            case 2:
                message.y = $root.ivec2.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return imat2;
})();

export const umat2 = $root.umat2 = (() => {

    /**
     * Properties of an umat2.
     * @exports Iumat2
     * @interface Iumat2
     * @property {Iuvec2|null} [x] umat2 x
     * @property {Iuvec2|null} [y] umat2 y
     */

    /**
     * Constructs a new umat2.
     * @exports umat2
     * @classdesc Represents an umat2.
     * @implements Iumat2
     * @constructor
     * @param {Iumat2=} [properties] Properties to set
     */
    function umat2(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * umat2 x.
     * @member {Iuvec2|null|undefined} x
     * @memberof umat2
     * @instance
     */
    umat2.prototype.x = null;

    /**
     * umat2 y.
     * @member {Iuvec2|null|undefined} y
     * @memberof umat2
     * @instance
     */
    umat2.prototype.y = null;

    /**
     * Encodes the specified umat2 message. Does not implicitly {@link umat2.verify|verify} messages.
     * @function encode
     * @memberof umat2
     * @static
     * @param {Iumat2} message umat2 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    umat2.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.x != null && Object.hasOwnProperty.call(message, "x"))
            $root.uvec2.encode(message.x, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.y != null && Object.hasOwnProperty.call(message, "y"))
            $root.uvec2.encode(message.y, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Decodes an umat2 message from the specified reader or buffer.
     * @function decode
     * @memberof umat2
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {umat2} umat2
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    umat2.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.umat2();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.x = $root.uvec2.decode(reader, reader.uint32());
                break;
            case 2:
                message.y = $root.uvec2.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return umat2;
})();

export const mat3 = $root.mat3 = (() => {

    /**
     * Properties of a mat3.
     * @exports Imat3
     * @interface Imat3
     * @property {Ivec3|null} [x] mat3 x
     * @property {Ivec3|null} [y] mat3 y
     * @property {Ivec3|null} [z] mat3 z
     */

    /**
     * Constructs a new mat3.
     * @exports mat3
     * @classdesc Represents a mat3.
     * @implements Imat3
     * @constructor
     * @param {Imat3=} [properties] Properties to set
     */
    function mat3(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * mat3 x.
     * @member {Ivec3|null|undefined} x
     * @memberof mat3
     * @instance
     */
    mat3.prototype.x = null;

    /**
     * mat3 y.
     * @member {Ivec3|null|undefined} y
     * @memberof mat3
     * @instance
     */
    mat3.prototype.y = null;

    /**
     * mat3 z.
     * @member {Ivec3|null|undefined} z
     * @memberof mat3
     * @instance
     */
    mat3.prototype.z = null;

    /**
     * Encodes the specified mat3 message. Does not implicitly {@link mat3.verify|verify} messages.
     * @function encode
     * @memberof mat3
     * @static
     * @param {Imat3} message mat3 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    mat3.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.x != null && Object.hasOwnProperty.call(message, "x"))
            $root.vec3.encode(message.x, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.y != null && Object.hasOwnProperty.call(message, "y"))
            $root.vec3.encode(message.y, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.z != null && Object.hasOwnProperty.call(message, "z"))
            $root.vec3.encode(message.z, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Decodes a mat3 message from the specified reader or buffer.
     * @function decode
     * @memberof mat3
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {mat3} mat3
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    mat3.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mat3();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.x = $root.vec3.decode(reader, reader.uint32());
                break;
            case 2:
                message.y = $root.vec3.decode(reader, reader.uint32());
                break;
            case 3:
                message.z = $root.vec3.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return mat3;
})();

export const fmat3 = $root.fmat3 = (() => {

    /**
     * Properties of a fmat3.
     * @exports Ifmat3
     * @interface Ifmat3
     * @property {Ifvec3|null} [x] fmat3 x
     * @property {Ifvec3|null} [y] fmat3 y
     * @property {Ifvec3|null} [z] fmat3 z
     */

    /**
     * Constructs a new fmat3.
     * @exports fmat3
     * @classdesc Represents a fmat3.
     * @implements Ifmat3
     * @constructor
     * @param {Ifmat3=} [properties] Properties to set
     */
    function fmat3(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * fmat3 x.
     * @member {Ifvec3|null|undefined} x
     * @memberof fmat3
     * @instance
     */
    fmat3.prototype.x = null;

    /**
     * fmat3 y.
     * @member {Ifvec3|null|undefined} y
     * @memberof fmat3
     * @instance
     */
    fmat3.prototype.y = null;

    /**
     * fmat3 z.
     * @member {Ifvec3|null|undefined} z
     * @memberof fmat3
     * @instance
     */
    fmat3.prototype.z = null;

    /**
     * Encodes the specified fmat3 message. Does not implicitly {@link fmat3.verify|verify} messages.
     * @function encode
     * @memberof fmat3
     * @static
     * @param {Ifmat3} message fmat3 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    fmat3.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.x != null && Object.hasOwnProperty.call(message, "x"))
            $root.fvec3.encode(message.x, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.y != null && Object.hasOwnProperty.call(message, "y"))
            $root.fvec3.encode(message.y, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.z != null && Object.hasOwnProperty.call(message, "z"))
            $root.fvec3.encode(message.z, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Decodes a fmat3 message from the specified reader or buffer.
     * @function decode
     * @memberof fmat3
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {fmat3} fmat3
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    fmat3.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.fmat3();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.x = $root.fvec3.decode(reader, reader.uint32());
                break;
            case 2:
                message.y = $root.fvec3.decode(reader, reader.uint32());
                break;
            case 3:
                message.z = $root.fvec3.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return fmat3;
})();

export const imat3 = $root.imat3 = (() => {

    /**
     * Properties of an imat3.
     * @exports Iimat3
     * @interface Iimat3
     * @property {Iivec3|null} [x] imat3 x
     * @property {Iivec3|null} [y] imat3 y
     * @property {Iivec3|null} [z] imat3 z
     */

    /**
     * Constructs a new imat3.
     * @exports imat3
     * @classdesc Represents an imat3.
     * @implements Iimat3
     * @constructor
     * @param {Iimat3=} [properties] Properties to set
     */
    function imat3(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * imat3 x.
     * @member {Iivec3|null|undefined} x
     * @memberof imat3
     * @instance
     */
    imat3.prototype.x = null;

    /**
     * imat3 y.
     * @member {Iivec3|null|undefined} y
     * @memberof imat3
     * @instance
     */
    imat3.prototype.y = null;

    /**
     * imat3 z.
     * @member {Iivec3|null|undefined} z
     * @memberof imat3
     * @instance
     */
    imat3.prototype.z = null;

    /**
     * Encodes the specified imat3 message. Does not implicitly {@link imat3.verify|verify} messages.
     * @function encode
     * @memberof imat3
     * @static
     * @param {Iimat3} message imat3 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    imat3.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.x != null && Object.hasOwnProperty.call(message, "x"))
            $root.ivec3.encode(message.x, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.y != null && Object.hasOwnProperty.call(message, "y"))
            $root.ivec3.encode(message.y, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.z != null && Object.hasOwnProperty.call(message, "z"))
            $root.ivec3.encode(message.z, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Decodes an imat3 message from the specified reader or buffer.
     * @function decode
     * @memberof imat3
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {imat3} imat3
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    imat3.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.imat3();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.x = $root.ivec3.decode(reader, reader.uint32());
                break;
            case 2:
                message.y = $root.ivec3.decode(reader, reader.uint32());
                break;
            case 3:
                message.z = $root.ivec3.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return imat3;
})();

export const umat3 = $root.umat3 = (() => {

    /**
     * Properties of an umat3.
     * @exports Iumat3
     * @interface Iumat3
     * @property {Iuvec3|null} [x] umat3 x
     * @property {Iuvec3|null} [y] umat3 y
     * @property {Iuvec3|null} [z] umat3 z
     */

    /**
     * Constructs a new umat3.
     * @exports umat3
     * @classdesc Represents an umat3.
     * @implements Iumat3
     * @constructor
     * @param {Iumat3=} [properties] Properties to set
     */
    function umat3(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * umat3 x.
     * @member {Iuvec3|null|undefined} x
     * @memberof umat3
     * @instance
     */
    umat3.prototype.x = null;

    /**
     * umat3 y.
     * @member {Iuvec3|null|undefined} y
     * @memberof umat3
     * @instance
     */
    umat3.prototype.y = null;

    /**
     * umat3 z.
     * @member {Iuvec3|null|undefined} z
     * @memberof umat3
     * @instance
     */
    umat3.prototype.z = null;

    /**
     * Encodes the specified umat3 message. Does not implicitly {@link umat3.verify|verify} messages.
     * @function encode
     * @memberof umat3
     * @static
     * @param {Iumat3} message umat3 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    umat3.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.x != null && Object.hasOwnProperty.call(message, "x"))
            $root.uvec3.encode(message.x, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.y != null && Object.hasOwnProperty.call(message, "y"))
            $root.uvec3.encode(message.y, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.z != null && Object.hasOwnProperty.call(message, "z"))
            $root.uvec3.encode(message.z, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Decodes an umat3 message from the specified reader or buffer.
     * @function decode
     * @memberof umat3
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {umat3} umat3
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    umat3.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.umat3();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.x = $root.uvec3.decode(reader, reader.uint32());
                break;
            case 2:
                message.y = $root.uvec3.decode(reader, reader.uint32());
                break;
            case 3:
                message.z = $root.uvec3.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return umat3;
})();

export const mat4 = $root.mat4 = (() => {

    /**
     * Properties of a mat4.
     * @exports Imat4
     * @interface Imat4
     * @property {Ivec4|null} [x] mat4 x
     * @property {Ivec4|null} [y] mat4 y
     * @property {Ivec4|null} [z] mat4 z
     * @property {Ivec4|null} [t] mat4 t
     */

    /**
     * Constructs a new mat4.
     * @exports mat4
     * @classdesc Represents a mat4.
     * @implements Imat4
     * @constructor
     * @param {Imat4=} [properties] Properties to set
     */
    function mat4(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * mat4 x.
     * @member {Ivec4|null|undefined} x
     * @memberof mat4
     * @instance
     */
    mat4.prototype.x = null;

    /**
     * mat4 y.
     * @member {Ivec4|null|undefined} y
     * @memberof mat4
     * @instance
     */
    mat4.prototype.y = null;

    /**
     * mat4 z.
     * @member {Ivec4|null|undefined} z
     * @memberof mat4
     * @instance
     */
    mat4.prototype.z = null;

    /**
     * mat4 t.
     * @member {Ivec4|null|undefined} t
     * @memberof mat4
     * @instance
     */
    mat4.prototype.t = null;

    /**
     * Encodes the specified mat4 message. Does not implicitly {@link mat4.verify|verify} messages.
     * @function encode
     * @memberof mat4
     * @static
     * @param {Imat4} message mat4 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    mat4.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.x != null && Object.hasOwnProperty.call(message, "x"))
            $root.vec4.encode(message.x, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.y != null && Object.hasOwnProperty.call(message, "y"))
            $root.vec4.encode(message.y, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.z != null && Object.hasOwnProperty.call(message, "z"))
            $root.vec4.encode(message.z, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.t != null && Object.hasOwnProperty.call(message, "t"))
            $root.vec4.encode(message.t, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        return writer;
    };

    /**
     * Decodes a mat4 message from the specified reader or buffer.
     * @function decode
     * @memberof mat4
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {mat4} mat4
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    mat4.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mat4();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.x = $root.vec4.decode(reader, reader.uint32());
                break;
            case 2:
                message.y = $root.vec4.decode(reader, reader.uint32());
                break;
            case 3:
                message.z = $root.vec4.decode(reader, reader.uint32());
                break;
            case 4:
                message.t = $root.vec4.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return mat4;
})();

export const fmat4 = $root.fmat4 = (() => {

    /**
     * Properties of a fmat4.
     * @exports Ifmat4
     * @interface Ifmat4
     * @property {Ifvec4|null} [x] fmat4 x
     * @property {Ifvec4|null} [y] fmat4 y
     * @property {Ifvec4|null} [z] fmat4 z
     * @property {Ifvec4|null} [t] fmat4 t
     */

    /**
     * Constructs a new fmat4.
     * @exports fmat4
     * @classdesc Represents a fmat4.
     * @implements Ifmat4
     * @constructor
     * @param {Ifmat4=} [properties] Properties to set
     */
    function fmat4(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * fmat4 x.
     * @member {Ifvec4|null|undefined} x
     * @memberof fmat4
     * @instance
     */
    fmat4.prototype.x = null;

    /**
     * fmat4 y.
     * @member {Ifvec4|null|undefined} y
     * @memberof fmat4
     * @instance
     */
    fmat4.prototype.y = null;

    /**
     * fmat4 z.
     * @member {Ifvec4|null|undefined} z
     * @memberof fmat4
     * @instance
     */
    fmat4.prototype.z = null;

    /**
     * fmat4 t.
     * @member {Ifvec4|null|undefined} t
     * @memberof fmat4
     * @instance
     */
    fmat4.prototype.t = null;

    /**
     * Encodes the specified fmat4 message. Does not implicitly {@link fmat4.verify|verify} messages.
     * @function encode
     * @memberof fmat4
     * @static
     * @param {Ifmat4} message fmat4 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    fmat4.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.x != null && Object.hasOwnProperty.call(message, "x"))
            $root.fvec4.encode(message.x, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.y != null && Object.hasOwnProperty.call(message, "y"))
            $root.fvec4.encode(message.y, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.z != null && Object.hasOwnProperty.call(message, "z"))
            $root.fvec4.encode(message.z, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.t != null && Object.hasOwnProperty.call(message, "t"))
            $root.fvec4.encode(message.t, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        return writer;
    };

    /**
     * Decodes a fmat4 message from the specified reader or buffer.
     * @function decode
     * @memberof fmat4
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {fmat4} fmat4
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    fmat4.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.fmat4();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.x = $root.fvec4.decode(reader, reader.uint32());
                break;
            case 2:
                message.y = $root.fvec4.decode(reader, reader.uint32());
                break;
            case 3:
                message.z = $root.fvec4.decode(reader, reader.uint32());
                break;
            case 4:
                message.t = $root.fvec4.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return fmat4;
})();

export const imat4 = $root.imat4 = (() => {

    /**
     * Properties of an imat4.
     * @exports Iimat4
     * @interface Iimat4
     * @property {Iivec4|null} [x] imat4 x
     * @property {Iivec4|null} [y] imat4 y
     * @property {Iivec4|null} [z] imat4 z
     * @property {Iivec4|null} [t] imat4 t
     */

    /**
     * Constructs a new imat4.
     * @exports imat4
     * @classdesc Represents an imat4.
     * @implements Iimat4
     * @constructor
     * @param {Iimat4=} [properties] Properties to set
     */
    function imat4(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * imat4 x.
     * @member {Iivec4|null|undefined} x
     * @memberof imat4
     * @instance
     */
    imat4.prototype.x = null;

    /**
     * imat4 y.
     * @member {Iivec4|null|undefined} y
     * @memberof imat4
     * @instance
     */
    imat4.prototype.y = null;

    /**
     * imat4 z.
     * @member {Iivec4|null|undefined} z
     * @memberof imat4
     * @instance
     */
    imat4.prototype.z = null;

    /**
     * imat4 t.
     * @member {Iivec4|null|undefined} t
     * @memberof imat4
     * @instance
     */
    imat4.prototype.t = null;

    /**
     * Encodes the specified imat4 message. Does not implicitly {@link imat4.verify|verify} messages.
     * @function encode
     * @memberof imat4
     * @static
     * @param {Iimat4} message imat4 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    imat4.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.x != null && Object.hasOwnProperty.call(message, "x"))
            $root.ivec4.encode(message.x, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.y != null && Object.hasOwnProperty.call(message, "y"))
            $root.ivec4.encode(message.y, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.z != null && Object.hasOwnProperty.call(message, "z"))
            $root.ivec4.encode(message.z, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.t != null && Object.hasOwnProperty.call(message, "t"))
            $root.ivec4.encode(message.t, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        return writer;
    };

    /**
     * Decodes an imat4 message from the specified reader or buffer.
     * @function decode
     * @memberof imat4
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {imat4} imat4
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    imat4.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.imat4();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.x = $root.ivec4.decode(reader, reader.uint32());
                break;
            case 2:
                message.y = $root.ivec4.decode(reader, reader.uint32());
                break;
            case 3:
                message.z = $root.ivec4.decode(reader, reader.uint32());
                break;
            case 4:
                message.t = $root.ivec4.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return imat4;
})();

export const umat4 = $root.umat4 = (() => {

    /**
     * Properties of an umat4.
     * @exports Iumat4
     * @interface Iumat4
     * @property {Iuvec4|null} [x] umat4 x
     * @property {Iuvec4|null} [y] umat4 y
     * @property {Iuvec4|null} [z] umat4 z
     * @property {Iuvec4|null} [t] umat4 t
     */

    /**
     * Constructs a new umat4.
     * @exports umat4
     * @classdesc Represents an umat4.
     * @implements Iumat4
     * @constructor
     * @param {Iumat4=} [properties] Properties to set
     */
    function umat4(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * umat4 x.
     * @member {Iuvec4|null|undefined} x
     * @memberof umat4
     * @instance
     */
    umat4.prototype.x = null;

    /**
     * umat4 y.
     * @member {Iuvec4|null|undefined} y
     * @memberof umat4
     * @instance
     */
    umat4.prototype.y = null;

    /**
     * umat4 z.
     * @member {Iuvec4|null|undefined} z
     * @memberof umat4
     * @instance
     */
    umat4.prototype.z = null;

    /**
     * umat4 t.
     * @member {Iuvec4|null|undefined} t
     * @memberof umat4
     * @instance
     */
    umat4.prototype.t = null;

    /**
     * Encodes the specified umat4 message. Does not implicitly {@link umat4.verify|verify} messages.
     * @function encode
     * @memberof umat4
     * @static
     * @param {Iumat4} message umat4 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    umat4.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.x != null && Object.hasOwnProperty.call(message, "x"))
            $root.uvec4.encode(message.x, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.y != null && Object.hasOwnProperty.call(message, "y"))
            $root.uvec4.encode(message.y, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.z != null && Object.hasOwnProperty.call(message, "z"))
            $root.uvec4.encode(message.z, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.t != null && Object.hasOwnProperty.call(message, "t"))
            $root.uvec4.encode(message.t, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        return writer;
    };

    /**
     * Decodes an umat4 message from the specified reader or buffer.
     * @function decode
     * @memberof umat4
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {umat4} umat4
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    umat4.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.umat4();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.x = $root.uvec4.decode(reader, reader.uint32());
                break;
            case 2:
                message.y = $root.uvec4.decode(reader, reader.uint32());
                break;
            case 3:
                message.z = $root.uvec4.decode(reader, reader.uint32());
                break;
            case 4:
                message.t = $root.uvec4.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return umat4;
})();

export const mat5 = $root.mat5 = (() => {

    /**
     * Properties of a mat5.
     * @exports Imat5
     * @interface Imat5
     * @property {Ivec5|null} [s0] mat5 s0
     * @property {Ivec5|null} [s1] mat5 s1
     * @property {Ivec5|null} [s2] mat5 s2
     * @property {Ivec5|null} [s3] mat5 s3
     * @property {Ivec5|null} [s4] mat5 s4
     */

    /**
     * Constructs a new mat5.
     * @exports mat5
     * @classdesc Represents a mat5.
     * @implements Imat5
     * @constructor
     * @param {Imat5=} [properties] Properties to set
     */
    function mat5(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * mat5 s0.
     * @member {Ivec5|null|undefined} s0
     * @memberof mat5
     * @instance
     */
    mat5.prototype.s0 = null;

    /**
     * mat5 s1.
     * @member {Ivec5|null|undefined} s1
     * @memberof mat5
     * @instance
     */
    mat5.prototype.s1 = null;

    /**
     * mat5 s2.
     * @member {Ivec5|null|undefined} s2
     * @memberof mat5
     * @instance
     */
    mat5.prototype.s2 = null;

    /**
     * mat5 s3.
     * @member {Ivec5|null|undefined} s3
     * @memberof mat5
     * @instance
     */
    mat5.prototype.s3 = null;

    /**
     * mat5 s4.
     * @member {Ivec5|null|undefined} s4
     * @memberof mat5
     * @instance
     */
    mat5.prototype.s4 = null;

    /**
     * Encodes the specified mat5 message. Does not implicitly {@link mat5.verify|verify} messages.
     * @function encode
     * @memberof mat5
     * @static
     * @param {Imat5} message mat5 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    mat5.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            $root.vec5.encode(message.s0, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            $root.vec5.encode(message.s1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            $root.vec5.encode(message.s2, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            $root.vec5.encode(message.s3, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            $root.vec5.encode(message.s4, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        return writer;
    };

    /**
     * Decodes a mat5 message from the specified reader or buffer.
     * @function decode
     * @memberof mat5
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {mat5} mat5
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    mat5.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mat5();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = $root.vec5.decode(reader, reader.uint32());
                break;
            case 2:
                message.s1 = $root.vec5.decode(reader, reader.uint32());
                break;
            case 3:
                message.s2 = $root.vec5.decode(reader, reader.uint32());
                break;
            case 4:
                message.s3 = $root.vec5.decode(reader, reader.uint32());
                break;
            case 5:
                message.s4 = $root.vec5.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return mat5;
})();

export const fmat5 = $root.fmat5 = (() => {

    /**
     * Properties of a fmat5.
     * @exports Ifmat5
     * @interface Ifmat5
     * @property {Ifvec5|null} [s0] fmat5 s0
     * @property {Ifvec5|null} [s1] fmat5 s1
     * @property {Ifvec5|null} [s2] fmat5 s2
     * @property {Ifvec5|null} [s3] fmat5 s3
     * @property {Ifvec5|null} [s4] fmat5 s4
     */

    /**
     * Constructs a new fmat5.
     * @exports fmat5
     * @classdesc Represents a fmat5.
     * @implements Ifmat5
     * @constructor
     * @param {Ifmat5=} [properties] Properties to set
     */
    function fmat5(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * fmat5 s0.
     * @member {Ifvec5|null|undefined} s0
     * @memberof fmat5
     * @instance
     */
    fmat5.prototype.s0 = null;

    /**
     * fmat5 s1.
     * @member {Ifvec5|null|undefined} s1
     * @memberof fmat5
     * @instance
     */
    fmat5.prototype.s1 = null;

    /**
     * fmat5 s2.
     * @member {Ifvec5|null|undefined} s2
     * @memberof fmat5
     * @instance
     */
    fmat5.prototype.s2 = null;

    /**
     * fmat5 s3.
     * @member {Ifvec5|null|undefined} s3
     * @memberof fmat5
     * @instance
     */
    fmat5.prototype.s3 = null;

    /**
     * fmat5 s4.
     * @member {Ifvec5|null|undefined} s4
     * @memberof fmat5
     * @instance
     */
    fmat5.prototype.s4 = null;

    /**
     * Encodes the specified fmat5 message. Does not implicitly {@link fmat5.verify|verify} messages.
     * @function encode
     * @memberof fmat5
     * @static
     * @param {Ifmat5} message fmat5 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    fmat5.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            $root.fvec5.encode(message.s0, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            $root.fvec5.encode(message.s1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            $root.fvec5.encode(message.s2, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            $root.fvec5.encode(message.s3, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            $root.fvec5.encode(message.s4, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        return writer;
    };

    /**
     * Decodes a fmat5 message from the specified reader or buffer.
     * @function decode
     * @memberof fmat5
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {fmat5} fmat5
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    fmat5.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.fmat5();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = $root.fvec5.decode(reader, reader.uint32());
                break;
            case 2:
                message.s1 = $root.fvec5.decode(reader, reader.uint32());
                break;
            case 3:
                message.s2 = $root.fvec5.decode(reader, reader.uint32());
                break;
            case 4:
                message.s3 = $root.fvec5.decode(reader, reader.uint32());
                break;
            case 5:
                message.s4 = $root.fvec5.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return fmat5;
})();

export const imat5 = $root.imat5 = (() => {

    /**
     * Properties of an imat5.
     * @exports Iimat5
     * @interface Iimat5
     * @property {Iivec5|null} [s0] imat5 s0
     * @property {Iivec5|null} [s1] imat5 s1
     * @property {Iivec5|null} [s2] imat5 s2
     * @property {Iivec5|null} [s3] imat5 s3
     * @property {Iivec5|null} [s4] imat5 s4
     */

    /**
     * Constructs a new imat5.
     * @exports imat5
     * @classdesc Represents an imat5.
     * @implements Iimat5
     * @constructor
     * @param {Iimat5=} [properties] Properties to set
     */
    function imat5(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * imat5 s0.
     * @member {Iivec5|null|undefined} s0
     * @memberof imat5
     * @instance
     */
    imat5.prototype.s0 = null;

    /**
     * imat5 s1.
     * @member {Iivec5|null|undefined} s1
     * @memberof imat5
     * @instance
     */
    imat5.prototype.s1 = null;

    /**
     * imat5 s2.
     * @member {Iivec5|null|undefined} s2
     * @memberof imat5
     * @instance
     */
    imat5.prototype.s2 = null;

    /**
     * imat5 s3.
     * @member {Iivec5|null|undefined} s3
     * @memberof imat5
     * @instance
     */
    imat5.prototype.s3 = null;

    /**
     * imat5 s4.
     * @member {Iivec5|null|undefined} s4
     * @memberof imat5
     * @instance
     */
    imat5.prototype.s4 = null;

    /**
     * Encodes the specified imat5 message. Does not implicitly {@link imat5.verify|verify} messages.
     * @function encode
     * @memberof imat5
     * @static
     * @param {Iimat5} message imat5 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    imat5.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            $root.ivec5.encode(message.s0, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            $root.ivec5.encode(message.s1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            $root.ivec5.encode(message.s2, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            $root.ivec5.encode(message.s3, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            $root.ivec5.encode(message.s4, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        return writer;
    };

    /**
     * Decodes an imat5 message from the specified reader or buffer.
     * @function decode
     * @memberof imat5
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {imat5} imat5
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    imat5.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.imat5();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = $root.ivec5.decode(reader, reader.uint32());
                break;
            case 2:
                message.s1 = $root.ivec5.decode(reader, reader.uint32());
                break;
            case 3:
                message.s2 = $root.ivec5.decode(reader, reader.uint32());
                break;
            case 4:
                message.s3 = $root.ivec5.decode(reader, reader.uint32());
                break;
            case 5:
                message.s4 = $root.ivec5.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return imat5;
})();

export const umat5 = $root.umat5 = (() => {

    /**
     * Properties of an umat5.
     * @exports Iumat5
     * @interface Iumat5
     * @property {Iuvec5|null} [s0] umat5 s0
     * @property {Iuvec5|null} [s1] umat5 s1
     * @property {Iuvec5|null} [s2] umat5 s2
     * @property {Iuvec5|null} [s3] umat5 s3
     * @property {Iuvec5|null} [s4] umat5 s4
     */

    /**
     * Constructs a new umat5.
     * @exports umat5
     * @classdesc Represents an umat5.
     * @implements Iumat5
     * @constructor
     * @param {Iumat5=} [properties] Properties to set
     */
    function umat5(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * umat5 s0.
     * @member {Iuvec5|null|undefined} s0
     * @memberof umat5
     * @instance
     */
    umat5.prototype.s0 = null;

    /**
     * umat5 s1.
     * @member {Iuvec5|null|undefined} s1
     * @memberof umat5
     * @instance
     */
    umat5.prototype.s1 = null;

    /**
     * umat5 s2.
     * @member {Iuvec5|null|undefined} s2
     * @memberof umat5
     * @instance
     */
    umat5.prototype.s2 = null;

    /**
     * umat5 s3.
     * @member {Iuvec5|null|undefined} s3
     * @memberof umat5
     * @instance
     */
    umat5.prototype.s3 = null;

    /**
     * umat5 s4.
     * @member {Iuvec5|null|undefined} s4
     * @memberof umat5
     * @instance
     */
    umat5.prototype.s4 = null;

    /**
     * Encodes the specified umat5 message. Does not implicitly {@link umat5.verify|verify} messages.
     * @function encode
     * @memberof umat5
     * @static
     * @param {Iumat5} message umat5 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    umat5.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            $root.uvec5.encode(message.s0, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            $root.uvec5.encode(message.s1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            $root.uvec5.encode(message.s2, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            $root.uvec5.encode(message.s3, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            $root.uvec5.encode(message.s4, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        return writer;
    };

    /**
     * Decodes an umat5 message from the specified reader or buffer.
     * @function decode
     * @memberof umat5
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {umat5} umat5
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    umat5.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.umat5();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = $root.uvec5.decode(reader, reader.uint32());
                break;
            case 2:
                message.s1 = $root.uvec5.decode(reader, reader.uint32());
                break;
            case 3:
                message.s2 = $root.uvec5.decode(reader, reader.uint32());
                break;
            case 4:
                message.s3 = $root.uvec5.decode(reader, reader.uint32());
                break;
            case 5:
                message.s4 = $root.uvec5.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return umat5;
})();

export const mat6 = $root.mat6 = (() => {

    /**
     * Properties of a mat6.
     * @exports Imat6
     * @interface Imat6
     * @property {Ivec6|null} [s0] mat6 s0
     * @property {Ivec6|null} [s1] mat6 s1
     * @property {Ivec6|null} [s2] mat6 s2
     * @property {Ivec6|null} [s3] mat6 s3
     * @property {Ivec6|null} [s4] mat6 s4
     * @property {Ivec6|null} [s5] mat6 s5
     */

    /**
     * Constructs a new mat6.
     * @exports mat6
     * @classdesc Represents a mat6.
     * @implements Imat6
     * @constructor
     * @param {Imat6=} [properties] Properties to set
     */
    function mat6(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * mat6 s0.
     * @member {Ivec6|null|undefined} s0
     * @memberof mat6
     * @instance
     */
    mat6.prototype.s0 = null;

    /**
     * mat6 s1.
     * @member {Ivec6|null|undefined} s1
     * @memberof mat6
     * @instance
     */
    mat6.prototype.s1 = null;

    /**
     * mat6 s2.
     * @member {Ivec6|null|undefined} s2
     * @memberof mat6
     * @instance
     */
    mat6.prototype.s2 = null;

    /**
     * mat6 s3.
     * @member {Ivec6|null|undefined} s3
     * @memberof mat6
     * @instance
     */
    mat6.prototype.s3 = null;

    /**
     * mat6 s4.
     * @member {Ivec6|null|undefined} s4
     * @memberof mat6
     * @instance
     */
    mat6.prototype.s4 = null;

    /**
     * mat6 s5.
     * @member {Ivec6|null|undefined} s5
     * @memberof mat6
     * @instance
     */
    mat6.prototype.s5 = null;

    /**
     * Encodes the specified mat6 message. Does not implicitly {@link mat6.verify|verify} messages.
     * @function encode
     * @memberof mat6
     * @static
     * @param {Imat6} message mat6 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    mat6.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            $root.vec6.encode(message.s0, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            $root.vec6.encode(message.s1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            $root.vec6.encode(message.s2, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            $root.vec6.encode(message.s3, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            $root.vec6.encode(message.s4, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            $root.vec6.encode(message.s5, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        return writer;
    };

    /**
     * Decodes a mat6 message from the specified reader or buffer.
     * @function decode
     * @memberof mat6
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {mat6} mat6
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    mat6.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mat6();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = $root.vec6.decode(reader, reader.uint32());
                break;
            case 2:
                message.s1 = $root.vec6.decode(reader, reader.uint32());
                break;
            case 3:
                message.s2 = $root.vec6.decode(reader, reader.uint32());
                break;
            case 4:
                message.s3 = $root.vec6.decode(reader, reader.uint32());
                break;
            case 5:
                message.s4 = $root.vec6.decode(reader, reader.uint32());
                break;
            case 6:
                message.s5 = $root.vec6.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return mat6;
})();

export const fmat6 = $root.fmat6 = (() => {

    /**
     * Properties of a fmat6.
     * @exports Ifmat6
     * @interface Ifmat6
     * @property {Ifvec6|null} [s0] fmat6 s0
     * @property {Ifvec6|null} [s1] fmat6 s1
     * @property {Ifvec6|null} [s2] fmat6 s2
     * @property {Ifvec6|null} [s3] fmat6 s3
     * @property {Ifvec6|null} [s4] fmat6 s4
     * @property {Ifvec6|null} [s5] fmat6 s5
     */

    /**
     * Constructs a new fmat6.
     * @exports fmat6
     * @classdesc Represents a fmat6.
     * @implements Ifmat6
     * @constructor
     * @param {Ifmat6=} [properties] Properties to set
     */
    function fmat6(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * fmat6 s0.
     * @member {Ifvec6|null|undefined} s0
     * @memberof fmat6
     * @instance
     */
    fmat6.prototype.s0 = null;

    /**
     * fmat6 s1.
     * @member {Ifvec6|null|undefined} s1
     * @memberof fmat6
     * @instance
     */
    fmat6.prototype.s1 = null;

    /**
     * fmat6 s2.
     * @member {Ifvec6|null|undefined} s2
     * @memberof fmat6
     * @instance
     */
    fmat6.prototype.s2 = null;

    /**
     * fmat6 s3.
     * @member {Ifvec6|null|undefined} s3
     * @memberof fmat6
     * @instance
     */
    fmat6.prototype.s3 = null;

    /**
     * fmat6 s4.
     * @member {Ifvec6|null|undefined} s4
     * @memberof fmat6
     * @instance
     */
    fmat6.prototype.s4 = null;

    /**
     * fmat6 s5.
     * @member {Ifvec6|null|undefined} s5
     * @memberof fmat6
     * @instance
     */
    fmat6.prototype.s5 = null;

    /**
     * Encodes the specified fmat6 message. Does not implicitly {@link fmat6.verify|verify} messages.
     * @function encode
     * @memberof fmat6
     * @static
     * @param {Ifmat6} message fmat6 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    fmat6.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            $root.fvec6.encode(message.s0, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            $root.fvec6.encode(message.s1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            $root.fvec6.encode(message.s2, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            $root.fvec6.encode(message.s3, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            $root.fvec6.encode(message.s4, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            $root.fvec6.encode(message.s5, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        return writer;
    };

    /**
     * Decodes a fmat6 message from the specified reader or buffer.
     * @function decode
     * @memberof fmat6
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {fmat6} fmat6
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    fmat6.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.fmat6();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = $root.fvec6.decode(reader, reader.uint32());
                break;
            case 2:
                message.s1 = $root.fvec6.decode(reader, reader.uint32());
                break;
            case 3:
                message.s2 = $root.fvec6.decode(reader, reader.uint32());
                break;
            case 4:
                message.s3 = $root.fvec6.decode(reader, reader.uint32());
                break;
            case 5:
                message.s4 = $root.fvec6.decode(reader, reader.uint32());
                break;
            case 6:
                message.s5 = $root.fvec6.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return fmat6;
})();

export const imat6 = $root.imat6 = (() => {

    /**
     * Properties of an imat6.
     * @exports Iimat6
     * @interface Iimat6
     * @property {Iivec6|null} [s0] imat6 s0
     * @property {Iivec6|null} [s1] imat6 s1
     * @property {Iivec6|null} [s2] imat6 s2
     * @property {Iivec6|null} [s3] imat6 s3
     * @property {Iivec6|null} [s4] imat6 s4
     * @property {Iivec6|null} [s5] imat6 s5
     */

    /**
     * Constructs a new imat6.
     * @exports imat6
     * @classdesc Represents an imat6.
     * @implements Iimat6
     * @constructor
     * @param {Iimat6=} [properties] Properties to set
     */
    function imat6(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * imat6 s0.
     * @member {Iivec6|null|undefined} s0
     * @memberof imat6
     * @instance
     */
    imat6.prototype.s0 = null;

    /**
     * imat6 s1.
     * @member {Iivec6|null|undefined} s1
     * @memberof imat6
     * @instance
     */
    imat6.prototype.s1 = null;

    /**
     * imat6 s2.
     * @member {Iivec6|null|undefined} s2
     * @memberof imat6
     * @instance
     */
    imat6.prototype.s2 = null;

    /**
     * imat6 s3.
     * @member {Iivec6|null|undefined} s3
     * @memberof imat6
     * @instance
     */
    imat6.prototype.s3 = null;

    /**
     * imat6 s4.
     * @member {Iivec6|null|undefined} s4
     * @memberof imat6
     * @instance
     */
    imat6.prototype.s4 = null;

    /**
     * imat6 s5.
     * @member {Iivec6|null|undefined} s5
     * @memberof imat6
     * @instance
     */
    imat6.prototype.s5 = null;

    /**
     * Encodes the specified imat6 message. Does not implicitly {@link imat6.verify|verify} messages.
     * @function encode
     * @memberof imat6
     * @static
     * @param {Iimat6} message imat6 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    imat6.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            $root.ivec6.encode(message.s0, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            $root.ivec6.encode(message.s1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            $root.ivec6.encode(message.s2, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            $root.ivec6.encode(message.s3, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            $root.ivec6.encode(message.s4, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            $root.ivec6.encode(message.s5, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        return writer;
    };

    /**
     * Decodes an imat6 message from the specified reader or buffer.
     * @function decode
     * @memberof imat6
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {imat6} imat6
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    imat6.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.imat6();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = $root.ivec6.decode(reader, reader.uint32());
                break;
            case 2:
                message.s1 = $root.ivec6.decode(reader, reader.uint32());
                break;
            case 3:
                message.s2 = $root.ivec6.decode(reader, reader.uint32());
                break;
            case 4:
                message.s3 = $root.ivec6.decode(reader, reader.uint32());
                break;
            case 5:
                message.s4 = $root.ivec6.decode(reader, reader.uint32());
                break;
            case 6:
                message.s5 = $root.ivec6.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return imat6;
})();

export const umat6 = $root.umat6 = (() => {

    /**
     * Properties of an umat6.
     * @exports Iumat6
     * @interface Iumat6
     * @property {Iuvec6|null} [s0] umat6 s0
     * @property {Iuvec6|null} [s1] umat6 s1
     * @property {Iuvec6|null} [s2] umat6 s2
     * @property {Iuvec6|null} [s3] umat6 s3
     * @property {Iuvec6|null} [s4] umat6 s4
     * @property {Iuvec6|null} [s5] umat6 s5
     */

    /**
     * Constructs a new umat6.
     * @exports umat6
     * @classdesc Represents an umat6.
     * @implements Iumat6
     * @constructor
     * @param {Iumat6=} [properties] Properties to set
     */
    function umat6(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * umat6 s0.
     * @member {Iuvec6|null|undefined} s0
     * @memberof umat6
     * @instance
     */
    umat6.prototype.s0 = null;

    /**
     * umat6 s1.
     * @member {Iuvec6|null|undefined} s1
     * @memberof umat6
     * @instance
     */
    umat6.prototype.s1 = null;

    /**
     * umat6 s2.
     * @member {Iuvec6|null|undefined} s2
     * @memberof umat6
     * @instance
     */
    umat6.prototype.s2 = null;

    /**
     * umat6 s3.
     * @member {Iuvec6|null|undefined} s3
     * @memberof umat6
     * @instance
     */
    umat6.prototype.s3 = null;

    /**
     * umat6 s4.
     * @member {Iuvec6|null|undefined} s4
     * @memberof umat6
     * @instance
     */
    umat6.prototype.s4 = null;

    /**
     * umat6 s5.
     * @member {Iuvec6|null|undefined} s5
     * @memberof umat6
     * @instance
     */
    umat6.prototype.s5 = null;

    /**
     * Encodes the specified umat6 message. Does not implicitly {@link umat6.verify|verify} messages.
     * @function encode
     * @memberof umat6
     * @static
     * @param {Iumat6} message umat6 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    umat6.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            $root.uvec6.encode(message.s0, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            $root.uvec6.encode(message.s1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            $root.uvec6.encode(message.s2, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            $root.uvec6.encode(message.s3, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            $root.uvec6.encode(message.s4, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            $root.uvec6.encode(message.s5, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        return writer;
    };

    /**
     * Decodes an umat6 message from the specified reader or buffer.
     * @function decode
     * @memberof umat6
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {umat6} umat6
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    umat6.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.umat6();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = $root.uvec6.decode(reader, reader.uint32());
                break;
            case 2:
                message.s1 = $root.uvec6.decode(reader, reader.uint32());
                break;
            case 3:
                message.s2 = $root.uvec6.decode(reader, reader.uint32());
                break;
            case 4:
                message.s3 = $root.uvec6.decode(reader, reader.uint32());
                break;
            case 5:
                message.s4 = $root.uvec6.decode(reader, reader.uint32());
                break;
            case 6:
                message.s5 = $root.uvec6.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return umat6;
})();

export const mat7 = $root.mat7 = (() => {

    /**
     * Properties of a mat7.
     * @exports Imat7
     * @interface Imat7
     * @property {Ivec7|null} [s0] mat7 s0
     * @property {Ivec7|null} [s1] mat7 s1
     * @property {Ivec7|null} [s2] mat7 s2
     * @property {Ivec7|null} [s3] mat7 s3
     * @property {Ivec7|null} [s4] mat7 s4
     * @property {Ivec7|null} [s5] mat7 s5
     * @property {Ivec7|null} [s6] mat7 s6
     */

    /**
     * Constructs a new mat7.
     * @exports mat7
     * @classdesc Represents a mat7.
     * @implements Imat7
     * @constructor
     * @param {Imat7=} [properties] Properties to set
     */
    function mat7(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * mat7 s0.
     * @member {Ivec7|null|undefined} s0
     * @memberof mat7
     * @instance
     */
    mat7.prototype.s0 = null;

    /**
     * mat7 s1.
     * @member {Ivec7|null|undefined} s1
     * @memberof mat7
     * @instance
     */
    mat7.prototype.s1 = null;

    /**
     * mat7 s2.
     * @member {Ivec7|null|undefined} s2
     * @memberof mat7
     * @instance
     */
    mat7.prototype.s2 = null;

    /**
     * mat7 s3.
     * @member {Ivec7|null|undefined} s3
     * @memberof mat7
     * @instance
     */
    mat7.prototype.s3 = null;

    /**
     * mat7 s4.
     * @member {Ivec7|null|undefined} s4
     * @memberof mat7
     * @instance
     */
    mat7.prototype.s4 = null;

    /**
     * mat7 s5.
     * @member {Ivec7|null|undefined} s5
     * @memberof mat7
     * @instance
     */
    mat7.prototype.s5 = null;

    /**
     * mat7 s6.
     * @member {Ivec7|null|undefined} s6
     * @memberof mat7
     * @instance
     */
    mat7.prototype.s6 = null;

    /**
     * Encodes the specified mat7 message. Does not implicitly {@link mat7.verify|verify} messages.
     * @function encode
     * @memberof mat7
     * @static
     * @param {Imat7} message mat7 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    mat7.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            $root.vec7.encode(message.s0, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            $root.vec7.encode(message.s1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            $root.vec7.encode(message.s2, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            $root.vec7.encode(message.s3, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            $root.vec7.encode(message.s4, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            $root.vec7.encode(message.s5, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            $root.vec7.encode(message.s6, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        return writer;
    };

    /**
     * Decodes a mat7 message from the specified reader or buffer.
     * @function decode
     * @memberof mat7
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {mat7} mat7
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    mat7.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mat7();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = $root.vec7.decode(reader, reader.uint32());
                break;
            case 2:
                message.s1 = $root.vec7.decode(reader, reader.uint32());
                break;
            case 3:
                message.s2 = $root.vec7.decode(reader, reader.uint32());
                break;
            case 4:
                message.s3 = $root.vec7.decode(reader, reader.uint32());
                break;
            case 5:
                message.s4 = $root.vec7.decode(reader, reader.uint32());
                break;
            case 6:
                message.s5 = $root.vec7.decode(reader, reader.uint32());
                break;
            case 7:
                message.s6 = $root.vec7.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return mat7;
})();

export const fmat7 = $root.fmat7 = (() => {

    /**
     * Properties of a fmat7.
     * @exports Ifmat7
     * @interface Ifmat7
     * @property {Ifvec7|null} [s0] fmat7 s0
     * @property {Ifvec7|null} [s1] fmat7 s1
     * @property {Ifvec7|null} [s2] fmat7 s2
     * @property {Ifvec7|null} [s3] fmat7 s3
     * @property {Ifvec7|null} [s4] fmat7 s4
     * @property {Ifvec7|null} [s5] fmat7 s5
     * @property {Ifvec7|null} [s6] fmat7 s6
     */

    /**
     * Constructs a new fmat7.
     * @exports fmat7
     * @classdesc Represents a fmat7.
     * @implements Ifmat7
     * @constructor
     * @param {Ifmat7=} [properties] Properties to set
     */
    function fmat7(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * fmat7 s0.
     * @member {Ifvec7|null|undefined} s0
     * @memberof fmat7
     * @instance
     */
    fmat7.prototype.s0 = null;

    /**
     * fmat7 s1.
     * @member {Ifvec7|null|undefined} s1
     * @memberof fmat7
     * @instance
     */
    fmat7.prototype.s1 = null;

    /**
     * fmat7 s2.
     * @member {Ifvec7|null|undefined} s2
     * @memberof fmat7
     * @instance
     */
    fmat7.prototype.s2 = null;

    /**
     * fmat7 s3.
     * @member {Ifvec7|null|undefined} s3
     * @memberof fmat7
     * @instance
     */
    fmat7.prototype.s3 = null;

    /**
     * fmat7 s4.
     * @member {Ifvec7|null|undefined} s4
     * @memberof fmat7
     * @instance
     */
    fmat7.prototype.s4 = null;

    /**
     * fmat7 s5.
     * @member {Ifvec7|null|undefined} s5
     * @memberof fmat7
     * @instance
     */
    fmat7.prototype.s5 = null;

    /**
     * fmat7 s6.
     * @member {Ifvec7|null|undefined} s6
     * @memberof fmat7
     * @instance
     */
    fmat7.prototype.s6 = null;

    /**
     * Encodes the specified fmat7 message. Does not implicitly {@link fmat7.verify|verify} messages.
     * @function encode
     * @memberof fmat7
     * @static
     * @param {Ifmat7} message fmat7 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    fmat7.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            $root.fvec7.encode(message.s0, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            $root.fvec7.encode(message.s1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            $root.fvec7.encode(message.s2, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            $root.fvec7.encode(message.s3, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            $root.fvec7.encode(message.s4, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            $root.fvec7.encode(message.s5, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            $root.fvec7.encode(message.s6, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        return writer;
    };

    /**
     * Decodes a fmat7 message from the specified reader or buffer.
     * @function decode
     * @memberof fmat7
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {fmat7} fmat7
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    fmat7.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.fmat7();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = $root.fvec7.decode(reader, reader.uint32());
                break;
            case 2:
                message.s1 = $root.fvec7.decode(reader, reader.uint32());
                break;
            case 3:
                message.s2 = $root.fvec7.decode(reader, reader.uint32());
                break;
            case 4:
                message.s3 = $root.fvec7.decode(reader, reader.uint32());
                break;
            case 5:
                message.s4 = $root.fvec7.decode(reader, reader.uint32());
                break;
            case 6:
                message.s5 = $root.fvec7.decode(reader, reader.uint32());
                break;
            case 7:
                message.s6 = $root.fvec7.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return fmat7;
})();

export const imat7 = $root.imat7 = (() => {

    /**
     * Properties of an imat7.
     * @exports Iimat7
     * @interface Iimat7
     * @property {Iivec7|null} [s0] imat7 s0
     * @property {Iivec7|null} [s1] imat7 s1
     * @property {Iivec7|null} [s2] imat7 s2
     * @property {Iivec7|null} [s3] imat7 s3
     * @property {Iivec7|null} [s4] imat7 s4
     * @property {Iivec7|null} [s5] imat7 s5
     * @property {Iivec7|null} [s6] imat7 s6
     */

    /**
     * Constructs a new imat7.
     * @exports imat7
     * @classdesc Represents an imat7.
     * @implements Iimat7
     * @constructor
     * @param {Iimat7=} [properties] Properties to set
     */
    function imat7(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * imat7 s0.
     * @member {Iivec7|null|undefined} s0
     * @memberof imat7
     * @instance
     */
    imat7.prototype.s0 = null;

    /**
     * imat7 s1.
     * @member {Iivec7|null|undefined} s1
     * @memberof imat7
     * @instance
     */
    imat7.prototype.s1 = null;

    /**
     * imat7 s2.
     * @member {Iivec7|null|undefined} s2
     * @memberof imat7
     * @instance
     */
    imat7.prototype.s2 = null;

    /**
     * imat7 s3.
     * @member {Iivec7|null|undefined} s3
     * @memberof imat7
     * @instance
     */
    imat7.prototype.s3 = null;

    /**
     * imat7 s4.
     * @member {Iivec7|null|undefined} s4
     * @memberof imat7
     * @instance
     */
    imat7.prototype.s4 = null;

    /**
     * imat7 s5.
     * @member {Iivec7|null|undefined} s5
     * @memberof imat7
     * @instance
     */
    imat7.prototype.s5 = null;

    /**
     * imat7 s6.
     * @member {Iivec7|null|undefined} s6
     * @memberof imat7
     * @instance
     */
    imat7.prototype.s6 = null;

    /**
     * Encodes the specified imat7 message. Does not implicitly {@link imat7.verify|verify} messages.
     * @function encode
     * @memberof imat7
     * @static
     * @param {Iimat7} message imat7 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    imat7.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            $root.ivec7.encode(message.s0, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            $root.ivec7.encode(message.s1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            $root.ivec7.encode(message.s2, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            $root.ivec7.encode(message.s3, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            $root.ivec7.encode(message.s4, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            $root.ivec7.encode(message.s5, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            $root.ivec7.encode(message.s6, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        return writer;
    };

    /**
     * Decodes an imat7 message from the specified reader or buffer.
     * @function decode
     * @memberof imat7
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {imat7} imat7
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    imat7.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.imat7();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = $root.ivec7.decode(reader, reader.uint32());
                break;
            case 2:
                message.s1 = $root.ivec7.decode(reader, reader.uint32());
                break;
            case 3:
                message.s2 = $root.ivec7.decode(reader, reader.uint32());
                break;
            case 4:
                message.s3 = $root.ivec7.decode(reader, reader.uint32());
                break;
            case 5:
                message.s4 = $root.ivec7.decode(reader, reader.uint32());
                break;
            case 6:
                message.s5 = $root.ivec7.decode(reader, reader.uint32());
                break;
            case 7:
                message.s6 = $root.ivec7.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return imat7;
})();

export const umat7 = $root.umat7 = (() => {

    /**
     * Properties of an umat7.
     * @exports Iumat7
     * @interface Iumat7
     * @property {Iuvec7|null} [s0] umat7 s0
     * @property {Iuvec7|null} [s1] umat7 s1
     * @property {Iuvec7|null} [s2] umat7 s2
     * @property {Iuvec7|null} [s3] umat7 s3
     * @property {Iuvec7|null} [s4] umat7 s4
     * @property {Iuvec7|null} [s5] umat7 s5
     * @property {Iuvec7|null} [s6] umat7 s6
     */

    /**
     * Constructs a new umat7.
     * @exports umat7
     * @classdesc Represents an umat7.
     * @implements Iumat7
     * @constructor
     * @param {Iumat7=} [properties] Properties to set
     */
    function umat7(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * umat7 s0.
     * @member {Iuvec7|null|undefined} s0
     * @memberof umat7
     * @instance
     */
    umat7.prototype.s0 = null;

    /**
     * umat7 s1.
     * @member {Iuvec7|null|undefined} s1
     * @memberof umat7
     * @instance
     */
    umat7.prototype.s1 = null;

    /**
     * umat7 s2.
     * @member {Iuvec7|null|undefined} s2
     * @memberof umat7
     * @instance
     */
    umat7.prototype.s2 = null;

    /**
     * umat7 s3.
     * @member {Iuvec7|null|undefined} s3
     * @memberof umat7
     * @instance
     */
    umat7.prototype.s3 = null;

    /**
     * umat7 s4.
     * @member {Iuvec7|null|undefined} s4
     * @memberof umat7
     * @instance
     */
    umat7.prototype.s4 = null;

    /**
     * umat7 s5.
     * @member {Iuvec7|null|undefined} s5
     * @memberof umat7
     * @instance
     */
    umat7.prototype.s5 = null;

    /**
     * umat7 s6.
     * @member {Iuvec7|null|undefined} s6
     * @memberof umat7
     * @instance
     */
    umat7.prototype.s6 = null;

    /**
     * Encodes the specified umat7 message. Does not implicitly {@link umat7.verify|verify} messages.
     * @function encode
     * @memberof umat7
     * @static
     * @param {Iumat7} message umat7 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    umat7.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            $root.uvec7.encode(message.s0, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            $root.uvec7.encode(message.s1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            $root.uvec7.encode(message.s2, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            $root.uvec7.encode(message.s3, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            $root.uvec7.encode(message.s4, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            $root.uvec7.encode(message.s5, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            $root.uvec7.encode(message.s6, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        return writer;
    };

    /**
     * Decodes an umat7 message from the specified reader or buffer.
     * @function decode
     * @memberof umat7
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {umat7} umat7
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    umat7.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.umat7();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = $root.uvec7.decode(reader, reader.uint32());
                break;
            case 2:
                message.s1 = $root.uvec7.decode(reader, reader.uint32());
                break;
            case 3:
                message.s2 = $root.uvec7.decode(reader, reader.uint32());
                break;
            case 4:
                message.s3 = $root.uvec7.decode(reader, reader.uint32());
                break;
            case 5:
                message.s4 = $root.uvec7.decode(reader, reader.uint32());
                break;
            case 6:
                message.s5 = $root.uvec7.decode(reader, reader.uint32());
                break;
            case 7:
                message.s6 = $root.uvec7.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return umat7;
})();

export const mat8 = $root.mat8 = (() => {

    /**
     * Properties of a mat8.
     * @exports Imat8
     * @interface Imat8
     * @property {Ivec8|null} [s0] mat8 s0
     * @property {Ivec8|null} [s1] mat8 s1
     * @property {Ivec8|null} [s2] mat8 s2
     * @property {Ivec8|null} [s3] mat8 s3
     * @property {Ivec8|null} [s4] mat8 s4
     * @property {Ivec8|null} [s5] mat8 s5
     * @property {Ivec8|null} [s6] mat8 s6
     * @property {Ivec8|null} [s7] mat8 s7
     */

    /**
     * Constructs a new mat8.
     * @exports mat8
     * @classdesc Represents a mat8.
     * @implements Imat8
     * @constructor
     * @param {Imat8=} [properties] Properties to set
     */
    function mat8(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * mat8 s0.
     * @member {Ivec8|null|undefined} s0
     * @memberof mat8
     * @instance
     */
    mat8.prototype.s0 = null;

    /**
     * mat8 s1.
     * @member {Ivec8|null|undefined} s1
     * @memberof mat8
     * @instance
     */
    mat8.prototype.s1 = null;

    /**
     * mat8 s2.
     * @member {Ivec8|null|undefined} s2
     * @memberof mat8
     * @instance
     */
    mat8.prototype.s2 = null;

    /**
     * mat8 s3.
     * @member {Ivec8|null|undefined} s3
     * @memberof mat8
     * @instance
     */
    mat8.prototype.s3 = null;

    /**
     * mat8 s4.
     * @member {Ivec8|null|undefined} s4
     * @memberof mat8
     * @instance
     */
    mat8.prototype.s4 = null;

    /**
     * mat8 s5.
     * @member {Ivec8|null|undefined} s5
     * @memberof mat8
     * @instance
     */
    mat8.prototype.s5 = null;

    /**
     * mat8 s6.
     * @member {Ivec8|null|undefined} s6
     * @memberof mat8
     * @instance
     */
    mat8.prototype.s6 = null;

    /**
     * mat8 s7.
     * @member {Ivec8|null|undefined} s7
     * @memberof mat8
     * @instance
     */
    mat8.prototype.s7 = null;

    /**
     * Encodes the specified mat8 message. Does not implicitly {@link mat8.verify|verify} messages.
     * @function encode
     * @memberof mat8
     * @static
     * @param {Imat8} message mat8 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    mat8.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            $root.vec8.encode(message.s0, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            $root.vec8.encode(message.s1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            $root.vec8.encode(message.s2, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            $root.vec8.encode(message.s3, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            $root.vec8.encode(message.s4, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            $root.vec8.encode(message.s5, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            $root.vec8.encode(message.s6, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            $root.vec8.encode(message.s7, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        return writer;
    };

    /**
     * Decodes a mat8 message from the specified reader or buffer.
     * @function decode
     * @memberof mat8
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {mat8} mat8
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    mat8.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mat8();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = $root.vec8.decode(reader, reader.uint32());
                break;
            case 2:
                message.s1 = $root.vec8.decode(reader, reader.uint32());
                break;
            case 3:
                message.s2 = $root.vec8.decode(reader, reader.uint32());
                break;
            case 4:
                message.s3 = $root.vec8.decode(reader, reader.uint32());
                break;
            case 5:
                message.s4 = $root.vec8.decode(reader, reader.uint32());
                break;
            case 6:
                message.s5 = $root.vec8.decode(reader, reader.uint32());
                break;
            case 7:
                message.s6 = $root.vec8.decode(reader, reader.uint32());
                break;
            case 8:
                message.s7 = $root.vec8.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return mat8;
})();

export const fmat8 = $root.fmat8 = (() => {

    /**
     * Properties of a fmat8.
     * @exports Ifmat8
     * @interface Ifmat8
     * @property {Ifvec8|null} [s0] fmat8 s0
     * @property {Ifvec8|null} [s1] fmat8 s1
     * @property {Ifvec8|null} [s2] fmat8 s2
     * @property {Ifvec8|null} [s3] fmat8 s3
     * @property {Ifvec8|null} [s4] fmat8 s4
     * @property {Ifvec8|null} [s5] fmat8 s5
     * @property {Ifvec8|null} [s6] fmat8 s6
     * @property {Ifvec8|null} [s7] fmat8 s7
     */

    /**
     * Constructs a new fmat8.
     * @exports fmat8
     * @classdesc Represents a fmat8.
     * @implements Ifmat8
     * @constructor
     * @param {Ifmat8=} [properties] Properties to set
     */
    function fmat8(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * fmat8 s0.
     * @member {Ifvec8|null|undefined} s0
     * @memberof fmat8
     * @instance
     */
    fmat8.prototype.s0 = null;

    /**
     * fmat8 s1.
     * @member {Ifvec8|null|undefined} s1
     * @memberof fmat8
     * @instance
     */
    fmat8.prototype.s1 = null;

    /**
     * fmat8 s2.
     * @member {Ifvec8|null|undefined} s2
     * @memberof fmat8
     * @instance
     */
    fmat8.prototype.s2 = null;

    /**
     * fmat8 s3.
     * @member {Ifvec8|null|undefined} s3
     * @memberof fmat8
     * @instance
     */
    fmat8.prototype.s3 = null;

    /**
     * fmat8 s4.
     * @member {Ifvec8|null|undefined} s4
     * @memberof fmat8
     * @instance
     */
    fmat8.prototype.s4 = null;

    /**
     * fmat8 s5.
     * @member {Ifvec8|null|undefined} s5
     * @memberof fmat8
     * @instance
     */
    fmat8.prototype.s5 = null;

    /**
     * fmat8 s6.
     * @member {Ifvec8|null|undefined} s6
     * @memberof fmat8
     * @instance
     */
    fmat8.prototype.s6 = null;

    /**
     * fmat8 s7.
     * @member {Ifvec8|null|undefined} s7
     * @memberof fmat8
     * @instance
     */
    fmat8.prototype.s7 = null;

    /**
     * Encodes the specified fmat8 message. Does not implicitly {@link fmat8.verify|verify} messages.
     * @function encode
     * @memberof fmat8
     * @static
     * @param {Ifmat8} message fmat8 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    fmat8.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            $root.fvec8.encode(message.s0, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            $root.fvec8.encode(message.s1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            $root.fvec8.encode(message.s2, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            $root.fvec8.encode(message.s3, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            $root.fvec8.encode(message.s4, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            $root.fvec8.encode(message.s5, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            $root.fvec8.encode(message.s6, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            $root.fvec8.encode(message.s7, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        return writer;
    };

    /**
     * Decodes a fmat8 message from the specified reader or buffer.
     * @function decode
     * @memberof fmat8
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {fmat8} fmat8
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    fmat8.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.fmat8();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = $root.fvec8.decode(reader, reader.uint32());
                break;
            case 2:
                message.s1 = $root.fvec8.decode(reader, reader.uint32());
                break;
            case 3:
                message.s2 = $root.fvec8.decode(reader, reader.uint32());
                break;
            case 4:
                message.s3 = $root.fvec8.decode(reader, reader.uint32());
                break;
            case 5:
                message.s4 = $root.fvec8.decode(reader, reader.uint32());
                break;
            case 6:
                message.s5 = $root.fvec8.decode(reader, reader.uint32());
                break;
            case 7:
                message.s6 = $root.fvec8.decode(reader, reader.uint32());
                break;
            case 8:
                message.s7 = $root.fvec8.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return fmat8;
})();

export const imat8 = $root.imat8 = (() => {

    /**
     * Properties of an imat8.
     * @exports Iimat8
     * @interface Iimat8
     * @property {Iivec8|null} [s0] imat8 s0
     * @property {Iivec8|null} [s1] imat8 s1
     * @property {Iivec8|null} [s2] imat8 s2
     * @property {Iivec8|null} [s3] imat8 s3
     * @property {Iivec8|null} [s4] imat8 s4
     * @property {Iivec8|null} [s5] imat8 s5
     * @property {Iivec8|null} [s6] imat8 s6
     * @property {Iivec8|null} [s7] imat8 s7
     */

    /**
     * Constructs a new imat8.
     * @exports imat8
     * @classdesc Represents an imat8.
     * @implements Iimat8
     * @constructor
     * @param {Iimat8=} [properties] Properties to set
     */
    function imat8(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * imat8 s0.
     * @member {Iivec8|null|undefined} s0
     * @memberof imat8
     * @instance
     */
    imat8.prototype.s0 = null;

    /**
     * imat8 s1.
     * @member {Iivec8|null|undefined} s1
     * @memberof imat8
     * @instance
     */
    imat8.prototype.s1 = null;

    /**
     * imat8 s2.
     * @member {Iivec8|null|undefined} s2
     * @memberof imat8
     * @instance
     */
    imat8.prototype.s2 = null;

    /**
     * imat8 s3.
     * @member {Iivec8|null|undefined} s3
     * @memberof imat8
     * @instance
     */
    imat8.prototype.s3 = null;

    /**
     * imat8 s4.
     * @member {Iivec8|null|undefined} s4
     * @memberof imat8
     * @instance
     */
    imat8.prototype.s4 = null;

    /**
     * imat8 s5.
     * @member {Iivec8|null|undefined} s5
     * @memberof imat8
     * @instance
     */
    imat8.prototype.s5 = null;

    /**
     * imat8 s6.
     * @member {Iivec8|null|undefined} s6
     * @memberof imat8
     * @instance
     */
    imat8.prototype.s6 = null;

    /**
     * imat8 s7.
     * @member {Iivec8|null|undefined} s7
     * @memberof imat8
     * @instance
     */
    imat8.prototype.s7 = null;

    /**
     * Encodes the specified imat8 message. Does not implicitly {@link imat8.verify|verify} messages.
     * @function encode
     * @memberof imat8
     * @static
     * @param {Iimat8} message imat8 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    imat8.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            $root.ivec8.encode(message.s0, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            $root.ivec8.encode(message.s1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            $root.ivec8.encode(message.s2, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            $root.ivec8.encode(message.s3, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            $root.ivec8.encode(message.s4, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            $root.ivec8.encode(message.s5, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            $root.ivec8.encode(message.s6, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            $root.ivec8.encode(message.s7, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        return writer;
    };

    /**
     * Decodes an imat8 message from the specified reader or buffer.
     * @function decode
     * @memberof imat8
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {imat8} imat8
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    imat8.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.imat8();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = $root.ivec8.decode(reader, reader.uint32());
                break;
            case 2:
                message.s1 = $root.ivec8.decode(reader, reader.uint32());
                break;
            case 3:
                message.s2 = $root.ivec8.decode(reader, reader.uint32());
                break;
            case 4:
                message.s3 = $root.ivec8.decode(reader, reader.uint32());
                break;
            case 5:
                message.s4 = $root.ivec8.decode(reader, reader.uint32());
                break;
            case 6:
                message.s5 = $root.ivec8.decode(reader, reader.uint32());
                break;
            case 7:
                message.s6 = $root.ivec8.decode(reader, reader.uint32());
                break;
            case 8:
                message.s7 = $root.ivec8.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return imat8;
})();

export const umat8 = $root.umat8 = (() => {

    /**
     * Properties of an umat8.
     * @exports Iumat8
     * @interface Iumat8
     * @property {Iuvec8|null} [s0] umat8 s0
     * @property {Iuvec8|null} [s1] umat8 s1
     * @property {Iuvec8|null} [s2] umat8 s2
     * @property {Iuvec8|null} [s3] umat8 s3
     * @property {Iuvec8|null} [s4] umat8 s4
     * @property {Iuvec8|null} [s5] umat8 s5
     * @property {Iuvec8|null} [s6] umat8 s6
     * @property {Iuvec8|null} [s7] umat8 s7
     */

    /**
     * Constructs a new umat8.
     * @exports umat8
     * @classdesc Represents an umat8.
     * @implements Iumat8
     * @constructor
     * @param {Iumat8=} [properties] Properties to set
     */
    function umat8(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * umat8 s0.
     * @member {Iuvec8|null|undefined} s0
     * @memberof umat8
     * @instance
     */
    umat8.prototype.s0 = null;

    /**
     * umat8 s1.
     * @member {Iuvec8|null|undefined} s1
     * @memberof umat8
     * @instance
     */
    umat8.prototype.s1 = null;

    /**
     * umat8 s2.
     * @member {Iuvec8|null|undefined} s2
     * @memberof umat8
     * @instance
     */
    umat8.prototype.s2 = null;

    /**
     * umat8 s3.
     * @member {Iuvec8|null|undefined} s3
     * @memberof umat8
     * @instance
     */
    umat8.prototype.s3 = null;

    /**
     * umat8 s4.
     * @member {Iuvec8|null|undefined} s4
     * @memberof umat8
     * @instance
     */
    umat8.prototype.s4 = null;

    /**
     * umat8 s5.
     * @member {Iuvec8|null|undefined} s5
     * @memberof umat8
     * @instance
     */
    umat8.prototype.s5 = null;

    /**
     * umat8 s6.
     * @member {Iuvec8|null|undefined} s6
     * @memberof umat8
     * @instance
     */
    umat8.prototype.s6 = null;

    /**
     * umat8 s7.
     * @member {Iuvec8|null|undefined} s7
     * @memberof umat8
     * @instance
     */
    umat8.prototype.s7 = null;

    /**
     * Encodes the specified umat8 message. Does not implicitly {@link umat8.verify|verify} messages.
     * @function encode
     * @memberof umat8
     * @static
     * @param {Iumat8} message umat8 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    umat8.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            $root.uvec8.encode(message.s0, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            $root.uvec8.encode(message.s1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            $root.uvec8.encode(message.s2, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            $root.uvec8.encode(message.s3, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            $root.uvec8.encode(message.s4, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            $root.uvec8.encode(message.s5, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            $root.uvec8.encode(message.s6, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            $root.uvec8.encode(message.s7, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        return writer;
    };

    /**
     * Decodes an umat8 message from the specified reader or buffer.
     * @function decode
     * @memberof umat8
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {umat8} umat8
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    umat8.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.umat8();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = $root.uvec8.decode(reader, reader.uint32());
                break;
            case 2:
                message.s1 = $root.uvec8.decode(reader, reader.uint32());
                break;
            case 3:
                message.s2 = $root.uvec8.decode(reader, reader.uint32());
                break;
            case 4:
                message.s3 = $root.uvec8.decode(reader, reader.uint32());
                break;
            case 5:
                message.s4 = $root.uvec8.decode(reader, reader.uint32());
                break;
            case 6:
                message.s5 = $root.uvec8.decode(reader, reader.uint32());
                break;
            case 7:
                message.s6 = $root.uvec8.decode(reader, reader.uint32());
                break;
            case 8:
                message.s7 = $root.uvec8.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return umat8;
})();

export const mat9 = $root.mat9 = (() => {

    /**
     * Properties of a mat9.
     * @exports Imat9
     * @interface Imat9
     * @property {Ivec9|null} [s0] mat9 s0
     * @property {Ivec9|null} [s1] mat9 s1
     * @property {Ivec9|null} [s2] mat9 s2
     * @property {Ivec9|null} [s3] mat9 s3
     * @property {Ivec9|null} [s4] mat9 s4
     * @property {Ivec9|null} [s5] mat9 s5
     * @property {Ivec9|null} [s6] mat9 s6
     * @property {Ivec9|null} [s7] mat9 s7
     * @property {Ivec9|null} [s8] mat9 s8
     */

    /**
     * Constructs a new mat9.
     * @exports mat9
     * @classdesc Represents a mat9.
     * @implements Imat9
     * @constructor
     * @param {Imat9=} [properties] Properties to set
     */
    function mat9(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * mat9 s0.
     * @member {Ivec9|null|undefined} s0
     * @memberof mat9
     * @instance
     */
    mat9.prototype.s0 = null;

    /**
     * mat9 s1.
     * @member {Ivec9|null|undefined} s1
     * @memberof mat9
     * @instance
     */
    mat9.prototype.s1 = null;

    /**
     * mat9 s2.
     * @member {Ivec9|null|undefined} s2
     * @memberof mat9
     * @instance
     */
    mat9.prototype.s2 = null;

    /**
     * mat9 s3.
     * @member {Ivec9|null|undefined} s3
     * @memberof mat9
     * @instance
     */
    mat9.prototype.s3 = null;

    /**
     * mat9 s4.
     * @member {Ivec9|null|undefined} s4
     * @memberof mat9
     * @instance
     */
    mat9.prototype.s4 = null;

    /**
     * mat9 s5.
     * @member {Ivec9|null|undefined} s5
     * @memberof mat9
     * @instance
     */
    mat9.prototype.s5 = null;

    /**
     * mat9 s6.
     * @member {Ivec9|null|undefined} s6
     * @memberof mat9
     * @instance
     */
    mat9.prototype.s6 = null;

    /**
     * mat9 s7.
     * @member {Ivec9|null|undefined} s7
     * @memberof mat9
     * @instance
     */
    mat9.prototype.s7 = null;

    /**
     * mat9 s8.
     * @member {Ivec9|null|undefined} s8
     * @memberof mat9
     * @instance
     */
    mat9.prototype.s8 = null;

    /**
     * Encodes the specified mat9 message. Does not implicitly {@link mat9.verify|verify} messages.
     * @function encode
     * @memberof mat9
     * @static
     * @param {Imat9} message mat9 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    mat9.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            $root.vec9.encode(message.s0, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            $root.vec9.encode(message.s1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            $root.vec9.encode(message.s2, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            $root.vec9.encode(message.s3, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            $root.vec9.encode(message.s4, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            $root.vec9.encode(message.s5, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            $root.vec9.encode(message.s6, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            $root.vec9.encode(message.s7, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            $root.vec9.encode(message.s8, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        return writer;
    };

    /**
     * Decodes a mat9 message from the specified reader or buffer.
     * @function decode
     * @memberof mat9
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {mat9} mat9
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    mat9.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mat9();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = $root.vec9.decode(reader, reader.uint32());
                break;
            case 2:
                message.s1 = $root.vec9.decode(reader, reader.uint32());
                break;
            case 3:
                message.s2 = $root.vec9.decode(reader, reader.uint32());
                break;
            case 4:
                message.s3 = $root.vec9.decode(reader, reader.uint32());
                break;
            case 5:
                message.s4 = $root.vec9.decode(reader, reader.uint32());
                break;
            case 6:
                message.s5 = $root.vec9.decode(reader, reader.uint32());
                break;
            case 7:
                message.s6 = $root.vec9.decode(reader, reader.uint32());
                break;
            case 8:
                message.s7 = $root.vec9.decode(reader, reader.uint32());
                break;
            case 9:
                message.s8 = $root.vec9.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return mat9;
})();

export const fmat9 = $root.fmat9 = (() => {

    /**
     * Properties of a fmat9.
     * @exports Ifmat9
     * @interface Ifmat9
     * @property {Ifvec9|null} [s0] fmat9 s0
     * @property {Ifvec9|null} [s1] fmat9 s1
     * @property {Ifvec9|null} [s2] fmat9 s2
     * @property {Ifvec9|null} [s3] fmat9 s3
     * @property {Ifvec9|null} [s4] fmat9 s4
     * @property {Ifvec9|null} [s5] fmat9 s5
     * @property {Ifvec9|null} [s6] fmat9 s6
     * @property {Ifvec9|null} [s7] fmat9 s7
     * @property {Ifvec9|null} [s8] fmat9 s8
     */

    /**
     * Constructs a new fmat9.
     * @exports fmat9
     * @classdesc Represents a fmat9.
     * @implements Ifmat9
     * @constructor
     * @param {Ifmat9=} [properties] Properties to set
     */
    function fmat9(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * fmat9 s0.
     * @member {Ifvec9|null|undefined} s0
     * @memberof fmat9
     * @instance
     */
    fmat9.prototype.s0 = null;

    /**
     * fmat9 s1.
     * @member {Ifvec9|null|undefined} s1
     * @memberof fmat9
     * @instance
     */
    fmat9.prototype.s1 = null;

    /**
     * fmat9 s2.
     * @member {Ifvec9|null|undefined} s2
     * @memberof fmat9
     * @instance
     */
    fmat9.prototype.s2 = null;

    /**
     * fmat9 s3.
     * @member {Ifvec9|null|undefined} s3
     * @memberof fmat9
     * @instance
     */
    fmat9.prototype.s3 = null;

    /**
     * fmat9 s4.
     * @member {Ifvec9|null|undefined} s4
     * @memberof fmat9
     * @instance
     */
    fmat9.prototype.s4 = null;

    /**
     * fmat9 s5.
     * @member {Ifvec9|null|undefined} s5
     * @memberof fmat9
     * @instance
     */
    fmat9.prototype.s5 = null;

    /**
     * fmat9 s6.
     * @member {Ifvec9|null|undefined} s6
     * @memberof fmat9
     * @instance
     */
    fmat9.prototype.s6 = null;

    /**
     * fmat9 s7.
     * @member {Ifvec9|null|undefined} s7
     * @memberof fmat9
     * @instance
     */
    fmat9.prototype.s7 = null;

    /**
     * fmat9 s8.
     * @member {Ifvec9|null|undefined} s8
     * @memberof fmat9
     * @instance
     */
    fmat9.prototype.s8 = null;

    /**
     * Encodes the specified fmat9 message. Does not implicitly {@link fmat9.verify|verify} messages.
     * @function encode
     * @memberof fmat9
     * @static
     * @param {Ifmat9} message fmat9 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    fmat9.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            $root.fvec9.encode(message.s0, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            $root.fvec9.encode(message.s1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            $root.fvec9.encode(message.s2, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            $root.fvec9.encode(message.s3, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            $root.fvec9.encode(message.s4, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            $root.fvec9.encode(message.s5, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            $root.fvec9.encode(message.s6, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            $root.fvec9.encode(message.s7, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            $root.fvec9.encode(message.s8, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        return writer;
    };

    /**
     * Decodes a fmat9 message from the specified reader or buffer.
     * @function decode
     * @memberof fmat9
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {fmat9} fmat9
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    fmat9.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.fmat9();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = $root.fvec9.decode(reader, reader.uint32());
                break;
            case 2:
                message.s1 = $root.fvec9.decode(reader, reader.uint32());
                break;
            case 3:
                message.s2 = $root.fvec9.decode(reader, reader.uint32());
                break;
            case 4:
                message.s3 = $root.fvec9.decode(reader, reader.uint32());
                break;
            case 5:
                message.s4 = $root.fvec9.decode(reader, reader.uint32());
                break;
            case 6:
                message.s5 = $root.fvec9.decode(reader, reader.uint32());
                break;
            case 7:
                message.s6 = $root.fvec9.decode(reader, reader.uint32());
                break;
            case 8:
                message.s7 = $root.fvec9.decode(reader, reader.uint32());
                break;
            case 9:
                message.s8 = $root.fvec9.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return fmat9;
})();

export const imat9 = $root.imat9 = (() => {

    /**
     * Properties of an imat9.
     * @exports Iimat9
     * @interface Iimat9
     * @property {Iivec9|null} [s0] imat9 s0
     * @property {Iivec9|null} [s1] imat9 s1
     * @property {Iivec9|null} [s2] imat9 s2
     * @property {Iivec9|null} [s3] imat9 s3
     * @property {Iivec9|null} [s4] imat9 s4
     * @property {Iivec9|null} [s5] imat9 s5
     * @property {Iivec9|null} [s6] imat9 s6
     * @property {Iivec9|null} [s7] imat9 s7
     * @property {Iivec9|null} [s8] imat9 s8
     */

    /**
     * Constructs a new imat9.
     * @exports imat9
     * @classdesc Represents an imat9.
     * @implements Iimat9
     * @constructor
     * @param {Iimat9=} [properties] Properties to set
     */
    function imat9(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * imat9 s0.
     * @member {Iivec9|null|undefined} s0
     * @memberof imat9
     * @instance
     */
    imat9.prototype.s0 = null;

    /**
     * imat9 s1.
     * @member {Iivec9|null|undefined} s1
     * @memberof imat9
     * @instance
     */
    imat9.prototype.s1 = null;

    /**
     * imat9 s2.
     * @member {Iivec9|null|undefined} s2
     * @memberof imat9
     * @instance
     */
    imat9.prototype.s2 = null;

    /**
     * imat9 s3.
     * @member {Iivec9|null|undefined} s3
     * @memberof imat9
     * @instance
     */
    imat9.prototype.s3 = null;

    /**
     * imat9 s4.
     * @member {Iivec9|null|undefined} s4
     * @memberof imat9
     * @instance
     */
    imat9.prototype.s4 = null;

    /**
     * imat9 s5.
     * @member {Iivec9|null|undefined} s5
     * @memberof imat9
     * @instance
     */
    imat9.prototype.s5 = null;

    /**
     * imat9 s6.
     * @member {Iivec9|null|undefined} s6
     * @memberof imat9
     * @instance
     */
    imat9.prototype.s6 = null;

    /**
     * imat9 s7.
     * @member {Iivec9|null|undefined} s7
     * @memberof imat9
     * @instance
     */
    imat9.prototype.s7 = null;

    /**
     * imat9 s8.
     * @member {Iivec9|null|undefined} s8
     * @memberof imat9
     * @instance
     */
    imat9.prototype.s8 = null;

    /**
     * Encodes the specified imat9 message. Does not implicitly {@link imat9.verify|verify} messages.
     * @function encode
     * @memberof imat9
     * @static
     * @param {Iimat9} message imat9 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    imat9.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            $root.ivec9.encode(message.s0, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            $root.ivec9.encode(message.s1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            $root.ivec9.encode(message.s2, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            $root.ivec9.encode(message.s3, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            $root.ivec9.encode(message.s4, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            $root.ivec9.encode(message.s5, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            $root.ivec9.encode(message.s6, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            $root.ivec9.encode(message.s7, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            $root.ivec9.encode(message.s8, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        return writer;
    };

    /**
     * Decodes an imat9 message from the specified reader or buffer.
     * @function decode
     * @memberof imat9
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {imat9} imat9
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    imat9.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.imat9();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = $root.ivec9.decode(reader, reader.uint32());
                break;
            case 2:
                message.s1 = $root.ivec9.decode(reader, reader.uint32());
                break;
            case 3:
                message.s2 = $root.ivec9.decode(reader, reader.uint32());
                break;
            case 4:
                message.s3 = $root.ivec9.decode(reader, reader.uint32());
                break;
            case 5:
                message.s4 = $root.ivec9.decode(reader, reader.uint32());
                break;
            case 6:
                message.s5 = $root.ivec9.decode(reader, reader.uint32());
                break;
            case 7:
                message.s6 = $root.ivec9.decode(reader, reader.uint32());
                break;
            case 8:
                message.s7 = $root.ivec9.decode(reader, reader.uint32());
                break;
            case 9:
                message.s8 = $root.ivec9.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return imat9;
})();

export const umat9 = $root.umat9 = (() => {

    /**
     * Properties of an umat9.
     * @exports Iumat9
     * @interface Iumat9
     * @property {Iuvec9|null} [s0] umat9 s0
     * @property {Iuvec9|null} [s1] umat9 s1
     * @property {Iuvec9|null} [s2] umat9 s2
     * @property {Iuvec9|null} [s3] umat9 s3
     * @property {Iuvec9|null} [s4] umat9 s4
     * @property {Iuvec9|null} [s5] umat9 s5
     * @property {Iuvec9|null} [s6] umat9 s6
     * @property {Iuvec9|null} [s7] umat9 s7
     * @property {Iuvec9|null} [s8] umat9 s8
     */

    /**
     * Constructs a new umat9.
     * @exports umat9
     * @classdesc Represents an umat9.
     * @implements Iumat9
     * @constructor
     * @param {Iumat9=} [properties] Properties to set
     */
    function umat9(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * umat9 s0.
     * @member {Iuvec9|null|undefined} s0
     * @memberof umat9
     * @instance
     */
    umat9.prototype.s0 = null;

    /**
     * umat9 s1.
     * @member {Iuvec9|null|undefined} s1
     * @memberof umat9
     * @instance
     */
    umat9.prototype.s1 = null;

    /**
     * umat9 s2.
     * @member {Iuvec9|null|undefined} s2
     * @memberof umat9
     * @instance
     */
    umat9.prototype.s2 = null;

    /**
     * umat9 s3.
     * @member {Iuvec9|null|undefined} s3
     * @memberof umat9
     * @instance
     */
    umat9.prototype.s3 = null;

    /**
     * umat9 s4.
     * @member {Iuvec9|null|undefined} s4
     * @memberof umat9
     * @instance
     */
    umat9.prototype.s4 = null;

    /**
     * umat9 s5.
     * @member {Iuvec9|null|undefined} s5
     * @memberof umat9
     * @instance
     */
    umat9.prototype.s5 = null;

    /**
     * umat9 s6.
     * @member {Iuvec9|null|undefined} s6
     * @memberof umat9
     * @instance
     */
    umat9.prototype.s6 = null;

    /**
     * umat9 s7.
     * @member {Iuvec9|null|undefined} s7
     * @memberof umat9
     * @instance
     */
    umat9.prototype.s7 = null;

    /**
     * umat9 s8.
     * @member {Iuvec9|null|undefined} s8
     * @memberof umat9
     * @instance
     */
    umat9.prototype.s8 = null;

    /**
     * Encodes the specified umat9 message. Does not implicitly {@link umat9.verify|verify} messages.
     * @function encode
     * @memberof umat9
     * @static
     * @param {Iumat9} message umat9 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    umat9.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            $root.uvec9.encode(message.s0, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            $root.uvec9.encode(message.s1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            $root.uvec9.encode(message.s2, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            $root.uvec9.encode(message.s3, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            $root.uvec9.encode(message.s4, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            $root.uvec9.encode(message.s5, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            $root.uvec9.encode(message.s6, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            $root.uvec9.encode(message.s7, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            $root.uvec9.encode(message.s8, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        return writer;
    };

    /**
     * Decodes an umat9 message from the specified reader or buffer.
     * @function decode
     * @memberof umat9
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {umat9} umat9
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    umat9.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.umat9();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = $root.uvec9.decode(reader, reader.uint32());
                break;
            case 2:
                message.s1 = $root.uvec9.decode(reader, reader.uint32());
                break;
            case 3:
                message.s2 = $root.uvec9.decode(reader, reader.uint32());
                break;
            case 4:
                message.s3 = $root.uvec9.decode(reader, reader.uint32());
                break;
            case 5:
                message.s4 = $root.uvec9.decode(reader, reader.uint32());
                break;
            case 6:
                message.s5 = $root.uvec9.decode(reader, reader.uint32());
                break;
            case 7:
                message.s6 = $root.uvec9.decode(reader, reader.uint32());
                break;
            case 8:
                message.s7 = $root.uvec9.decode(reader, reader.uint32());
                break;
            case 9:
                message.s8 = $root.uvec9.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return umat9;
})();

export const mat10 = $root.mat10 = (() => {

    /**
     * Properties of a mat10.
     * @exports Imat10
     * @interface Imat10
     * @property {Ivec10|null} [s0] mat10 s0
     * @property {Ivec10|null} [s1] mat10 s1
     * @property {Ivec10|null} [s2] mat10 s2
     * @property {Ivec10|null} [s3] mat10 s3
     * @property {Ivec10|null} [s4] mat10 s4
     * @property {Ivec10|null} [s5] mat10 s5
     * @property {Ivec10|null} [s6] mat10 s6
     * @property {Ivec10|null} [s7] mat10 s7
     * @property {Ivec10|null} [s8] mat10 s8
     * @property {Ivec10|null} [s9] mat10 s9
     */

    /**
     * Constructs a new mat10.
     * @exports mat10
     * @classdesc Represents a mat10.
     * @implements Imat10
     * @constructor
     * @param {Imat10=} [properties] Properties to set
     */
    function mat10(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * mat10 s0.
     * @member {Ivec10|null|undefined} s0
     * @memberof mat10
     * @instance
     */
    mat10.prototype.s0 = null;

    /**
     * mat10 s1.
     * @member {Ivec10|null|undefined} s1
     * @memberof mat10
     * @instance
     */
    mat10.prototype.s1 = null;

    /**
     * mat10 s2.
     * @member {Ivec10|null|undefined} s2
     * @memberof mat10
     * @instance
     */
    mat10.prototype.s2 = null;

    /**
     * mat10 s3.
     * @member {Ivec10|null|undefined} s3
     * @memberof mat10
     * @instance
     */
    mat10.prototype.s3 = null;

    /**
     * mat10 s4.
     * @member {Ivec10|null|undefined} s4
     * @memberof mat10
     * @instance
     */
    mat10.prototype.s4 = null;

    /**
     * mat10 s5.
     * @member {Ivec10|null|undefined} s5
     * @memberof mat10
     * @instance
     */
    mat10.prototype.s5 = null;

    /**
     * mat10 s6.
     * @member {Ivec10|null|undefined} s6
     * @memberof mat10
     * @instance
     */
    mat10.prototype.s6 = null;

    /**
     * mat10 s7.
     * @member {Ivec10|null|undefined} s7
     * @memberof mat10
     * @instance
     */
    mat10.prototype.s7 = null;

    /**
     * mat10 s8.
     * @member {Ivec10|null|undefined} s8
     * @memberof mat10
     * @instance
     */
    mat10.prototype.s8 = null;

    /**
     * mat10 s9.
     * @member {Ivec10|null|undefined} s9
     * @memberof mat10
     * @instance
     */
    mat10.prototype.s9 = null;

    /**
     * Encodes the specified mat10 message. Does not implicitly {@link mat10.verify|verify} messages.
     * @function encode
     * @memberof mat10
     * @static
     * @param {Imat10} message mat10 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    mat10.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            $root.vec10.encode(message.s0, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            $root.vec10.encode(message.s1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            $root.vec10.encode(message.s2, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            $root.vec10.encode(message.s3, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            $root.vec10.encode(message.s4, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            $root.vec10.encode(message.s5, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            $root.vec10.encode(message.s6, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            $root.vec10.encode(message.s7, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            $root.vec10.encode(message.s8, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        if (message.s9 != null && Object.hasOwnProperty.call(message, "s9"))
            $root.vec10.encode(message.s9, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
        return writer;
    };

    /**
     * Decodes a mat10 message from the specified reader or buffer.
     * @function decode
     * @memberof mat10
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {mat10} mat10
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    mat10.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mat10();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = $root.vec10.decode(reader, reader.uint32());
                break;
            case 2:
                message.s1 = $root.vec10.decode(reader, reader.uint32());
                break;
            case 3:
                message.s2 = $root.vec10.decode(reader, reader.uint32());
                break;
            case 4:
                message.s3 = $root.vec10.decode(reader, reader.uint32());
                break;
            case 5:
                message.s4 = $root.vec10.decode(reader, reader.uint32());
                break;
            case 6:
                message.s5 = $root.vec10.decode(reader, reader.uint32());
                break;
            case 7:
                message.s6 = $root.vec10.decode(reader, reader.uint32());
                break;
            case 8:
                message.s7 = $root.vec10.decode(reader, reader.uint32());
                break;
            case 9:
                message.s8 = $root.vec10.decode(reader, reader.uint32());
                break;
            case 10:
                message.s9 = $root.vec10.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return mat10;
})();

export const fmat10 = $root.fmat10 = (() => {

    /**
     * Properties of a fmat10.
     * @exports Ifmat10
     * @interface Ifmat10
     * @property {Ifvec10|null} [s0] fmat10 s0
     * @property {Ifvec10|null} [s1] fmat10 s1
     * @property {Ifvec10|null} [s2] fmat10 s2
     * @property {Ifvec10|null} [s3] fmat10 s3
     * @property {Ifvec10|null} [s4] fmat10 s4
     * @property {Ifvec10|null} [s5] fmat10 s5
     * @property {Ifvec10|null} [s6] fmat10 s6
     * @property {Ifvec10|null} [s7] fmat10 s7
     * @property {Ifvec10|null} [s8] fmat10 s8
     * @property {Ifvec10|null} [s9] fmat10 s9
     */

    /**
     * Constructs a new fmat10.
     * @exports fmat10
     * @classdesc Represents a fmat10.
     * @implements Ifmat10
     * @constructor
     * @param {Ifmat10=} [properties] Properties to set
     */
    function fmat10(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * fmat10 s0.
     * @member {Ifvec10|null|undefined} s0
     * @memberof fmat10
     * @instance
     */
    fmat10.prototype.s0 = null;

    /**
     * fmat10 s1.
     * @member {Ifvec10|null|undefined} s1
     * @memberof fmat10
     * @instance
     */
    fmat10.prototype.s1 = null;

    /**
     * fmat10 s2.
     * @member {Ifvec10|null|undefined} s2
     * @memberof fmat10
     * @instance
     */
    fmat10.prototype.s2 = null;

    /**
     * fmat10 s3.
     * @member {Ifvec10|null|undefined} s3
     * @memberof fmat10
     * @instance
     */
    fmat10.prototype.s3 = null;

    /**
     * fmat10 s4.
     * @member {Ifvec10|null|undefined} s4
     * @memberof fmat10
     * @instance
     */
    fmat10.prototype.s4 = null;

    /**
     * fmat10 s5.
     * @member {Ifvec10|null|undefined} s5
     * @memberof fmat10
     * @instance
     */
    fmat10.prototype.s5 = null;

    /**
     * fmat10 s6.
     * @member {Ifvec10|null|undefined} s6
     * @memberof fmat10
     * @instance
     */
    fmat10.prototype.s6 = null;

    /**
     * fmat10 s7.
     * @member {Ifvec10|null|undefined} s7
     * @memberof fmat10
     * @instance
     */
    fmat10.prototype.s7 = null;

    /**
     * fmat10 s8.
     * @member {Ifvec10|null|undefined} s8
     * @memberof fmat10
     * @instance
     */
    fmat10.prototype.s8 = null;

    /**
     * fmat10 s9.
     * @member {Ifvec10|null|undefined} s9
     * @memberof fmat10
     * @instance
     */
    fmat10.prototype.s9 = null;

    /**
     * Encodes the specified fmat10 message. Does not implicitly {@link fmat10.verify|verify} messages.
     * @function encode
     * @memberof fmat10
     * @static
     * @param {Ifmat10} message fmat10 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    fmat10.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            $root.fvec10.encode(message.s0, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            $root.fvec10.encode(message.s1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            $root.fvec10.encode(message.s2, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            $root.fvec10.encode(message.s3, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            $root.fvec10.encode(message.s4, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            $root.fvec10.encode(message.s5, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            $root.fvec10.encode(message.s6, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            $root.fvec10.encode(message.s7, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            $root.fvec10.encode(message.s8, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        if (message.s9 != null && Object.hasOwnProperty.call(message, "s9"))
            $root.fvec10.encode(message.s9, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
        return writer;
    };

    /**
     * Decodes a fmat10 message from the specified reader or buffer.
     * @function decode
     * @memberof fmat10
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {fmat10} fmat10
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    fmat10.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.fmat10();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = $root.fvec10.decode(reader, reader.uint32());
                break;
            case 2:
                message.s1 = $root.fvec10.decode(reader, reader.uint32());
                break;
            case 3:
                message.s2 = $root.fvec10.decode(reader, reader.uint32());
                break;
            case 4:
                message.s3 = $root.fvec10.decode(reader, reader.uint32());
                break;
            case 5:
                message.s4 = $root.fvec10.decode(reader, reader.uint32());
                break;
            case 6:
                message.s5 = $root.fvec10.decode(reader, reader.uint32());
                break;
            case 7:
                message.s6 = $root.fvec10.decode(reader, reader.uint32());
                break;
            case 8:
                message.s7 = $root.fvec10.decode(reader, reader.uint32());
                break;
            case 9:
                message.s8 = $root.fvec10.decode(reader, reader.uint32());
                break;
            case 10:
                message.s9 = $root.fvec10.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return fmat10;
})();

export const imat10 = $root.imat10 = (() => {

    /**
     * Properties of an imat10.
     * @exports Iimat10
     * @interface Iimat10
     * @property {Iivec10|null} [s0] imat10 s0
     * @property {Iivec10|null} [s1] imat10 s1
     * @property {Iivec10|null} [s2] imat10 s2
     * @property {Iivec10|null} [s3] imat10 s3
     * @property {Iivec10|null} [s4] imat10 s4
     * @property {Iivec10|null} [s5] imat10 s5
     * @property {Iivec10|null} [s6] imat10 s6
     * @property {Iivec10|null} [s7] imat10 s7
     * @property {Iivec10|null} [s8] imat10 s8
     * @property {Iivec10|null} [s9] imat10 s9
     */

    /**
     * Constructs a new imat10.
     * @exports imat10
     * @classdesc Represents an imat10.
     * @implements Iimat10
     * @constructor
     * @param {Iimat10=} [properties] Properties to set
     */
    function imat10(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * imat10 s0.
     * @member {Iivec10|null|undefined} s0
     * @memberof imat10
     * @instance
     */
    imat10.prototype.s0 = null;

    /**
     * imat10 s1.
     * @member {Iivec10|null|undefined} s1
     * @memberof imat10
     * @instance
     */
    imat10.prototype.s1 = null;

    /**
     * imat10 s2.
     * @member {Iivec10|null|undefined} s2
     * @memberof imat10
     * @instance
     */
    imat10.prototype.s2 = null;

    /**
     * imat10 s3.
     * @member {Iivec10|null|undefined} s3
     * @memberof imat10
     * @instance
     */
    imat10.prototype.s3 = null;

    /**
     * imat10 s4.
     * @member {Iivec10|null|undefined} s4
     * @memberof imat10
     * @instance
     */
    imat10.prototype.s4 = null;

    /**
     * imat10 s5.
     * @member {Iivec10|null|undefined} s5
     * @memberof imat10
     * @instance
     */
    imat10.prototype.s5 = null;

    /**
     * imat10 s6.
     * @member {Iivec10|null|undefined} s6
     * @memberof imat10
     * @instance
     */
    imat10.prototype.s6 = null;

    /**
     * imat10 s7.
     * @member {Iivec10|null|undefined} s7
     * @memberof imat10
     * @instance
     */
    imat10.prototype.s7 = null;

    /**
     * imat10 s8.
     * @member {Iivec10|null|undefined} s8
     * @memberof imat10
     * @instance
     */
    imat10.prototype.s8 = null;

    /**
     * imat10 s9.
     * @member {Iivec10|null|undefined} s9
     * @memberof imat10
     * @instance
     */
    imat10.prototype.s9 = null;

    /**
     * Encodes the specified imat10 message. Does not implicitly {@link imat10.verify|verify} messages.
     * @function encode
     * @memberof imat10
     * @static
     * @param {Iimat10} message imat10 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    imat10.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            $root.ivec10.encode(message.s0, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            $root.ivec10.encode(message.s1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            $root.ivec10.encode(message.s2, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            $root.ivec10.encode(message.s3, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            $root.ivec10.encode(message.s4, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            $root.ivec10.encode(message.s5, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            $root.ivec10.encode(message.s6, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            $root.ivec10.encode(message.s7, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            $root.ivec10.encode(message.s8, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        if (message.s9 != null && Object.hasOwnProperty.call(message, "s9"))
            $root.ivec10.encode(message.s9, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
        return writer;
    };

    /**
     * Decodes an imat10 message from the specified reader or buffer.
     * @function decode
     * @memberof imat10
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {imat10} imat10
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    imat10.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.imat10();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = $root.ivec10.decode(reader, reader.uint32());
                break;
            case 2:
                message.s1 = $root.ivec10.decode(reader, reader.uint32());
                break;
            case 3:
                message.s2 = $root.ivec10.decode(reader, reader.uint32());
                break;
            case 4:
                message.s3 = $root.ivec10.decode(reader, reader.uint32());
                break;
            case 5:
                message.s4 = $root.ivec10.decode(reader, reader.uint32());
                break;
            case 6:
                message.s5 = $root.ivec10.decode(reader, reader.uint32());
                break;
            case 7:
                message.s6 = $root.ivec10.decode(reader, reader.uint32());
                break;
            case 8:
                message.s7 = $root.ivec10.decode(reader, reader.uint32());
                break;
            case 9:
                message.s8 = $root.ivec10.decode(reader, reader.uint32());
                break;
            case 10:
                message.s9 = $root.ivec10.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return imat10;
})();

export const umat10 = $root.umat10 = (() => {

    /**
     * Properties of an umat10.
     * @exports Iumat10
     * @interface Iumat10
     * @property {Iuvec10|null} [s0] umat10 s0
     * @property {Iuvec10|null} [s1] umat10 s1
     * @property {Iuvec10|null} [s2] umat10 s2
     * @property {Iuvec10|null} [s3] umat10 s3
     * @property {Iuvec10|null} [s4] umat10 s4
     * @property {Iuvec10|null} [s5] umat10 s5
     * @property {Iuvec10|null} [s6] umat10 s6
     * @property {Iuvec10|null} [s7] umat10 s7
     * @property {Iuvec10|null} [s8] umat10 s8
     * @property {Iuvec10|null} [s9] umat10 s9
     */

    /**
     * Constructs a new umat10.
     * @exports umat10
     * @classdesc Represents an umat10.
     * @implements Iumat10
     * @constructor
     * @param {Iumat10=} [properties] Properties to set
     */
    function umat10(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * umat10 s0.
     * @member {Iuvec10|null|undefined} s0
     * @memberof umat10
     * @instance
     */
    umat10.prototype.s0 = null;

    /**
     * umat10 s1.
     * @member {Iuvec10|null|undefined} s1
     * @memberof umat10
     * @instance
     */
    umat10.prototype.s1 = null;

    /**
     * umat10 s2.
     * @member {Iuvec10|null|undefined} s2
     * @memberof umat10
     * @instance
     */
    umat10.prototype.s2 = null;

    /**
     * umat10 s3.
     * @member {Iuvec10|null|undefined} s3
     * @memberof umat10
     * @instance
     */
    umat10.prototype.s3 = null;

    /**
     * umat10 s4.
     * @member {Iuvec10|null|undefined} s4
     * @memberof umat10
     * @instance
     */
    umat10.prototype.s4 = null;

    /**
     * umat10 s5.
     * @member {Iuvec10|null|undefined} s5
     * @memberof umat10
     * @instance
     */
    umat10.prototype.s5 = null;

    /**
     * umat10 s6.
     * @member {Iuvec10|null|undefined} s6
     * @memberof umat10
     * @instance
     */
    umat10.prototype.s6 = null;

    /**
     * umat10 s7.
     * @member {Iuvec10|null|undefined} s7
     * @memberof umat10
     * @instance
     */
    umat10.prototype.s7 = null;

    /**
     * umat10 s8.
     * @member {Iuvec10|null|undefined} s8
     * @memberof umat10
     * @instance
     */
    umat10.prototype.s8 = null;

    /**
     * umat10 s9.
     * @member {Iuvec10|null|undefined} s9
     * @memberof umat10
     * @instance
     */
    umat10.prototype.s9 = null;

    /**
     * Encodes the specified umat10 message. Does not implicitly {@link umat10.verify|verify} messages.
     * @function encode
     * @memberof umat10
     * @static
     * @param {Iumat10} message umat10 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    umat10.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            $root.uvec10.encode(message.s0, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            $root.uvec10.encode(message.s1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            $root.uvec10.encode(message.s2, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            $root.uvec10.encode(message.s3, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            $root.uvec10.encode(message.s4, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            $root.uvec10.encode(message.s5, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            $root.uvec10.encode(message.s6, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            $root.uvec10.encode(message.s7, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            $root.uvec10.encode(message.s8, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        if (message.s9 != null && Object.hasOwnProperty.call(message, "s9"))
            $root.uvec10.encode(message.s9, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
        return writer;
    };

    /**
     * Decodes an umat10 message from the specified reader or buffer.
     * @function decode
     * @memberof umat10
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {umat10} umat10
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    umat10.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.umat10();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = $root.uvec10.decode(reader, reader.uint32());
                break;
            case 2:
                message.s1 = $root.uvec10.decode(reader, reader.uint32());
                break;
            case 3:
                message.s2 = $root.uvec10.decode(reader, reader.uint32());
                break;
            case 4:
                message.s3 = $root.uvec10.decode(reader, reader.uint32());
                break;
            case 5:
                message.s4 = $root.uvec10.decode(reader, reader.uint32());
                break;
            case 6:
                message.s5 = $root.uvec10.decode(reader, reader.uint32());
                break;
            case 7:
                message.s6 = $root.uvec10.decode(reader, reader.uint32());
                break;
            case 8:
                message.s7 = $root.uvec10.decode(reader, reader.uint32());
                break;
            case 9:
                message.s8 = $root.uvec10.decode(reader, reader.uint32());
                break;
            case 10:
                message.s9 = $root.uvec10.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return umat10;
})();

export const mat11 = $root.mat11 = (() => {

    /**
     * Properties of a mat11.
     * @exports Imat11
     * @interface Imat11
     * @property {Ivec11|null} [s0] mat11 s0
     * @property {Ivec11|null} [s1] mat11 s1
     * @property {Ivec11|null} [s2] mat11 s2
     * @property {Ivec11|null} [s3] mat11 s3
     * @property {Ivec11|null} [s4] mat11 s4
     * @property {Ivec11|null} [s5] mat11 s5
     * @property {Ivec11|null} [s6] mat11 s6
     * @property {Ivec11|null} [s7] mat11 s7
     * @property {Ivec11|null} [s8] mat11 s8
     * @property {Ivec11|null} [s9] mat11 s9
     * @property {Ivec11|null} [sa] mat11 sa
     */

    /**
     * Constructs a new mat11.
     * @exports mat11
     * @classdesc Represents a mat11.
     * @implements Imat11
     * @constructor
     * @param {Imat11=} [properties] Properties to set
     */
    function mat11(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * mat11 s0.
     * @member {Ivec11|null|undefined} s0
     * @memberof mat11
     * @instance
     */
    mat11.prototype.s0 = null;

    /**
     * mat11 s1.
     * @member {Ivec11|null|undefined} s1
     * @memberof mat11
     * @instance
     */
    mat11.prototype.s1 = null;

    /**
     * mat11 s2.
     * @member {Ivec11|null|undefined} s2
     * @memberof mat11
     * @instance
     */
    mat11.prototype.s2 = null;

    /**
     * mat11 s3.
     * @member {Ivec11|null|undefined} s3
     * @memberof mat11
     * @instance
     */
    mat11.prototype.s3 = null;

    /**
     * mat11 s4.
     * @member {Ivec11|null|undefined} s4
     * @memberof mat11
     * @instance
     */
    mat11.prototype.s4 = null;

    /**
     * mat11 s5.
     * @member {Ivec11|null|undefined} s5
     * @memberof mat11
     * @instance
     */
    mat11.prototype.s5 = null;

    /**
     * mat11 s6.
     * @member {Ivec11|null|undefined} s6
     * @memberof mat11
     * @instance
     */
    mat11.prototype.s6 = null;

    /**
     * mat11 s7.
     * @member {Ivec11|null|undefined} s7
     * @memberof mat11
     * @instance
     */
    mat11.prototype.s7 = null;

    /**
     * mat11 s8.
     * @member {Ivec11|null|undefined} s8
     * @memberof mat11
     * @instance
     */
    mat11.prototype.s8 = null;

    /**
     * mat11 s9.
     * @member {Ivec11|null|undefined} s9
     * @memberof mat11
     * @instance
     */
    mat11.prototype.s9 = null;

    /**
     * mat11 sa.
     * @member {Ivec11|null|undefined} sa
     * @memberof mat11
     * @instance
     */
    mat11.prototype.sa = null;

    /**
     * Encodes the specified mat11 message. Does not implicitly {@link mat11.verify|verify} messages.
     * @function encode
     * @memberof mat11
     * @static
     * @param {Imat11} message mat11 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    mat11.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            $root.vec11.encode(message.s0, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            $root.vec11.encode(message.s1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            $root.vec11.encode(message.s2, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            $root.vec11.encode(message.s3, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            $root.vec11.encode(message.s4, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            $root.vec11.encode(message.s5, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            $root.vec11.encode(message.s6, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            $root.vec11.encode(message.s7, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            $root.vec11.encode(message.s8, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        if (message.s9 != null && Object.hasOwnProperty.call(message, "s9"))
            $root.vec11.encode(message.s9, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
        if (message.sa != null && Object.hasOwnProperty.call(message, "sa"))
            $root.vec11.encode(message.sa, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
        return writer;
    };

    /**
     * Decodes a mat11 message from the specified reader or buffer.
     * @function decode
     * @memberof mat11
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {mat11} mat11
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    mat11.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mat11();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = $root.vec11.decode(reader, reader.uint32());
                break;
            case 2:
                message.s1 = $root.vec11.decode(reader, reader.uint32());
                break;
            case 3:
                message.s2 = $root.vec11.decode(reader, reader.uint32());
                break;
            case 4:
                message.s3 = $root.vec11.decode(reader, reader.uint32());
                break;
            case 5:
                message.s4 = $root.vec11.decode(reader, reader.uint32());
                break;
            case 6:
                message.s5 = $root.vec11.decode(reader, reader.uint32());
                break;
            case 7:
                message.s6 = $root.vec11.decode(reader, reader.uint32());
                break;
            case 8:
                message.s7 = $root.vec11.decode(reader, reader.uint32());
                break;
            case 9:
                message.s8 = $root.vec11.decode(reader, reader.uint32());
                break;
            case 10:
                message.s9 = $root.vec11.decode(reader, reader.uint32());
                break;
            case 11:
                message.sa = $root.vec11.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return mat11;
})();

export const fmat11 = $root.fmat11 = (() => {

    /**
     * Properties of a fmat11.
     * @exports Ifmat11
     * @interface Ifmat11
     * @property {Ifvec11|null} [s0] fmat11 s0
     * @property {Ifvec11|null} [s1] fmat11 s1
     * @property {Ifvec11|null} [s2] fmat11 s2
     * @property {Ifvec11|null} [s3] fmat11 s3
     * @property {Ifvec11|null} [s4] fmat11 s4
     * @property {Ifvec11|null} [s5] fmat11 s5
     * @property {Ifvec11|null} [s6] fmat11 s6
     * @property {Ifvec11|null} [s7] fmat11 s7
     * @property {Ifvec11|null} [s8] fmat11 s8
     * @property {Ifvec11|null} [s9] fmat11 s9
     * @property {Ifvec11|null} [sa] fmat11 sa
     */

    /**
     * Constructs a new fmat11.
     * @exports fmat11
     * @classdesc Represents a fmat11.
     * @implements Ifmat11
     * @constructor
     * @param {Ifmat11=} [properties] Properties to set
     */
    function fmat11(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * fmat11 s0.
     * @member {Ifvec11|null|undefined} s0
     * @memberof fmat11
     * @instance
     */
    fmat11.prototype.s0 = null;

    /**
     * fmat11 s1.
     * @member {Ifvec11|null|undefined} s1
     * @memberof fmat11
     * @instance
     */
    fmat11.prototype.s1 = null;

    /**
     * fmat11 s2.
     * @member {Ifvec11|null|undefined} s2
     * @memberof fmat11
     * @instance
     */
    fmat11.prototype.s2 = null;

    /**
     * fmat11 s3.
     * @member {Ifvec11|null|undefined} s3
     * @memberof fmat11
     * @instance
     */
    fmat11.prototype.s3 = null;

    /**
     * fmat11 s4.
     * @member {Ifvec11|null|undefined} s4
     * @memberof fmat11
     * @instance
     */
    fmat11.prototype.s4 = null;

    /**
     * fmat11 s5.
     * @member {Ifvec11|null|undefined} s5
     * @memberof fmat11
     * @instance
     */
    fmat11.prototype.s5 = null;

    /**
     * fmat11 s6.
     * @member {Ifvec11|null|undefined} s6
     * @memberof fmat11
     * @instance
     */
    fmat11.prototype.s6 = null;

    /**
     * fmat11 s7.
     * @member {Ifvec11|null|undefined} s7
     * @memberof fmat11
     * @instance
     */
    fmat11.prototype.s7 = null;

    /**
     * fmat11 s8.
     * @member {Ifvec11|null|undefined} s8
     * @memberof fmat11
     * @instance
     */
    fmat11.prototype.s8 = null;

    /**
     * fmat11 s9.
     * @member {Ifvec11|null|undefined} s9
     * @memberof fmat11
     * @instance
     */
    fmat11.prototype.s9 = null;

    /**
     * fmat11 sa.
     * @member {Ifvec11|null|undefined} sa
     * @memberof fmat11
     * @instance
     */
    fmat11.prototype.sa = null;

    /**
     * Encodes the specified fmat11 message. Does not implicitly {@link fmat11.verify|verify} messages.
     * @function encode
     * @memberof fmat11
     * @static
     * @param {Ifmat11} message fmat11 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    fmat11.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            $root.fvec11.encode(message.s0, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            $root.fvec11.encode(message.s1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            $root.fvec11.encode(message.s2, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            $root.fvec11.encode(message.s3, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            $root.fvec11.encode(message.s4, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            $root.fvec11.encode(message.s5, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            $root.fvec11.encode(message.s6, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            $root.fvec11.encode(message.s7, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            $root.fvec11.encode(message.s8, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        if (message.s9 != null && Object.hasOwnProperty.call(message, "s9"))
            $root.fvec11.encode(message.s9, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
        if (message.sa != null && Object.hasOwnProperty.call(message, "sa"))
            $root.fvec11.encode(message.sa, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
        return writer;
    };

    /**
     * Decodes a fmat11 message from the specified reader or buffer.
     * @function decode
     * @memberof fmat11
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {fmat11} fmat11
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    fmat11.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.fmat11();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = $root.fvec11.decode(reader, reader.uint32());
                break;
            case 2:
                message.s1 = $root.fvec11.decode(reader, reader.uint32());
                break;
            case 3:
                message.s2 = $root.fvec11.decode(reader, reader.uint32());
                break;
            case 4:
                message.s3 = $root.fvec11.decode(reader, reader.uint32());
                break;
            case 5:
                message.s4 = $root.fvec11.decode(reader, reader.uint32());
                break;
            case 6:
                message.s5 = $root.fvec11.decode(reader, reader.uint32());
                break;
            case 7:
                message.s6 = $root.fvec11.decode(reader, reader.uint32());
                break;
            case 8:
                message.s7 = $root.fvec11.decode(reader, reader.uint32());
                break;
            case 9:
                message.s8 = $root.fvec11.decode(reader, reader.uint32());
                break;
            case 10:
                message.s9 = $root.fvec11.decode(reader, reader.uint32());
                break;
            case 11:
                message.sa = $root.fvec11.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return fmat11;
})();

export const imat11 = $root.imat11 = (() => {

    /**
     * Properties of an imat11.
     * @exports Iimat11
     * @interface Iimat11
     * @property {Iivec11|null} [s0] imat11 s0
     * @property {Iivec11|null} [s1] imat11 s1
     * @property {Iivec11|null} [s2] imat11 s2
     * @property {Iivec11|null} [s3] imat11 s3
     * @property {Iivec11|null} [s4] imat11 s4
     * @property {Iivec11|null} [s5] imat11 s5
     * @property {Iivec11|null} [s6] imat11 s6
     * @property {Iivec11|null} [s7] imat11 s7
     * @property {Iivec11|null} [s8] imat11 s8
     * @property {Iivec11|null} [s9] imat11 s9
     * @property {Iivec11|null} [sa] imat11 sa
     */

    /**
     * Constructs a new imat11.
     * @exports imat11
     * @classdesc Represents an imat11.
     * @implements Iimat11
     * @constructor
     * @param {Iimat11=} [properties] Properties to set
     */
    function imat11(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * imat11 s0.
     * @member {Iivec11|null|undefined} s0
     * @memberof imat11
     * @instance
     */
    imat11.prototype.s0 = null;

    /**
     * imat11 s1.
     * @member {Iivec11|null|undefined} s1
     * @memberof imat11
     * @instance
     */
    imat11.prototype.s1 = null;

    /**
     * imat11 s2.
     * @member {Iivec11|null|undefined} s2
     * @memberof imat11
     * @instance
     */
    imat11.prototype.s2 = null;

    /**
     * imat11 s3.
     * @member {Iivec11|null|undefined} s3
     * @memberof imat11
     * @instance
     */
    imat11.prototype.s3 = null;

    /**
     * imat11 s4.
     * @member {Iivec11|null|undefined} s4
     * @memberof imat11
     * @instance
     */
    imat11.prototype.s4 = null;

    /**
     * imat11 s5.
     * @member {Iivec11|null|undefined} s5
     * @memberof imat11
     * @instance
     */
    imat11.prototype.s5 = null;

    /**
     * imat11 s6.
     * @member {Iivec11|null|undefined} s6
     * @memberof imat11
     * @instance
     */
    imat11.prototype.s6 = null;

    /**
     * imat11 s7.
     * @member {Iivec11|null|undefined} s7
     * @memberof imat11
     * @instance
     */
    imat11.prototype.s7 = null;

    /**
     * imat11 s8.
     * @member {Iivec11|null|undefined} s8
     * @memberof imat11
     * @instance
     */
    imat11.prototype.s8 = null;

    /**
     * imat11 s9.
     * @member {Iivec11|null|undefined} s9
     * @memberof imat11
     * @instance
     */
    imat11.prototype.s9 = null;

    /**
     * imat11 sa.
     * @member {Iivec11|null|undefined} sa
     * @memberof imat11
     * @instance
     */
    imat11.prototype.sa = null;

    /**
     * Encodes the specified imat11 message. Does not implicitly {@link imat11.verify|verify} messages.
     * @function encode
     * @memberof imat11
     * @static
     * @param {Iimat11} message imat11 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    imat11.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            $root.ivec11.encode(message.s0, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            $root.ivec11.encode(message.s1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            $root.ivec11.encode(message.s2, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            $root.ivec11.encode(message.s3, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            $root.ivec11.encode(message.s4, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            $root.ivec11.encode(message.s5, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            $root.ivec11.encode(message.s6, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            $root.ivec11.encode(message.s7, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            $root.ivec11.encode(message.s8, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        if (message.s9 != null && Object.hasOwnProperty.call(message, "s9"))
            $root.ivec11.encode(message.s9, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
        if (message.sa != null && Object.hasOwnProperty.call(message, "sa"))
            $root.ivec11.encode(message.sa, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
        return writer;
    };

    /**
     * Decodes an imat11 message from the specified reader or buffer.
     * @function decode
     * @memberof imat11
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {imat11} imat11
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    imat11.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.imat11();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = $root.ivec11.decode(reader, reader.uint32());
                break;
            case 2:
                message.s1 = $root.ivec11.decode(reader, reader.uint32());
                break;
            case 3:
                message.s2 = $root.ivec11.decode(reader, reader.uint32());
                break;
            case 4:
                message.s3 = $root.ivec11.decode(reader, reader.uint32());
                break;
            case 5:
                message.s4 = $root.ivec11.decode(reader, reader.uint32());
                break;
            case 6:
                message.s5 = $root.ivec11.decode(reader, reader.uint32());
                break;
            case 7:
                message.s6 = $root.ivec11.decode(reader, reader.uint32());
                break;
            case 8:
                message.s7 = $root.ivec11.decode(reader, reader.uint32());
                break;
            case 9:
                message.s8 = $root.ivec11.decode(reader, reader.uint32());
                break;
            case 10:
                message.s9 = $root.ivec11.decode(reader, reader.uint32());
                break;
            case 11:
                message.sa = $root.ivec11.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return imat11;
})();

export const umat11 = $root.umat11 = (() => {

    /**
     * Properties of an umat11.
     * @exports Iumat11
     * @interface Iumat11
     * @property {Iuvec11|null} [s0] umat11 s0
     * @property {Iuvec11|null} [s1] umat11 s1
     * @property {Iuvec11|null} [s2] umat11 s2
     * @property {Iuvec11|null} [s3] umat11 s3
     * @property {Iuvec11|null} [s4] umat11 s4
     * @property {Iuvec11|null} [s5] umat11 s5
     * @property {Iuvec11|null} [s6] umat11 s6
     * @property {Iuvec11|null} [s7] umat11 s7
     * @property {Iuvec11|null} [s8] umat11 s8
     * @property {Iuvec11|null} [s9] umat11 s9
     * @property {Iuvec11|null} [sa] umat11 sa
     */

    /**
     * Constructs a new umat11.
     * @exports umat11
     * @classdesc Represents an umat11.
     * @implements Iumat11
     * @constructor
     * @param {Iumat11=} [properties] Properties to set
     */
    function umat11(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * umat11 s0.
     * @member {Iuvec11|null|undefined} s0
     * @memberof umat11
     * @instance
     */
    umat11.prototype.s0 = null;

    /**
     * umat11 s1.
     * @member {Iuvec11|null|undefined} s1
     * @memberof umat11
     * @instance
     */
    umat11.prototype.s1 = null;

    /**
     * umat11 s2.
     * @member {Iuvec11|null|undefined} s2
     * @memberof umat11
     * @instance
     */
    umat11.prototype.s2 = null;

    /**
     * umat11 s3.
     * @member {Iuvec11|null|undefined} s3
     * @memberof umat11
     * @instance
     */
    umat11.prototype.s3 = null;

    /**
     * umat11 s4.
     * @member {Iuvec11|null|undefined} s4
     * @memberof umat11
     * @instance
     */
    umat11.prototype.s4 = null;

    /**
     * umat11 s5.
     * @member {Iuvec11|null|undefined} s5
     * @memberof umat11
     * @instance
     */
    umat11.prototype.s5 = null;

    /**
     * umat11 s6.
     * @member {Iuvec11|null|undefined} s6
     * @memberof umat11
     * @instance
     */
    umat11.prototype.s6 = null;

    /**
     * umat11 s7.
     * @member {Iuvec11|null|undefined} s7
     * @memberof umat11
     * @instance
     */
    umat11.prototype.s7 = null;

    /**
     * umat11 s8.
     * @member {Iuvec11|null|undefined} s8
     * @memberof umat11
     * @instance
     */
    umat11.prototype.s8 = null;

    /**
     * umat11 s9.
     * @member {Iuvec11|null|undefined} s9
     * @memberof umat11
     * @instance
     */
    umat11.prototype.s9 = null;

    /**
     * umat11 sa.
     * @member {Iuvec11|null|undefined} sa
     * @memberof umat11
     * @instance
     */
    umat11.prototype.sa = null;

    /**
     * Encodes the specified umat11 message. Does not implicitly {@link umat11.verify|verify} messages.
     * @function encode
     * @memberof umat11
     * @static
     * @param {Iumat11} message umat11 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    umat11.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            $root.uvec11.encode(message.s0, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            $root.uvec11.encode(message.s1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            $root.uvec11.encode(message.s2, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            $root.uvec11.encode(message.s3, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            $root.uvec11.encode(message.s4, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            $root.uvec11.encode(message.s5, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            $root.uvec11.encode(message.s6, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            $root.uvec11.encode(message.s7, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            $root.uvec11.encode(message.s8, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        if (message.s9 != null && Object.hasOwnProperty.call(message, "s9"))
            $root.uvec11.encode(message.s9, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
        if (message.sa != null && Object.hasOwnProperty.call(message, "sa"))
            $root.uvec11.encode(message.sa, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
        return writer;
    };

    /**
     * Decodes an umat11 message from the specified reader or buffer.
     * @function decode
     * @memberof umat11
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {umat11} umat11
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    umat11.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.umat11();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = $root.uvec11.decode(reader, reader.uint32());
                break;
            case 2:
                message.s1 = $root.uvec11.decode(reader, reader.uint32());
                break;
            case 3:
                message.s2 = $root.uvec11.decode(reader, reader.uint32());
                break;
            case 4:
                message.s3 = $root.uvec11.decode(reader, reader.uint32());
                break;
            case 5:
                message.s4 = $root.uvec11.decode(reader, reader.uint32());
                break;
            case 6:
                message.s5 = $root.uvec11.decode(reader, reader.uint32());
                break;
            case 7:
                message.s6 = $root.uvec11.decode(reader, reader.uint32());
                break;
            case 8:
                message.s7 = $root.uvec11.decode(reader, reader.uint32());
                break;
            case 9:
                message.s8 = $root.uvec11.decode(reader, reader.uint32());
                break;
            case 10:
                message.s9 = $root.uvec11.decode(reader, reader.uint32());
                break;
            case 11:
                message.sa = $root.uvec11.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return umat11;
})();

export const mat12 = $root.mat12 = (() => {

    /**
     * Properties of a mat12.
     * @exports Imat12
     * @interface Imat12
     * @property {Ivec12|null} [s0] mat12 s0
     * @property {Ivec12|null} [s1] mat12 s1
     * @property {Ivec12|null} [s2] mat12 s2
     * @property {Ivec12|null} [s3] mat12 s3
     * @property {Ivec12|null} [s4] mat12 s4
     * @property {Ivec12|null} [s5] mat12 s5
     * @property {Ivec12|null} [s6] mat12 s6
     * @property {Ivec12|null} [s7] mat12 s7
     * @property {Ivec12|null} [s8] mat12 s8
     * @property {Ivec12|null} [s9] mat12 s9
     * @property {Ivec12|null} [sa] mat12 sa
     * @property {Ivec12|null} [sb] mat12 sb
     */

    /**
     * Constructs a new mat12.
     * @exports mat12
     * @classdesc Represents a mat12.
     * @implements Imat12
     * @constructor
     * @param {Imat12=} [properties] Properties to set
     */
    function mat12(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * mat12 s0.
     * @member {Ivec12|null|undefined} s0
     * @memberof mat12
     * @instance
     */
    mat12.prototype.s0 = null;

    /**
     * mat12 s1.
     * @member {Ivec12|null|undefined} s1
     * @memberof mat12
     * @instance
     */
    mat12.prototype.s1 = null;

    /**
     * mat12 s2.
     * @member {Ivec12|null|undefined} s2
     * @memberof mat12
     * @instance
     */
    mat12.prototype.s2 = null;

    /**
     * mat12 s3.
     * @member {Ivec12|null|undefined} s3
     * @memberof mat12
     * @instance
     */
    mat12.prototype.s3 = null;

    /**
     * mat12 s4.
     * @member {Ivec12|null|undefined} s4
     * @memberof mat12
     * @instance
     */
    mat12.prototype.s4 = null;

    /**
     * mat12 s5.
     * @member {Ivec12|null|undefined} s5
     * @memberof mat12
     * @instance
     */
    mat12.prototype.s5 = null;

    /**
     * mat12 s6.
     * @member {Ivec12|null|undefined} s6
     * @memberof mat12
     * @instance
     */
    mat12.prototype.s6 = null;

    /**
     * mat12 s7.
     * @member {Ivec12|null|undefined} s7
     * @memberof mat12
     * @instance
     */
    mat12.prototype.s7 = null;

    /**
     * mat12 s8.
     * @member {Ivec12|null|undefined} s8
     * @memberof mat12
     * @instance
     */
    mat12.prototype.s8 = null;

    /**
     * mat12 s9.
     * @member {Ivec12|null|undefined} s9
     * @memberof mat12
     * @instance
     */
    mat12.prototype.s9 = null;

    /**
     * mat12 sa.
     * @member {Ivec12|null|undefined} sa
     * @memberof mat12
     * @instance
     */
    mat12.prototype.sa = null;

    /**
     * mat12 sb.
     * @member {Ivec12|null|undefined} sb
     * @memberof mat12
     * @instance
     */
    mat12.prototype.sb = null;

    /**
     * Encodes the specified mat12 message. Does not implicitly {@link mat12.verify|verify} messages.
     * @function encode
     * @memberof mat12
     * @static
     * @param {Imat12} message mat12 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    mat12.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            $root.vec12.encode(message.s0, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            $root.vec12.encode(message.s1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            $root.vec12.encode(message.s2, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            $root.vec12.encode(message.s3, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            $root.vec12.encode(message.s4, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            $root.vec12.encode(message.s5, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            $root.vec12.encode(message.s6, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            $root.vec12.encode(message.s7, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            $root.vec12.encode(message.s8, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        if (message.s9 != null && Object.hasOwnProperty.call(message, "s9"))
            $root.vec12.encode(message.s9, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
        if (message.sa != null && Object.hasOwnProperty.call(message, "sa"))
            $root.vec12.encode(message.sa, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
        if (message.sb != null && Object.hasOwnProperty.call(message, "sb"))
            $root.vec12.encode(message.sb, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
        return writer;
    };

    /**
     * Decodes a mat12 message from the specified reader or buffer.
     * @function decode
     * @memberof mat12
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {mat12} mat12
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    mat12.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mat12();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = $root.vec12.decode(reader, reader.uint32());
                break;
            case 2:
                message.s1 = $root.vec12.decode(reader, reader.uint32());
                break;
            case 3:
                message.s2 = $root.vec12.decode(reader, reader.uint32());
                break;
            case 4:
                message.s3 = $root.vec12.decode(reader, reader.uint32());
                break;
            case 5:
                message.s4 = $root.vec12.decode(reader, reader.uint32());
                break;
            case 6:
                message.s5 = $root.vec12.decode(reader, reader.uint32());
                break;
            case 7:
                message.s6 = $root.vec12.decode(reader, reader.uint32());
                break;
            case 8:
                message.s7 = $root.vec12.decode(reader, reader.uint32());
                break;
            case 9:
                message.s8 = $root.vec12.decode(reader, reader.uint32());
                break;
            case 10:
                message.s9 = $root.vec12.decode(reader, reader.uint32());
                break;
            case 11:
                message.sa = $root.vec12.decode(reader, reader.uint32());
                break;
            case 12:
                message.sb = $root.vec12.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return mat12;
})();

export const fmat12 = $root.fmat12 = (() => {

    /**
     * Properties of a fmat12.
     * @exports Ifmat12
     * @interface Ifmat12
     * @property {Ifvec12|null} [s0] fmat12 s0
     * @property {Ifvec12|null} [s1] fmat12 s1
     * @property {Ifvec12|null} [s2] fmat12 s2
     * @property {Ifvec12|null} [s3] fmat12 s3
     * @property {Ifvec12|null} [s4] fmat12 s4
     * @property {Ifvec12|null} [s5] fmat12 s5
     * @property {Ifvec12|null} [s6] fmat12 s6
     * @property {Ifvec12|null} [s7] fmat12 s7
     * @property {Ifvec12|null} [s8] fmat12 s8
     * @property {Ifvec12|null} [s9] fmat12 s9
     * @property {Ifvec12|null} [sa] fmat12 sa
     * @property {Ifvec12|null} [sb] fmat12 sb
     */

    /**
     * Constructs a new fmat12.
     * @exports fmat12
     * @classdesc Represents a fmat12.
     * @implements Ifmat12
     * @constructor
     * @param {Ifmat12=} [properties] Properties to set
     */
    function fmat12(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * fmat12 s0.
     * @member {Ifvec12|null|undefined} s0
     * @memberof fmat12
     * @instance
     */
    fmat12.prototype.s0 = null;

    /**
     * fmat12 s1.
     * @member {Ifvec12|null|undefined} s1
     * @memberof fmat12
     * @instance
     */
    fmat12.prototype.s1 = null;

    /**
     * fmat12 s2.
     * @member {Ifvec12|null|undefined} s2
     * @memberof fmat12
     * @instance
     */
    fmat12.prototype.s2 = null;

    /**
     * fmat12 s3.
     * @member {Ifvec12|null|undefined} s3
     * @memberof fmat12
     * @instance
     */
    fmat12.prototype.s3 = null;

    /**
     * fmat12 s4.
     * @member {Ifvec12|null|undefined} s4
     * @memberof fmat12
     * @instance
     */
    fmat12.prototype.s4 = null;

    /**
     * fmat12 s5.
     * @member {Ifvec12|null|undefined} s5
     * @memberof fmat12
     * @instance
     */
    fmat12.prototype.s5 = null;

    /**
     * fmat12 s6.
     * @member {Ifvec12|null|undefined} s6
     * @memberof fmat12
     * @instance
     */
    fmat12.prototype.s6 = null;

    /**
     * fmat12 s7.
     * @member {Ifvec12|null|undefined} s7
     * @memberof fmat12
     * @instance
     */
    fmat12.prototype.s7 = null;

    /**
     * fmat12 s8.
     * @member {Ifvec12|null|undefined} s8
     * @memberof fmat12
     * @instance
     */
    fmat12.prototype.s8 = null;

    /**
     * fmat12 s9.
     * @member {Ifvec12|null|undefined} s9
     * @memberof fmat12
     * @instance
     */
    fmat12.prototype.s9 = null;

    /**
     * fmat12 sa.
     * @member {Ifvec12|null|undefined} sa
     * @memberof fmat12
     * @instance
     */
    fmat12.prototype.sa = null;

    /**
     * fmat12 sb.
     * @member {Ifvec12|null|undefined} sb
     * @memberof fmat12
     * @instance
     */
    fmat12.prototype.sb = null;

    /**
     * Encodes the specified fmat12 message. Does not implicitly {@link fmat12.verify|verify} messages.
     * @function encode
     * @memberof fmat12
     * @static
     * @param {Ifmat12} message fmat12 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    fmat12.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            $root.fvec12.encode(message.s0, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            $root.fvec12.encode(message.s1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            $root.fvec12.encode(message.s2, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            $root.fvec12.encode(message.s3, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            $root.fvec12.encode(message.s4, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            $root.fvec12.encode(message.s5, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            $root.fvec12.encode(message.s6, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            $root.fvec12.encode(message.s7, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            $root.fvec12.encode(message.s8, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        if (message.s9 != null && Object.hasOwnProperty.call(message, "s9"))
            $root.fvec12.encode(message.s9, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
        if (message.sa != null && Object.hasOwnProperty.call(message, "sa"))
            $root.fvec12.encode(message.sa, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
        if (message.sb != null && Object.hasOwnProperty.call(message, "sb"))
            $root.fvec12.encode(message.sb, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
        return writer;
    };

    /**
     * Decodes a fmat12 message from the specified reader or buffer.
     * @function decode
     * @memberof fmat12
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {fmat12} fmat12
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    fmat12.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.fmat12();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = $root.fvec12.decode(reader, reader.uint32());
                break;
            case 2:
                message.s1 = $root.fvec12.decode(reader, reader.uint32());
                break;
            case 3:
                message.s2 = $root.fvec12.decode(reader, reader.uint32());
                break;
            case 4:
                message.s3 = $root.fvec12.decode(reader, reader.uint32());
                break;
            case 5:
                message.s4 = $root.fvec12.decode(reader, reader.uint32());
                break;
            case 6:
                message.s5 = $root.fvec12.decode(reader, reader.uint32());
                break;
            case 7:
                message.s6 = $root.fvec12.decode(reader, reader.uint32());
                break;
            case 8:
                message.s7 = $root.fvec12.decode(reader, reader.uint32());
                break;
            case 9:
                message.s8 = $root.fvec12.decode(reader, reader.uint32());
                break;
            case 10:
                message.s9 = $root.fvec12.decode(reader, reader.uint32());
                break;
            case 11:
                message.sa = $root.fvec12.decode(reader, reader.uint32());
                break;
            case 12:
                message.sb = $root.fvec12.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return fmat12;
})();

export const imat12 = $root.imat12 = (() => {

    /**
     * Properties of an imat12.
     * @exports Iimat12
     * @interface Iimat12
     * @property {Iivec12|null} [s0] imat12 s0
     * @property {Iivec12|null} [s1] imat12 s1
     * @property {Iivec12|null} [s2] imat12 s2
     * @property {Iivec12|null} [s3] imat12 s3
     * @property {Iivec12|null} [s4] imat12 s4
     * @property {Iivec12|null} [s5] imat12 s5
     * @property {Iivec12|null} [s6] imat12 s6
     * @property {Iivec12|null} [s7] imat12 s7
     * @property {Iivec12|null} [s8] imat12 s8
     * @property {Iivec12|null} [s9] imat12 s9
     * @property {Iivec12|null} [sa] imat12 sa
     * @property {Iivec12|null} [sb] imat12 sb
     */

    /**
     * Constructs a new imat12.
     * @exports imat12
     * @classdesc Represents an imat12.
     * @implements Iimat12
     * @constructor
     * @param {Iimat12=} [properties] Properties to set
     */
    function imat12(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * imat12 s0.
     * @member {Iivec12|null|undefined} s0
     * @memberof imat12
     * @instance
     */
    imat12.prototype.s0 = null;

    /**
     * imat12 s1.
     * @member {Iivec12|null|undefined} s1
     * @memberof imat12
     * @instance
     */
    imat12.prototype.s1 = null;

    /**
     * imat12 s2.
     * @member {Iivec12|null|undefined} s2
     * @memberof imat12
     * @instance
     */
    imat12.prototype.s2 = null;

    /**
     * imat12 s3.
     * @member {Iivec12|null|undefined} s3
     * @memberof imat12
     * @instance
     */
    imat12.prototype.s3 = null;

    /**
     * imat12 s4.
     * @member {Iivec12|null|undefined} s4
     * @memberof imat12
     * @instance
     */
    imat12.prototype.s4 = null;

    /**
     * imat12 s5.
     * @member {Iivec12|null|undefined} s5
     * @memberof imat12
     * @instance
     */
    imat12.prototype.s5 = null;

    /**
     * imat12 s6.
     * @member {Iivec12|null|undefined} s6
     * @memberof imat12
     * @instance
     */
    imat12.prototype.s6 = null;

    /**
     * imat12 s7.
     * @member {Iivec12|null|undefined} s7
     * @memberof imat12
     * @instance
     */
    imat12.prototype.s7 = null;

    /**
     * imat12 s8.
     * @member {Iivec12|null|undefined} s8
     * @memberof imat12
     * @instance
     */
    imat12.prototype.s8 = null;

    /**
     * imat12 s9.
     * @member {Iivec12|null|undefined} s9
     * @memberof imat12
     * @instance
     */
    imat12.prototype.s9 = null;

    /**
     * imat12 sa.
     * @member {Iivec12|null|undefined} sa
     * @memberof imat12
     * @instance
     */
    imat12.prototype.sa = null;

    /**
     * imat12 sb.
     * @member {Iivec12|null|undefined} sb
     * @memberof imat12
     * @instance
     */
    imat12.prototype.sb = null;

    /**
     * Encodes the specified imat12 message. Does not implicitly {@link imat12.verify|verify} messages.
     * @function encode
     * @memberof imat12
     * @static
     * @param {Iimat12} message imat12 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    imat12.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            $root.ivec12.encode(message.s0, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            $root.ivec12.encode(message.s1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            $root.ivec12.encode(message.s2, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            $root.ivec12.encode(message.s3, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            $root.ivec12.encode(message.s4, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            $root.ivec12.encode(message.s5, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            $root.ivec12.encode(message.s6, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            $root.ivec12.encode(message.s7, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            $root.ivec12.encode(message.s8, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        if (message.s9 != null && Object.hasOwnProperty.call(message, "s9"))
            $root.ivec12.encode(message.s9, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
        if (message.sa != null && Object.hasOwnProperty.call(message, "sa"))
            $root.ivec12.encode(message.sa, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
        if (message.sb != null && Object.hasOwnProperty.call(message, "sb"))
            $root.ivec12.encode(message.sb, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
        return writer;
    };

    /**
     * Decodes an imat12 message from the specified reader or buffer.
     * @function decode
     * @memberof imat12
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {imat12} imat12
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    imat12.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.imat12();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = $root.ivec12.decode(reader, reader.uint32());
                break;
            case 2:
                message.s1 = $root.ivec12.decode(reader, reader.uint32());
                break;
            case 3:
                message.s2 = $root.ivec12.decode(reader, reader.uint32());
                break;
            case 4:
                message.s3 = $root.ivec12.decode(reader, reader.uint32());
                break;
            case 5:
                message.s4 = $root.ivec12.decode(reader, reader.uint32());
                break;
            case 6:
                message.s5 = $root.ivec12.decode(reader, reader.uint32());
                break;
            case 7:
                message.s6 = $root.ivec12.decode(reader, reader.uint32());
                break;
            case 8:
                message.s7 = $root.ivec12.decode(reader, reader.uint32());
                break;
            case 9:
                message.s8 = $root.ivec12.decode(reader, reader.uint32());
                break;
            case 10:
                message.s9 = $root.ivec12.decode(reader, reader.uint32());
                break;
            case 11:
                message.sa = $root.ivec12.decode(reader, reader.uint32());
                break;
            case 12:
                message.sb = $root.ivec12.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return imat12;
})();

export const umat12 = $root.umat12 = (() => {

    /**
     * Properties of an umat12.
     * @exports Iumat12
     * @interface Iumat12
     * @property {Iuvec12|null} [s0] umat12 s0
     * @property {Iuvec12|null} [s1] umat12 s1
     * @property {Iuvec12|null} [s2] umat12 s2
     * @property {Iuvec12|null} [s3] umat12 s3
     * @property {Iuvec12|null} [s4] umat12 s4
     * @property {Iuvec12|null} [s5] umat12 s5
     * @property {Iuvec12|null} [s6] umat12 s6
     * @property {Iuvec12|null} [s7] umat12 s7
     * @property {Iuvec12|null} [s8] umat12 s8
     * @property {Iuvec12|null} [s9] umat12 s9
     * @property {Iuvec12|null} [sa] umat12 sa
     * @property {Iuvec12|null} [sb] umat12 sb
     */

    /**
     * Constructs a new umat12.
     * @exports umat12
     * @classdesc Represents an umat12.
     * @implements Iumat12
     * @constructor
     * @param {Iumat12=} [properties] Properties to set
     */
    function umat12(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * umat12 s0.
     * @member {Iuvec12|null|undefined} s0
     * @memberof umat12
     * @instance
     */
    umat12.prototype.s0 = null;

    /**
     * umat12 s1.
     * @member {Iuvec12|null|undefined} s1
     * @memberof umat12
     * @instance
     */
    umat12.prototype.s1 = null;

    /**
     * umat12 s2.
     * @member {Iuvec12|null|undefined} s2
     * @memberof umat12
     * @instance
     */
    umat12.prototype.s2 = null;

    /**
     * umat12 s3.
     * @member {Iuvec12|null|undefined} s3
     * @memberof umat12
     * @instance
     */
    umat12.prototype.s3 = null;

    /**
     * umat12 s4.
     * @member {Iuvec12|null|undefined} s4
     * @memberof umat12
     * @instance
     */
    umat12.prototype.s4 = null;

    /**
     * umat12 s5.
     * @member {Iuvec12|null|undefined} s5
     * @memberof umat12
     * @instance
     */
    umat12.prototype.s5 = null;

    /**
     * umat12 s6.
     * @member {Iuvec12|null|undefined} s6
     * @memberof umat12
     * @instance
     */
    umat12.prototype.s6 = null;

    /**
     * umat12 s7.
     * @member {Iuvec12|null|undefined} s7
     * @memberof umat12
     * @instance
     */
    umat12.prototype.s7 = null;

    /**
     * umat12 s8.
     * @member {Iuvec12|null|undefined} s8
     * @memberof umat12
     * @instance
     */
    umat12.prototype.s8 = null;

    /**
     * umat12 s9.
     * @member {Iuvec12|null|undefined} s9
     * @memberof umat12
     * @instance
     */
    umat12.prototype.s9 = null;

    /**
     * umat12 sa.
     * @member {Iuvec12|null|undefined} sa
     * @memberof umat12
     * @instance
     */
    umat12.prototype.sa = null;

    /**
     * umat12 sb.
     * @member {Iuvec12|null|undefined} sb
     * @memberof umat12
     * @instance
     */
    umat12.prototype.sb = null;

    /**
     * Encodes the specified umat12 message. Does not implicitly {@link umat12.verify|verify} messages.
     * @function encode
     * @memberof umat12
     * @static
     * @param {Iumat12} message umat12 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    umat12.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            $root.uvec12.encode(message.s0, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            $root.uvec12.encode(message.s1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            $root.uvec12.encode(message.s2, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            $root.uvec12.encode(message.s3, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            $root.uvec12.encode(message.s4, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            $root.uvec12.encode(message.s5, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            $root.uvec12.encode(message.s6, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            $root.uvec12.encode(message.s7, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            $root.uvec12.encode(message.s8, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        if (message.s9 != null && Object.hasOwnProperty.call(message, "s9"))
            $root.uvec12.encode(message.s9, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
        if (message.sa != null && Object.hasOwnProperty.call(message, "sa"))
            $root.uvec12.encode(message.sa, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
        if (message.sb != null && Object.hasOwnProperty.call(message, "sb"))
            $root.uvec12.encode(message.sb, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
        return writer;
    };

    /**
     * Decodes an umat12 message from the specified reader or buffer.
     * @function decode
     * @memberof umat12
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {umat12} umat12
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    umat12.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.umat12();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = $root.uvec12.decode(reader, reader.uint32());
                break;
            case 2:
                message.s1 = $root.uvec12.decode(reader, reader.uint32());
                break;
            case 3:
                message.s2 = $root.uvec12.decode(reader, reader.uint32());
                break;
            case 4:
                message.s3 = $root.uvec12.decode(reader, reader.uint32());
                break;
            case 5:
                message.s4 = $root.uvec12.decode(reader, reader.uint32());
                break;
            case 6:
                message.s5 = $root.uvec12.decode(reader, reader.uint32());
                break;
            case 7:
                message.s6 = $root.uvec12.decode(reader, reader.uint32());
                break;
            case 8:
                message.s7 = $root.uvec12.decode(reader, reader.uint32());
                break;
            case 9:
                message.s8 = $root.uvec12.decode(reader, reader.uint32());
                break;
            case 10:
                message.s9 = $root.uvec12.decode(reader, reader.uint32());
                break;
            case 11:
                message.sa = $root.uvec12.decode(reader, reader.uint32());
                break;
            case 12:
                message.sb = $root.uvec12.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return umat12;
})();

export const mat13 = $root.mat13 = (() => {

    /**
     * Properties of a mat13.
     * @exports Imat13
     * @interface Imat13
     * @property {Ivec13|null} [s0] mat13 s0
     * @property {Ivec13|null} [s1] mat13 s1
     * @property {Ivec13|null} [s2] mat13 s2
     * @property {Ivec13|null} [s3] mat13 s3
     * @property {Ivec13|null} [s4] mat13 s4
     * @property {Ivec13|null} [s5] mat13 s5
     * @property {Ivec13|null} [s6] mat13 s6
     * @property {Ivec13|null} [s7] mat13 s7
     * @property {Ivec13|null} [s8] mat13 s8
     * @property {Ivec13|null} [s9] mat13 s9
     * @property {Ivec13|null} [sa] mat13 sa
     * @property {Ivec13|null} [sb] mat13 sb
     * @property {Ivec13|null} [sc] mat13 sc
     */

    /**
     * Constructs a new mat13.
     * @exports mat13
     * @classdesc Represents a mat13.
     * @implements Imat13
     * @constructor
     * @param {Imat13=} [properties] Properties to set
     */
    function mat13(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * mat13 s0.
     * @member {Ivec13|null|undefined} s0
     * @memberof mat13
     * @instance
     */
    mat13.prototype.s0 = null;

    /**
     * mat13 s1.
     * @member {Ivec13|null|undefined} s1
     * @memberof mat13
     * @instance
     */
    mat13.prototype.s1 = null;

    /**
     * mat13 s2.
     * @member {Ivec13|null|undefined} s2
     * @memberof mat13
     * @instance
     */
    mat13.prototype.s2 = null;

    /**
     * mat13 s3.
     * @member {Ivec13|null|undefined} s3
     * @memberof mat13
     * @instance
     */
    mat13.prototype.s3 = null;

    /**
     * mat13 s4.
     * @member {Ivec13|null|undefined} s4
     * @memberof mat13
     * @instance
     */
    mat13.prototype.s4 = null;

    /**
     * mat13 s5.
     * @member {Ivec13|null|undefined} s5
     * @memberof mat13
     * @instance
     */
    mat13.prototype.s5 = null;

    /**
     * mat13 s6.
     * @member {Ivec13|null|undefined} s6
     * @memberof mat13
     * @instance
     */
    mat13.prototype.s6 = null;

    /**
     * mat13 s7.
     * @member {Ivec13|null|undefined} s7
     * @memberof mat13
     * @instance
     */
    mat13.prototype.s7 = null;

    /**
     * mat13 s8.
     * @member {Ivec13|null|undefined} s8
     * @memberof mat13
     * @instance
     */
    mat13.prototype.s8 = null;

    /**
     * mat13 s9.
     * @member {Ivec13|null|undefined} s9
     * @memberof mat13
     * @instance
     */
    mat13.prototype.s9 = null;

    /**
     * mat13 sa.
     * @member {Ivec13|null|undefined} sa
     * @memberof mat13
     * @instance
     */
    mat13.prototype.sa = null;

    /**
     * mat13 sb.
     * @member {Ivec13|null|undefined} sb
     * @memberof mat13
     * @instance
     */
    mat13.prototype.sb = null;

    /**
     * mat13 sc.
     * @member {Ivec13|null|undefined} sc
     * @memberof mat13
     * @instance
     */
    mat13.prototype.sc = null;

    /**
     * Encodes the specified mat13 message. Does not implicitly {@link mat13.verify|verify} messages.
     * @function encode
     * @memberof mat13
     * @static
     * @param {Imat13} message mat13 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    mat13.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            $root.vec13.encode(message.s0, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            $root.vec13.encode(message.s1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            $root.vec13.encode(message.s2, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            $root.vec13.encode(message.s3, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            $root.vec13.encode(message.s4, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            $root.vec13.encode(message.s5, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            $root.vec13.encode(message.s6, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            $root.vec13.encode(message.s7, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            $root.vec13.encode(message.s8, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        if (message.s9 != null && Object.hasOwnProperty.call(message, "s9"))
            $root.vec13.encode(message.s9, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
        if (message.sa != null && Object.hasOwnProperty.call(message, "sa"))
            $root.vec13.encode(message.sa, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
        if (message.sb != null && Object.hasOwnProperty.call(message, "sb"))
            $root.vec13.encode(message.sb, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
        if (message.sc != null && Object.hasOwnProperty.call(message, "sc"))
            $root.vec13.encode(message.sc, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
        return writer;
    };

    /**
     * Decodes a mat13 message from the specified reader or buffer.
     * @function decode
     * @memberof mat13
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {mat13} mat13
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    mat13.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mat13();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = $root.vec13.decode(reader, reader.uint32());
                break;
            case 2:
                message.s1 = $root.vec13.decode(reader, reader.uint32());
                break;
            case 3:
                message.s2 = $root.vec13.decode(reader, reader.uint32());
                break;
            case 4:
                message.s3 = $root.vec13.decode(reader, reader.uint32());
                break;
            case 5:
                message.s4 = $root.vec13.decode(reader, reader.uint32());
                break;
            case 6:
                message.s5 = $root.vec13.decode(reader, reader.uint32());
                break;
            case 7:
                message.s6 = $root.vec13.decode(reader, reader.uint32());
                break;
            case 8:
                message.s7 = $root.vec13.decode(reader, reader.uint32());
                break;
            case 9:
                message.s8 = $root.vec13.decode(reader, reader.uint32());
                break;
            case 10:
                message.s9 = $root.vec13.decode(reader, reader.uint32());
                break;
            case 11:
                message.sa = $root.vec13.decode(reader, reader.uint32());
                break;
            case 12:
                message.sb = $root.vec13.decode(reader, reader.uint32());
                break;
            case 13:
                message.sc = $root.vec13.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return mat13;
})();

export const fmat13 = $root.fmat13 = (() => {

    /**
     * Properties of a fmat13.
     * @exports Ifmat13
     * @interface Ifmat13
     * @property {Ifvec13|null} [s0] fmat13 s0
     * @property {Ifvec13|null} [s1] fmat13 s1
     * @property {Ifvec13|null} [s2] fmat13 s2
     * @property {Ifvec13|null} [s3] fmat13 s3
     * @property {Ifvec13|null} [s4] fmat13 s4
     * @property {Ifvec13|null} [s5] fmat13 s5
     * @property {Ifvec13|null} [s6] fmat13 s6
     * @property {Ifvec13|null} [s7] fmat13 s7
     * @property {Ifvec13|null} [s8] fmat13 s8
     * @property {Ifvec13|null} [s9] fmat13 s9
     * @property {Ifvec13|null} [sa] fmat13 sa
     * @property {Ifvec13|null} [sb] fmat13 sb
     * @property {Ifvec13|null} [sc] fmat13 sc
     */

    /**
     * Constructs a new fmat13.
     * @exports fmat13
     * @classdesc Represents a fmat13.
     * @implements Ifmat13
     * @constructor
     * @param {Ifmat13=} [properties] Properties to set
     */
    function fmat13(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * fmat13 s0.
     * @member {Ifvec13|null|undefined} s0
     * @memberof fmat13
     * @instance
     */
    fmat13.prototype.s0 = null;

    /**
     * fmat13 s1.
     * @member {Ifvec13|null|undefined} s1
     * @memberof fmat13
     * @instance
     */
    fmat13.prototype.s1 = null;

    /**
     * fmat13 s2.
     * @member {Ifvec13|null|undefined} s2
     * @memberof fmat13
     * @instance
     */
    fmat13.prototype.s2 = null;

    /**
     * fmat13 s3.
     * @member {Ifvec13|null|undefined} s3
     * @memberof fmat13
     * @instance
     */
    fmat13.prototype.s3 = null;

    /**
     * fmat13 s4.
     * @member {Ifvec13|null|undefined} s4
     * @memberof fmat13
     * @instance
     */
    fmat13.prototype.s4 = null;

    /**
     * fmat13 s5.
     * @member {Ifvec13|null|undefined} s5
     * @memberof fmat13
     * @instance
     */
    fmat13.prototype.s5 = null;

    /**
     * fmat13 s6.
     * @member {Ifvec13|null|undefined} s6
     * @memberof fmat13
     * @instance
     */
    fmat13.prototype.s6 = null;

    /**
     * fmat13 s7.
     * @member {Ifvec13|null|undefined} s7
     * @memberof fmat13
     * @instance
     */
    fmat13.prototype.s7 = null;

    /**
     * fmat13 s8.
     * @member {Ifvec13|null|undefined} s8
     * @memberof fmat13
     * @instance
     */
    fmat13.prototype.s8 = null;

    /**
     * fmat13 s9.
     * @member {Ifvec13|null|undefined} s9
     * @memberof fmat13
     * @instance
     */
    fmat13.prototype.s9 = null;

    /**
     * fmat13 sa.
     * @member {Ifvec13|null|undefined} sa
     * @memberof fmat13
     * @instance
     */
    fmat13.prototype.sa = null;

    /**
     * fmat13 sb.
     * @member {Ifvec13|null|undefined} sb
     * @memberof fmat13
     * @instance
     */
    fmat13.prototype.sb = null;

    /**
     * fmat13 sc.
     * @member {Ifvec13|null|undefined} sc
     * @memberof fmat13
     * @instance
     */
    fmat13.prototype.sc = null;

    /**
     * Encodes the specified fmat13 message. Does not implicitly {@link fmat13.verify|verify} messages.
     * @function encode
     * @memberof fmat13
     * @static
     * @param {Ifmat13} message fmat13 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    fmat13.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            $root.fvec13.encode(message.s0, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            $root.fvec13.encode(message.s1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            $root.fvec13.encode(message.s2, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            $root.fvec13.encode(message.s3, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            $root.fvec13.encode(message.s4, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            $root.fvec13.encode(message.s5, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            $root.fvec13.encode(message.s6, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            $root.fvec13.encode(message.s7, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            $root.fvec13.encode(message.s8, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        if (message.s9 != null && Object.hasOwnProperty.call(message, "s9"))
            $root.fvec13.encode(message.s9, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
        if (message.sa != null && Object.hasOwnProperty.call(message, "sa"))
            $root.fvec13.encode(message.sa, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
        if (message.sb != null && Object.hasOwnProperty.call(message, "sb"))
            $root.fvec13.encode(message.sb, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
        if (message.sc != null && Object.hasOwnProperty.call(message, "sc"))
            $root.fvec13.encode(message.sc, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
        return writer;
    };

    /**
     * Decodes a fmat13 message from the specified reader or buffer.
     * @function decode
     * @memberof fmat13
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {fmat13} fmat13
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    fmat13.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.fmat13();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = $root.fvec13.decode(reader, reader.uint32());
                break;
            case 2:
                message.s1 = $root.fvec13.decode(reader, reader.uint32());
                break;
            case 3:
                message.s2 = $root.fvec13.decode(reader, reader.uint32());
                break;
            case 4:
                message.s3 = $root.fvec13.decode(reader, reader.uint32());
                break;
            case 5:
                message.s4 = $root.fvec13.decode(reader, reader.uint32());
                break;
            case 6:
                message.s5 = $root.fvec13.decode(reader, reader.uint32());
                break;
            case 7:
                message.s6 = $root.fvec13.decode(reader, reader.uint32());
                break;
            case 8:
                message.s7 = $root.fvec13.decode(reader, reader.uint32());
                break;
            case 9:
                message.s8 = $root.fvec13.decode(reader, reader.uint32());
                break;
            case 10:
                message.s9 = $root.fvec13.decode(reader, reader.uint32());
                break;
            case 11:
                message.sa = $root.fvec13.decode(reader, reader.uint32());
                break;
            case 12:
                message.sb = $root.fvec13.decode(reader, reader.uint32());
                break;
            case 13:
                message.sc = $root.fvec13.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return fmat13;
})();

export const imat13 = $root.imat13 = (() => {

    /**
     * Properties of an imat13.
     * @exports Iimat13
     * @interface Iimat13
     * @property {Iivec13|null} [s0] imat13 s0
     * @property {Iivec13|null} [s1] imat13 s1
     * @property {Iivec13|null} [s2] imat13 s2
     * @property {Iivec13|null} [s3] imat13 s3
     * @property {Iivec13|null} [s4] imat13 s4
     * @property {Iivec13|null} [s5] imat13 s5
     * @property {Iivec13|null} [s6] imat13 s6
     * @property {Iivec13|null} [s7] imat13 s7
     * @property {Iivec13|null} [s8] imat13 s8
     * @property {Iivec13|null} [s9] imat13 s9
     * @property {Iivec13|null} [sa] imat13 sa
     * @property {Iivec13|null} [sb] imat13 sb
     * @property {Iivec13|null} [sc] imat13 sc
     */

    /**
     * Constructs a new imat13.
     * @exports imat13
     * @classdesc Represents an imat13.
     * @implements Iimat13
     * @constructor
     * @param {Iimat13=} [properties] Properties to set
     */
    function imat13(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * imat13 s0.
     * @member {Iivec13|null|undefined} s0
     * @memberof imat13
     * @instance
     */
    imat13.prototype.s0 = null;

    /**
     * imat13 s1.
     * @member {Iivec13|null|undefined} s1
     * @memberof imat13
     * @instance
     */
    imat13.prototype.s1 = null;

    /**
     * imat13 s2.
     * @member {Iivec13|null|undefined} s2
     * @memberof imat13
     * @instance
     */
    imat13.prototype.s2 = null;

    /**
     * imat13 s3.
     * @member {Iivec13|null|undefined} s3
     * @memberof imat13
     * @instance
     */
    imat13.prototype.s3 = null;

    /**
     * imat13 s4.
     * @member {Iivec13|null|undefined} s4
     * @memberof imat13
     * @instance
     */
    imat13.prototype.s4 = null;

    /**
     * imat13 s5.
     * @member {Iivec13|null|undefined} s5
     * @memberof imat13
     * @instance
     */
    imat13.prototype.s5 = null;

    /**
     * imat13 s6.
     * @member {Iivec13|null|undefined} s6
     * @memberof imat13
     * @instance
     */
    imat13.prototype.s6 = null;

    /**
     * imat13 s7.
     * @member {Iivec13|null|undefined} s7
     * @memberof imat13
     * @instance
     */
    imat13.prototype.s7 = null;

    /**
     * imat13 s8.
     * @member {Iivec13|null|undefined} s8
     * @memberof imat13
     * @instance
     */
    imat13.prototype.s8 = null;

    /**
     * imat13 s9.
     * @member {Iivec13|null|undefined} s9
     * @memberof imat13
     * @instance
     */
    imat13.prototype.s9 = null;

    /**
     * imat13 sa.
     * @member {Iivec13|null|undefined} sa
     * @memberof imat13
     * @instance
     */
    imat13.prototype.sa = null;

    /**
     * imat13 sb.
     * @member {Iivec13|null|undefined} sb
     * @memberof imat13
     * @instance
     */
    imat13.prototype.sb = null;

    /**
     * imat13 sc.
     * @member {Iivec13|null|undefined} sc
     * @memberof imat13
     * @instance
     */
    imat13.prototype.sc = null;

    /**
     * Encodes the specified imat13 message. Does not implicitly {@link imat13.verify|verify} messages.
     * @function encode
     * @memberof imat13
     * @static
     * @param {Iimat13} message imat13 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    imat13.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            $root.ivec13.encode(message.s0, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            $root.ivec13.encode(message.s1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            $root.ivec13.encode(message.s2, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            $root.ivec13.encode(message.s3, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            $root.ivec13.encode(message.s4, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            $root.ivec13.encode(message.s5, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            $root.ivec13.encode(message.s6, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            $root.ivec13.encode(message.s7, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            $root.ivec13.encode(message.s8, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        if (message.s9 != null && Object.hasOwnProperty.call(message, "s9"))
            $root.ivec13.encode(message.s9, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
        if (message.sa != null && Object.hasOwnProperty.call(message, "sa"))
            $root.ivec13.encode(message.sa, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
        if (message.sb != null && Object.hasOwnProperty.call(message, "sb"))
            $root.ivec13.encode(message.sb, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
        if (message.sc != null && Object.hasOwnProperty.call(message, "sc"))
            $root.ivec13.encode(message.sc, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
        return writer;
    };

    /**
     * Decodes an imat13 message from the specified reader or buffer.
     * @function decode
     * @memberof imat13
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {imat13} imat13
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    imat13.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.imat13();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = $root.ivec13.decode(reader, reader.uint32());
                break;
            case 2:
                message.s1 = $root.ivec13.decode(reader, reader.uint32());
                break;
            case 3:
                message.s2 = $root.ivec13.decode(reader, reader.uint32());
                break;
            case 4:
                message.s3 = $root.ivec13.decode(reader, reader.uint32());
                break;
            case 5:
                message.s4 = $root.ivec13.decode(reader, reader.uint32());
                break;
            case 6:
                message.s5 = $root.ivec13.decode(reader, reader.uint32());
                break;
            case 7:
                message.s6 = $root.ivec13.decode(reader, reader.uint32());
                break;
            case 8:
                message.s7 = $root.ivec13.decode(reader, reader.uint32());
                break;
            case 9:
                message.s8 = $root.ivec13.decode(reader, reader.uint32());
                break;
            case 10:
                message.s9 = $root.ivec13.decode(reader, reader.uint32());
                break;
            case 11:
                message.sa = $root.ivec13.decode(reader, reader.uint32());
                break;
            case 12:
                message.sb = $root.ivec13.decode(reader, reader.uint32());
                break;
            case 13:
                message.sc = $root.ivec13.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return imat13;
})();

export const umat13 = $root.umat13 = (() => {

    /**
     * Properties of an umat13.
     * @exports Iumat13
     * @interface Iumat13
     * @property {Iuvec13|null} [s0] umat13 s0
     * @property {Iuvec13|null} [s1] umat13 s1
     * @property {Iuvec13|null} [s2] umat13 s2
     * @property {Iuvec13|null} [s3] umat13 s3
     * @property {Iuvec13|null} [s4] umat13 s4
     * @property {Iuvec13|null} [s5] umat13 s5
     * @property {Iuvec13|null} [s6] umat13 s6
     * @property {Iuvec13|null} [s7] umat13 s7
     * @property {Iuvec13|null} [s8] umat13 s8
     * @property {Iuvec13|null} [s9] umat13 s9
     * @property {Iuvec13|null} [sa] umat13 sa
     * @property {Iuvec13|null} [sb] umat13 sb
     * @property {Iuvec13|null} [sc] umat13 sc
     */

    /**
     * Constructs a new umat13.
     * @exports umat13
     * @classdesc Represents an umat13.
     * @implements Iumat13
     * @constructor
     * @param {Iumat13=} [properties] Properties to set
     */
    function umat13(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * umat13 s0.
     * @member {Iuvec13|null|undefined} s0
     * @memberof umat13
     * @instance
     */
    umat13.prototype.s0 = null;

    /**
     * umat13 s1.
     * @member {Iuvec13|null|undefined} s1
     * @memberof umat13
     * @instance
     */
    umat13.prototype.s1 = null;

    /**
     * umat13 s2.
     * @member {Iuvec13|null|undefined} s2
     * @memberof umat13
     * @instance
     */
    umat13.prototype.s2 = null;

    /**
     * umat13 s3.
     * @member {Iuvec13|null|undefined} s3
     * @memberof umat13
     * @instance
     */
    umat13.prototype.s3 = null;

    /**
     * umat13 s4.
     * @member {Iuvec13|null|undefined} s4
     * @memberof umat13
     * @instance
     */
    umat13.prototype.s4 = null;

    /**
     * umat13 s5.
     * @member {Iuvec13|null|undefined} s5
     * @memberof umat13
     * @instance
     */
    umat13.prototype.s5 = null;

    /**
     * umat13 s6.
     * @member {Iuvec13|null|undefined} s6
     * @memberof umat13
     * @instance
     */
    umat13.prototype.s6 = null;

    /**
     * umat13 s7.
     * @member {Iuvec13|null|undefined} s7
     * @memberof umat13
     * @instance
     */
    umat13.prototype.s7 = null;

    /**
     * umat13 s8.
     * @member {Iuvec13|null|undefined} s8
     * @memberof umat13
     * @instance
     */
    umat13.prototype.s8 = null;

    /**
     * umat13 s9.
     * @member {Iuvec13|null|undefined} s9
     * @memberof umat13
     * @instance
     */
    umat13.prototype.s9 = null;

    /**
     * umat13 sa.
     * @member {Iuvec13|null|undefined} sa
     * @memberof umat13
     * @instance
     */
    umat13.prototype.sa = null;

    /**
     * umat13 sb.
     * @member {Iuvec13|null|undefined} sb
     * @memberof umat13
     * @instance
     */
    umat13.prototype.sb = null;

    /**
     * umat13 sc.
     * @member {Iuvec13|null|undefined} sc
     * @memberof umat13
     * @instance
     */
    umat13.prototype.sc = null;

    /**
     * Encodes the specified umat13 message. Does not implicitly {@link umat13.verify|verify} messages.
     * @function encode
     * @memberof umat13
     * @static
     * @param {Iumat13} message umat13 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    umat13.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            $root.uvec13.encode(message.s0, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            $root.uvec13.encode(message.s1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            $root.uvec13.encode(message.s2, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            $root.uvec13.encode(message.s3, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            $root.uvec13.encode(message.s4, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            $root.uvec13.encode(message.s5, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            $root.uvec13.encode(message.s6, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            $root.uvec13.encode(message.s7, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            $root.uvec13.encode(message.s8, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        if (message.s9 != null && Object.hasOwnProperty.call(message, "s9"))
            $root.uvec13.encode(message.s9, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
        if (message.sa != null && Object.hasOwnProperty.call(message, "sa"))
            $root.uvec13.encode(message.sa, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
        if (message.sb != null && Object.hasOwnProperty.call(message, "sb"))
            $root.uvec13.encode(message.sb, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
        if (message.sc != null && Object.hasOwnProperty.call(message, "sc"))
            $root.uvec13.encode(message.sc, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
        return writer;
    };

    /**
     * Decodes an umat13 message from the specified reader or buffer.
     * @function decode
     * @memberof umat13
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {umat13} umat13
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    umat13.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.umat13();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = $root.uvec13.decode(reader, reader.uint32());
                break;
            case 2:
                message.s1 = $root.uvec13.decode(reader, reader.uint32());
                break;
            case 3:
                message.s2 = $root.uvec13.decode(reader, reader.uint32());
                break;
            case 4:
                message.s3 = $root.uvec13.decode(reader, reader.uint32());
                break;
            case 5:
                message.s4 = $root.uvec13.decode(reader, reader.uint32());
                break;
            case 6:
                message.s5 = $root.uvec13.decode(reader, reader.uint32());
                break;
            case 7:
                message.s6 = $root.uvec13.decode(reader, reader.uint32());
                break;
            case 8:
                message.s7 = $root.uvec13.decode(reader, reader.uint32());
                break;
            case 9:
                message.s8 = $root.uvec13.decode(reader, reader.uint32());
                break;
            case 10:
                message.s9 = $root.uvec13.decode(reader, reader.uint32());
                break;
            case 11:
                message.sa = $root.uvec13.decode(reader, reader.uint32());
                break;
            case 12:
                message.sb = $root.uvec13.decode(reader, reader.uint32());
                break;
            case 13:
                message.sc = $root.uvec13.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return umat13;
})();

export const mat14 = $root.mat14 = (() => {

    /**
     * Properties of a mat14.
     * @exports Imat14
     * @interface Imat14
     * @property {Ivec14|null} [s0] mat14 s0
     * @property {Ivec14|null} [s1] mat14 s1
     * @property {Ivec14|null} [s2] mat14 s2
     * @property {Ivec14|null} [s3] mat14 s3
     * @property {Ivec14|null} [s4] mat14 s4
     * @property {Ivec14|null} [s5] mat14 s5
     * @property {Ivec14|null} [s6] mat14 s6
     * @property {Ivec14|null} [s7] mat14 s7
     * @property {Ivec14|null} [s8] mat14 s8
     * @property {Ivec14|null} [s9] mat14 s9
     * @property {Ivec14|null} [sa] mat14 sa
     * @property {Ivec14|null} [sb] mat14 sb
     * @property {Ivec14|null} [sc] mat14 sc
     * @property {Ivec14|null} [sd] mat14 sd
     */

    /**
     * Constructs a new mat14.
     * @exports mat14
     * @classdesc Represents a mat14.
     * @implements Imat14
     * @constructor
     * @param {Imat14=} [properties] Properties to set
     */
    function mat14(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * mat14 s0.
     * @member {Ivec14|null|undefined} s0
     * @memberof mat14
     * @instance
     */
    mat14.prototype.s0 = null;

    /**
     * mat14 s1.
     * @member {Ivec14|null|undefined} s1
     * @memberof mat14
     * @instance
     */
    mat14.prototype.s1 = null;

    /**
     * mat14 s2.
     * @member {Ivec14|null|undefined} s2
     * @memberof mat14
     * @instance
     */
    mat14.prototype.s2 = null;

    /**
     * mat14 s3.
     * @member {Ivec14|null|undefined} s3
     * @memberof mat14
     * @instance
     */
    mat14.prototype.s3 = null;

    /**
     * mat14 s4.
     * @member {Ivec14|null|undefined} s4
     * @memberof mat14
     * @instance
     */
    mat14.prototype.s4 = null;

    /**
     * mat14 s5.
     * @member {Ivec14|null|undefined} s5
     * @memberof mat14
     * @instance
     */
    mat14.prototype.s5 = null;

    /**
     * mat14 s6.
     * @member {Ivec14|null|undefined} s6
     * @memberof mat14
     * @instance
     */
    mat14.prototype.s6 = null;

    /**
     * mat14 s7.
     * @member {Ivec14|null|undefined} s7
     * @memberof mat14
     * @instance
     */
    mat14.prototype.s7 = null;

    /**
     * mat14 s8.
     * @member {Ivec14|null|undefined} s8
     * @memberof mat14
     * @instance
     */
    mat14.prototype.s8 = null;

    /**
     * mat14 s9.
     * @member {Ivec14|null|undefined} s9
     * @memberof mat14
     * @instance
     */
    mat14.prototype.s9 = null;

    /**
     * mat14 sa.
     * @member {Ivec14|null|undefined} sa
     * @memberof mat14
     * @instance
     */
    mat14.prototype.sa = null;

    /**
     * mat14 sb.
     * @member {Ivec14|null|undefined} sb
     * @memberof mat14
     * @instance
     */
    mat14.prototype.sb = null;

    /**
     * mat14 sc.
     * @member {Ivec14|null|undefined} sc
     * @memberof mat14
     * @instance
     */
    mat14.prototype.sc = null;

    /**
     * mat14 sd.
     * @member {Ivec14|null|undefined} sd
     * @memberof mat14
     * @instance
     */
    mat14.prototype.sd = null;

    /**
     * Encodes the specified mat14 message. Does not implicitly {@link mat14.verify|verify} messages.
     * @function encode
     * @memberof mat14
     * @static
     * @param {Imat14} message mat14 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    mat14.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            $root.vec14.encode(message.s0, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            $root.vec14.encode(message.s1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            $root.vec14.encode(message.s2, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            $root.vec14.encode(message.s3, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            $root.vec14.encode(message.s4, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            $root.vec14.encode(message.s5, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            $root.vec14.encode(message.s6, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            $root.vec14.encode(message.s7, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            $root.vec14.encode(message.s8, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        if (message.s9 != null && Object.hasOwnProperty.call(message, "s9"))
            $root.vec14.encode(message.s9, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
        if (message.sa != null && Object.hasOwnProperty.call(message, "sa"))
            $root.vec14.encode(message.sa, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
        if (message.sb != null && Object.hasOwnProperty.call(message, "sb"))
            $root.vec14.encode(message.sb, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
        if (message.sc != null && Object.hasOwnProperty.call(message, "sc"))
            $root.vec14.encode(message.sc, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
        if (message.sd != null && Object.hasOwnProperty.call(message, "sd"))
            $root.vec14.encode(message.sd, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
        return writer;
    };

    /**
     * Decodes a mat14 message from the specified reader or buffer.
     * @function decode
     * @memberof mat14
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {mat14} mat14
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    mat14.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mat14();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = $root.vec14.decode(reader, reader.uint32());
                break;
            case 2:
                message.s1 = $root.vec14.decode(reader, reader.uint32());
                break;
            case 3:
                message.s2 = $root.vec14.decode(reader, reader.uint32());
                break;
            case 4:
                message.s3 = $root.vec14.decode(reader, reader.uint32());
                break;
            case 5:
                message.s4 = $root.vec14.decode(reader, reader.uint32());
                break;
            case 6:
                message.s5 = $root.vec14.decode(reader, reader.uint32());
                break;
            case 7:
                message.s6 = $root.vec14.decode(reader, reader.uint32());
                break;
            case 8:
                message.s7 = $root.vec14.decode(reader, reader.uint32());
                break;
            case 9:
                message.s8 = $root.vec14.decode(reader, reader.uint32());
                break;
            case 10:
                message.s9 = $root.vec14.decode(reader, reader.uint32());
                break;
            case 11:
                message.sa = $root.vec14.decode(reader, reader.uint32());
                break;
            case 12:
                message.sb = $root.vec14.decode(reader, reader.uint32());
                break;
            case 13:
                message.sc = $root.vec14.decode(reader, reader.uint32());
                break;
            case 14:
                message.sd = $root.vec14.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return mat14;
})();

export const fmat14 = $root.fmat14 = (() => {

    /**
     * Properties of a fmat14.
     * @exports Ifmat14
     * @interface Ifmat14
     * @property {Ifvec14|null} [s0] fmat14 s0
     * @property {Ifvec14|null} [s1] fmat14 s1
     * @property {Ifvec14|null} [s2] fmat14 s2
     * @property {Ifvec14|null} [s3] fmat14 s3
     * @property {Ifvec14|null} [s4] fmat14 s4
     * @property {Ifvec14|null} [s5] fmat14 s5
     * @property {Ifvec14|null} [s6] fmat14 s6
     * @property {Ifvec14|null} [s7] fmat14 s7
     * @property {Ifvec14|null} [s8] fmat14 s8
     * @property {Ifvec14|null} [s9] fmat14 s9
     * @property {Ifvec14|null} [sa] fmat14 sa
     * @property {Ifvec14|null} [sb] fmat14 sb
     * @property {Ifvec14|null} [sc] fmat14 sc
     * @property {Ifvec14|null} [sd] fmat14 sd
     */

    /**
     * Constructs a new fmat14.
     * @exports fmat14
     * @classdesc Represents a fmat14.
     * @implements Ifmat14
     * @constructor
     * @param {Ifmat14=} [properties] Properties to set
     */
    function fmat14(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * fmat14 s0.
     * @member {Ifvec14|null|undefined} s0
     * @memberof fmat14
     * @instance
     */
    fmat14.prototype.s0 = null;

    /**
     * fmat14 s1.
     * @member {Ifvec14|null|undefined} s1
     * @memberof fmat14
     * @instance
     */
    fmat14.prototype.s1 = null;

    /**
     * fmat14 s2.
     * @member {Ifvec14|null|undefined} s2
     * @memberof fmat14
     * @instance
     */
    fmat14.prototype.s2 = null;

    /**
     * fmat14 s3.
     * @member {Ifvec14|null|undefined} s3
     * @memberof fmat14
     * @instance
     */
    fmat14.prototype.s3 = null;

    /**
     * fmat14 s4.
     * @member {Ifvec14|null|undefined} s4
     * @memberof fmat14
     * @instance
     */
    fmat14.prototype.s4 = null;

    /**
     * fmat14 s5.
     * @member {Ifvec14|null|undefined} s5
     * @memberof fmat14
     * @instance
     */
    fmat14.prototype.s5 = null;

    /**
     * fmat14 s6.
     * @member {Ifvec14|null|undefined} s6
     * @memberof fmat14
     * @instance
     */
    fmat14.prototype.s6 = null;

    /**
     * fmat14 s7.
     * @member {Ifvec14|null|undefined} s7
     * @memberof fmat14
     * @instance
     */
    fmat14.prototype.s7 = null;

    /**
     * fmat14 s8.
     * @member {Ifvec14|null|undefined} s8
     * @memberof fmat14
     * @instance
     */
    fmat14.prototype.s8 = null;

    /**
     * fmat14 s9.
     * @member {Ifvec14|null|undefined} s9
     * @memberof fmat14
     * @instance
     */
    fmat14.prototype.s9 = null;

    /**
     * fmat14 sa.
     * @member {Ifvec14|null|undefined} sa
     * @memberof fmat14
     * @instance
     */
    fmat14.prototype.sa = null;

    /**
     * fmat14 sb.
     * @member {Ifvec14|null|undefined} sb
     * @memberof fmat14
     * @instance
     */
    fmat14.prototype.sb = null;

    /**
     * fmat14 sc.
     * @member {Ifvec14|null|undefined} sc
     * @memberof fmat14
     * @instance
     */
    fmat14.prototype.sc = null;

    /**
     * fmat14 sd.
     * @member {Ifvec14|null|undefined} sd
     * @memberof fmat14
     * @instance
     */
    fmat14.prototype.sd = null;

    /**
     * Encodes the specified fmat14 message. Does not implicitly {@link fmat14.verify|verify} messages.
     * @function encode
     * @memberof fmat14
     * @static
     * @param {Ifmat14} message fmat14 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    fmat14.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            $root.fvec14.encode(message.s0, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            $root.fvec14.encode(message.s1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            $root.fvec14.encode(message.s2, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            $root.fvec14.encode(message.s3, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            $root.fvec14.encode(message.s4, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            $root.fvec14.encode(message.s5, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            $root.fvec14.encode(message.s6, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            $root.fvec14.encode(message.s7, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            $root.fvec14.encode(message.s8, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        if (message.s9 != null && Object.hasOwnProperty.call(message, "s9"))
            $root.fvec14.encode(message.s9, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
        if (message.sa != null && Object.hasOwnProperty.call(message, "sa"))
            $root.fvec14.encode(message.sa, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
        if (message.sb != null && Object.hasOwnProperty.call(message, "sb"))
            $root.fvec14.encode(message.sb, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
        if (message.sc != null && Object.hasOwnProperty.call(message, "sc"))
            $root.fvec14.encode(message.sc, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
        if (message.sd != null && Object.hasOwnProperty.call(message, "sd"))
            $root.fvec14.encode(message.sd, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
        return writer;
    };

    /**
     * Decodes a fmat14 message from the specified reader or buffer.
     * @function decode
     * @memberof fmat14
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {fmat14} fmat14
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    fmat14.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.fmat14();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = $root.fvec14.decode(reader, reader.uint32());
                break;
            case 2:
                message.s1 = $root.fvec14.decode(reader, reader.uint32());
                break;
            case 3:
                message.s2 = $root.fvec14.decode(reader, reader.uint32());
                break;
            case 4:
                message.s3 = $root.fvec14.decode(reader, reader.uint32());
                break;
            case 5:
                message.s4 = $root.fvec14.decode(reader, reader.uint32());
                break;
            case 6:
                message.s5 = $root.fvec14.decode(reader, reader.uint32());
                break;
            case 7:
                message.s6 = $root.fvec14.decode(reader, reader.uint32());
                break;
            case 8:
                message.s7 = $root.fvec14.decode(reader, reader.uint32());
                break;
            case 9:
                message.s8 = $root.fvec14.decode(reader, reader.uint32());
                break;
            case 10:
                message.s9 = $root.fvec14.decode(reader, reader.uint32());
                break;
            case 11:
                message.sa = $root.fvec14.decode(reader, reader.uint32());
                break;
            case 12:
                message.sb = $root.fvec14.decode(reader, reader.uint32());
                break;
            case 13:
                message.sc = $root.fvec14.decode(reader, reader.uint32());
                break;
            case 14:
                message.sd = $root.fvec14.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return fmat14;
})();

export const imat14 = $root.imat14 = (() => {

    /**
     * Properties of an imat14.
     * @exports Iimat14
     * @interface Iimat14
     * @property {Iivec14|null} [s0] imat14 s0
     * @property {Iivec14|null} [s1] imat14 s1
     * @property {Iivec14|null} [s2] imat14 s2
     * @property {Iivec14|null} [s3] imat14 s3
     * @property {Iivec14|null} [s4] imat14 s4
     * @property {Iivec14|null} [s5] imat14 s5
     * @property {Iivec14|null} [s6] imat14 s6
     * @property {Iivec14|null} [s7] imat14 s7
     * @property {Iivec14|null} [s8] imat14 s8
     * @property {Iivec14|null} [s9] imat14 s9
     * @property {Iivec14|null} [sa] imat14 sa
     * @property {Iivec14|null} [sb] imat14 sb
     * @property {Iivec14|null} [sc] imat14 sc
     * @property {Iivec14|null} [sd] imat14 sd
     */

    /**
     * Constructs a new imat14.
     * @exports imat14
     * @classdesc Represents an imat14.
     * @implements Iimat14
     * @constructor
     * @param {Iimat14=} [properties] Properties to set
     */
    function imat14(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * imat14 s0.
     * @member {Iivec14|null|undefined} s0
     * @memberof imat14
     * @instance
     */
    imat14.prototype.s0 = null;

    /**
     * imat14 s1.
     * @member {Iivec14|null|undefined} s1
     * @memberof imat14
     * @instance
     */
    imat14.prototype.s1 = null;

    /**
     * imat14 s2.
     * @member {Iivec14|null|undefined} s2
     * @memberof imat14
     * @instance
     */
    imat14.prototype.s2 = null;

    /**
     * imat14 s3.
     * @member {Iivec14|null|undefined} s3
     * @memberof imat14
     * @instance
     */
    imat14.prototype.s3 = null;

    /**
     * imat14 s4.
     * @member {Iivec14|null|undefined} s4
     * @memberof imat14
     * @instance
     */
    imat14.prototype.s4 = null;

    /**
     * imat14 s5.
     * @member {Iivec14|null|undefined} s5
     * @memberof imat14
     * @instance
     */
    imat14.prototype.s5 = null;

    /**
     * imat14 s6.
     * @member {Iivec14|null|undefined} s6
     * @memberof imat14
     * @instance
     */
    imat14.prototype.s6 = null;

    /**
     * imat14 s7.
     * @member {Iivec14|null|undefined} s7
     * @memberof imat14
     * @instance
     */
    imat14.prototype.s7 = null;

    /**
     * imat14 s8.
     * @member {Iivec14|null|undefined} s8
     * @memberof imat14
     * @instance
     */
    imat14.prototype.s8 = null;

    /**
     * imat14 s9.
     * @member {Iivec14|null|undefined} s9
     * @memberof imat14
     * @instance
     */
    imat14.prototype.s9 = null;

    /**
     * imat14 sa.
     * @member {Iivec14|null|undefined} sa
     * @memberof imat14
     * @instance
     */
    imat14.prototype.sa = null;

    /**
     * imat14 sb.
     * @member {Iivec14|null|undefined} sb
     * @memberof imat14
     * @instance
     */
    imat14.prototype.sb = null;

    /**
     * imat14 sc.
     * @member {Iivec14|null|undefined} sc
     * @memberof imat14
     * @instance
     */
    imat14.prototype.sc = null;

    /**
     * imat14 sd.
     * @member {Iivec14|null|undefined} sd
     * @memberof imat14
     * @instance
     */
    imat14.prototype.sd = null;

    /**
     * Encodes the specified imat14 message. Does not implicitly {@link imat14.verify|verify} messages.
     * @function encode
     * @memberof imat14
     * @static
     * @param {Iimat14} message imat14 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    imat14.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            $root.ivec14.encode(message.s0, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            $root.ivec14.encode(message.s1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            $root.ivec14.encode(message.s2, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            $root.ivec14.encode(message.s3, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            $root.ivec14.encode(message.s4, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            $root.ivec14.encode(message.s5, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            $root.ivec14.encode(message.s6, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            $root.ivec14.encode(message.s7, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            $root.ivec14.encode(message.s8, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        if (message.s9 != null && Object.hasOwnProperty.call(message, "s9"))
            $root.ivec14.encode(message.s9, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
        if (message.sa != null && Object.hasOwnProperty.call(message, "sa"))
            $root.ivec14.encode(message.sa, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
        if (message.sb != null && Object.hasOwnProperty.call(message, "sb"))
            $root.ivec14.encode(message.sb, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
        if (message.sc != null && Object.hasOwnProperty.call(message, "sc"))
            $root.ivec14.encode(message.sc, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
        if (message.sd != null && Object.hasOwnProperty.call(message, "sd"))
            $root.ivec14.encode(message.sd, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
        return writer;
    };

    /**
     * Decodes an imat14 message from the specified reader or buffer.
     * @function decode
     * @memberof imat14
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {imat14} imat14
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    imat14.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.imat14();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = $root.ivec14.decode(reader, reader.uint32());
                break;
            case 2:
                message.s1 = $root.ivec14.decode(reader, reader.uint32());
                break;
            case 3:
                message.s2 = $root.ivec14.decode(reader, reader.uint32());
                break;
            case 4:
                message.s3 = $root.ivec14.decode(reader, reader.uint32());
                break;
            case 5:
                message.s4 = $root.ivec14.decode(reader, reader.uint32());
                break;
            case 6:
                message.s5 = $root.ivec14.decode(reader, reader.uint32());
                break;
            case 7:
                message.s6 = $root.ivec14.decode(reader, reader.uint32());
                break;
            case 8:
                message.s7 = $root.ivec14.decode(reader, reader.uint32());
                break;
            case 9:
                message.s8 = $root.ivec14.decode(reader, reader.uint32());
                break;
            case 10:
                message.s9 = $root.ivec14.decode(reader, reader.uint32());
                break;
            case 11:
                message.sa = $root.ivec14.decode(reader, reader.uint32());
                break;
            case 12:
                message.sb = $root.ivec14.decode(reader, reader.uint32());
                break;
            case 13:
                message.sc = $root.ivec14.decode(reader, reader.uint32());
                break;
            case 14:
                message.sd = $root.ivec14.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return imat14;
})();

export const umat14 = $root.umat14 = (() => {

    /**
     * Properties of an umat14.
     * @exports Iumat14
     * @interface Iumat14
     * @property {Iuvec14|null} [s0] umat14 s0
     * @property {Iuvec14|null} [s1] umat14 s1
     * @property {Iuvec14|null} [s2] umat14 s2
     * @property {Iuvec14|null} [s3] umat14 s3
     * @property {Iuvec14|null} [s4] umat14 s4
     * @property {Iuvec14|null} [s5] umat14 s5
     * @property {Iuvec14|null} [s6] umat14 s6
     * @property {Iuvec14|null} [s7] umat14 s7
     * @property {Iuvec14|null} [s8] umat14 s8
     * @property {Iuvec14|null} [s9] umat14 s9
     * @property {Iuvec14|null} [sa] umat14 sa
     * @property {Iuvec14|null} [sb] umat14 sb
     * @property {Iuvec14|null} [sc] umat14 sc
     * @property {Iuvec14|null} [sd] umat14 sd
     */

    /**
     * Constructs a new umat14.
     * @exports umat14
     * @classdesc Represents an umat14.
     * @implements Iumat14
     * @constructor
     * @param {Iumat14=} [properties] Properties to set
     */
    function umat14(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * umat14 s0.
     * @member {Iuvec14|null|undefined} s0
     * @memberof umat14
     * @instance
     */
    umat14.prototype.s0 = null;

    /**
     * umat14 s1.
     * @member {Iuvec14|null|undefined} s1
     * @memberof umat14
     * @instance
     */
    umat14.prototype.s1 = null;

    /**
     * umat14 s2.
     * @member {Iuvec14|null|undefined} s2
     * @memberof umat14
     * @instance
     */
    umat14.prototype.s2 = null;

    /**
     * umat14 s3.
     * @member {Iuvec14|null|undefined} s3
     * @memberof umat14
     * @instance
     */
    umat14.prototype.s3 = null;

    /**
     * umat14 s4.
     * @member {Iuvec14|null|undefined} s4
     * @memberof umat14
     * @instance
     */
    umat14.prototype.s4 = null;

    /**
     * umat14 s5.
     * @member {Iuvec14|null|undefined} s5
     * @memberof umat14
     * @instance
     */
    umat14.prototype.s5 = null;

    /**
     * umat14 s6.
     * @member {Iuvec14|null|undefined} s6
     * @memberof umat14
     * @instance
     */
    umat14.prototype.s6 = null;

    /**
     * umat14 s7.
     * @member {Iuvec14|null|undefined} s7
     * @memberof umat14
     * @instance
     */
    umat14.prototype.s7 = null;

    /**
     * umat14 s8.
     * @member {Iuvec14|null|undefined} s8
     * @memberof umat14
     * @instance
     */
    umat14.prototype.s8 = null;

    /**
     * umat14 s9.
     * @member {Iuvec14|null|undefined} s9
     * @memberof umat14
     * @instance
     */
    umat14.prototype.s9 = null;

    /**
     * umat14 sa.
     * @member {Iuvec14|null|undefined} sa
     * @memberof umat14
     * @instance
     */
    umat14.prototype.sa = null;

    /**
     * umat14 sb.
     * @member {Iuvec14|null|undefined} sb
     * @memberof umat14
     * @instance
     */
    umat14.prototype.sb = null;

    /**
     * umat14 sc.
     * @member {Iuvec14|null|undefined} sc
     * @memberof umat14
     * @instance
     */
    umat14.prototype.sc = null;

    /**
     * umat14 sd.
     * @member {Iuvec14|null|undefined} sd
     * @memberof umat14
     * @instance
     */
    umat14.prototype.sd = null;

    /**
     * Encodes the specified umat14 message. Does not implicitly {@link umat14.verify|verify} messages.
     * @function encode
     * @memberof umat14
     * @static
     * @param {Iumat14} message umat14 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    umat14.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            $root.uvec14.encode(message.s0, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            $root.uvec14.encode(message.s1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            $root.uvec14.encode(message.s2, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            $root.uvec14.encode(message.s3, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            $root.uvec14.encode(message.s4, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            $root.uvec14.encode(message.s5, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            $root.uvec14.encode(message.s6, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            $root.uvec14.encode(message.s7, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            $root.uvec14.encode(message.s8, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        if (message.s9 != null && Object.hasOwnProperty.call(message, "s9"))
            $root.uvec14.encode(message.s9, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
        if (message.sa != null && Object.hasOwnProperty.call(message, "sa"))
            $root.uvec14.encode(message.sa, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
        if (message.sb != null && Object.hasOwnProperty.call(message, "sb"))
            $root.uvec14.encode(message.sb, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
        if (message.sc != null && Object.hasOwnProperty.call(message, "sc"))
            $root.uvec14.encode(message.sc, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
        if (message.sd != null && Object.hasOwnProperty.call(message, "sd"))
            $root.uvec14.encode(message.sd, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
        return writer;
    };

    /**
     * Decodes an umat14 message from the specified reader or buffer.
     * @function decode
     * @memberof umat14
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {umat14} umat14
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    umat14.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.umat14();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = $root.uvec14.decode(reader, reader.uint32());
                break;
            case 2:
                message.s1 = $root.uvec14.decode(reader, reader.uint32());
                break;
            case 3:
                message.s2 = $root.uvec14.decode(reader, reader.uint32());
                break;
            case 4:
                message.s3 = $root.uvec14.decode(reader, reader.uint32());
                break;
            case 5:
                message.s4 = $root.uvec14.decode(reader, reader.uint32());
                break;
            case 6:
                message.s5 = $root.uvec14.decode(reader, reader.uint32());
                break;
            case 7:
                message.s6 = $root.uvec14.decode(reader, reader.uint32());
                break;
            case 8:
                message.s7 = $root.uvec14.decode(reader, reader.uint32());
                break;
            case 9:
                message.s8 = $root.uvec14.decode(reader, reader.uint32());
                break;
            case 10:
                message.s9 = $root.uvec14.decode(reader, reader.uint32());
                break;
            case 11:
                message.sa = $root.uvec14.decode(reader, reader.uint32());
                break;
            case 12:
                message.sb = $root.uvec14.decode(reader, reader.uint32());
                break;
            case 13:
                message.sc = $root.uvec14.decode(reader, reader.uint32());
                break;
            case 14:
                message.sd = $root.uvec14.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return umat14;
})();

export const mat15 = $root.mat15 = (() => {

    /**
     * Properties of a mat15.
     * @exports Imat15
     * @interface Imat15
     * @property {Ivec15|null} [s0] mat15 s0
     * @property {Ivec15|null} [s1] mat15 s1
     * @property {Ivec15|null} [s2] mat15 s2
     * @property {Ivec15|null} [s3] mat15 s3
     * @property {Ivec15|null} [s4] mat15 s4
     * @property {Ivec15|null} [s5] mat15 s5
     * @property {Ivec15|null} [s6] mat15 s6
     * @property {Ivec15|null} [s7] mat15 s7
     * @property {Ivec15|null} [s8] mat15 s8
     * @property {Ivec15|null} [s9] mat15 s9
     * @property {Ivec15|null} [sa] mat15 sa
     * @property {Ivec15|null} [sb] mat15 sb
     * @property {Ivec15|null} [sc] mat15 sc
     * @property {Ivec15|null} [sd] mat15 sd
     * @property {Ivec15|null} [se] mat15 se
     */

    /**
     * Constructs a new mat15.
     * @exports mat15
     * @classdesc Represents a mat15.
     * @implements Imat15
     * @constructor
     * @param {Imat15=} [properties] Properties to set
     */
    function mat15(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * mat15 s0.
     * @member {Ivec15|null|undefined} s0
     * @memberof mat15
     * @instance
     */
    mat15.prototype.s0 = null;

    /**
     * mat15 s1.
     * @member {Ivec15|null|undefined} s1
     * @memberof mat15
     * @instance
     */
    mat15.prototype.s1 = null;

    /**
     * mat15 s2.
     * @member {Ivec15|null|undefined} s2
     * @memberof mat15
     * @instance
     */
    mat15.prototype.s2 = null;

    /**
     * mat15 s3.
     * @member {Ivec15|null|undefined} s3
     * @memberof mat15
     * @instance
     */
    mat15.prototype.s3 = null;

    /**
     * mat15 s4.
     * @member {Ivec15|null|undefined} s4
     * @memberof mat15
     * @instance
     */
    mat15.prototype.s4 = null;

    /**
     * mat15 s5.
     * @member {Ivec15|null|undefined} s5
     * @memberof mat15
     * @instance
     */
    mat15.prototype.s5 = null;

    /**
     * mat15 s6.
     * @member {Ivec15|null|undefined} s6
     * @memberof mat15
     * @instance
     */
    mat15.prototype.s6 = null;

    /**
     * mat15 s7.
     * @member {Ivec15|null|undefined} s7
     * @memberof mat15
     * @instance
     */
    mat15.prototype.s7 = null;

    /**
     * mat15 s8.
     * @member {Ivec15|null|undefined} s8
     * @memberof mat15
     * @instance
     */
    mat15.prototype.s8 = null;

    /**
     * mat15 s9.
     * @member {Ivec15|null|undefined} s9
     * @memberof mat15
     * @instance
     */
    mat15.prototype.s9 = null;

    /**
     * mat15 sa.
     * @member {Ivec15|null|undefined} sa
     * @memberof mat15
     * @instance
     */
    mat15.prototype.sa = null;

    /**
     * mat15 sb.
     * @member {Ivec15|null|undefined} sb
     * @memberof mat15
     * @instance
     */
    mat15.prototype.sb = null;

    /**
     * mat15 sc.
     * @member {Ivec15|null|undefined} sc
     * @memberof mat15
     * @instance
     */
    mat15.prototype.sc = null;

    /**
     * mat15 sd.
     * @member {Ivec15|null|undefined} sd
     * @memberof mat15
     * @instance
     */
    mat15.prototype.sd = null;

    /**
     * mat15 se.
     * @member {Ivec15|null|undefined} se
     * @memberof mat15
     * @instance
     */
    mat15.prototype.se = null;

    /**
     * Encodes the specified mat15 message. Does not implicitly {@link mat15.verify|verify} messages.
     * @function encode
     * @memberof mat15
     * @static
     * @param {Imat15} message mat15 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    mat15.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            $root.vec15.encode(message.s0, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            $root.vec15.encode(message.s1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            $root.vec15.encode(message.s2, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            $root.vec15.encode(message.s3, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            $root.vec15.encode(message.s4, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            $root.vec15.encode(message.s5, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            $root.vec15.encode(message.s6, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            $root.vec15.encode(message.s7, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            $root.vec15.encode(message.s8, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        if (message.s9 != null && Object.hasOwnProperty.call(message, "s9"))
            $root.vec15.encode(message.s9, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
        if (message.sa != null && Object.hasOwnProperty.call(message, "sa"))
            $root.vec15.encode(message.sa, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
        if (message.sb != null && Object.hasOwnProperty.call(message, "sb"))
            $root.vec15.encode(message.sb, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
        if (message.sc != null && Object.hasOwnProperty.call(message, "sc"))
            $root.vec15.encode(message.sc, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
        if (message.sd != null && Object.hasOwnProperty.call(message, "sd"))
            $root.vec15.encode(message.sd, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
        if (message.se != null && Object.hasOwnProperty.call(message, "se"))
            $root.vec15.encode(message.se, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
        return writer;
    };

    /**
     * Decodes a mat15 message from the specified reader or buffer.
     * @function decode
     * @memberof mat15
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {mat15} mat15
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    mat15.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mat15();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = $root.vec15.decode(reader, reader.uint32());
                break;
            case 2:
                message.s1 = $root.vec15.decode(reader, reader.uint32());
                break;
            case 3:
                message.s2 = $root.vec15.decode(reader, reader.uint32());
                break;
            case 4:
                message.s3 = $root.vec15.decode(reader, reader.uint32());
                break;
            case 5:
                message.s4 = $root.vec15.decode(reader, reader.uint32());
                break;
            case 6:
                message.s5 = $root.vec15.decode(reader, reader.uint32());
                break;
            case 7:
                message.s6 = $root.vec15.decode(reader, reader.uint32());
                break;
            case 8:
                message.s7 = $root.vec15.decode(reader, reader.uint32());
                break;
            case 9:
                message.s8 = $root.vec15.decode(reader, reader.uint32());
                break;
            case 10:
                message.s9 = $root.vec15.decode(reader, reader.uint32());
                break;
            case 11:
                message.sa = $root.vec15.decode(reader, reader.uint32());
                break;
            case 12:
                message.sb = $root.vec15.decode(reader, reader.uint32());
                break;
            case 13:
                message.sc = $root.vec15.decode(reader, reader.uint32());
                break;
            case 14:
                message.sd = $root.vec15.decode(reader, reader.uint32());
                break;
            case 15:
                message.se = $root.vec15.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return mat15;
})();

export const fmat15 = $root.fmat15 = (() => {

    /**
     * Properties of a fmat15.
     * @exports Ifmat15
     * @interface Ifmat15
     * @property {Ifvec15|null} [s0] fmat15 s0
     * @property {Ifvec15|null} [s1] fmat15 s1
     * @property {Ifvec15|null} [s2] fmat15 s2
     * @property {Ifvec15|null} [s3] fmat15 s3
     * @property {Ifvec15|null} [s4] fmat15 s4
     * @property {Ifvec15|null} [s5] fmat15 s5
     * @property {Ifvec15|null} [s6] fmat15 s6
     * @property {Ifvec15|null} [s7] fmat15 s7
     * @property {Ifvec15|null} [s8] fmat15 s8
     * @property {Ifvec15|null} [s9] fmat15 s9
     * @property {Ifvec15|null} [sa] fmat15 sa
     * @property {Ifvec15|null} [sb] fmat15 sb
     * @property {Ifvec15|null} [sc] fmat15 sc
     * @property {Ifvec15|null} [sd] fmat15 sd
     * @property {Ifvec15|null} [se] fmat15 se
     */

    /**
     * Constructs a new fmat15.
     * @exports fmat15
     * @classdesc Represents a fmat15.
     * @implements Ifmat15
     * @constructor
     * @param {Ifmat15=} [properties] Properties to set
     */
    function fmat15(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * fmat15 s0.
     * @member {Ifvec15|null|undefined} s0
     * @memberof fmat15
     * @instance
     */
    fmat15.prototype.s0 = null;

    /**
     * fmat15 s1.
     * @member {Ifvec15|null|undefined} s1
     * @memberof fmat15
     * @instance
     */
    fmat15.prototype.s1 = null;

    /**
     * fmat15 s2.
     * @member {Ifvec15|null|undefined} s2
     * @memberof fmat15
     * @instance
     */
    fmat15.prototype.s2 = null;

    /**
     * fmat15 s3.
     * @member {Ifvec15|null|undefined} s3
     * @memberof fmat15
     * @instance
     */
    fmat15.prototype.s3 = null;

    /**
     * fmat15 s4.
     * @member {Ifvec15|null|undefined} s4
     * @memberof fmat15
     * @instance
     */
    fmat15.prototype.s4 = null;

    /**
     * fmat15 s5.
     * @member {Ifvec15|null|undefined} s5
     * @memberof fmat15
     * @instance
     */
    fmat15.prototype.s5 = null;

    /**
     * fmat15 s6.
     * @member {Ifvec15|null|undefined} s6
     * @memberof fmat15
     * @instance
     */
    fmat15.prototype.s6 = null;

    /**
     * fmat15 s7.
     * @member {Ifvec15|null|undefined} s7
     * @memberof fmat15
     * @instance
     */
    fmat15.prototype.s7 = null;

    /**
     * fmat15 s8.
     * @member {Ifvec15|null|undefined} s8
     * @memberof fmat15
     * @instance
     */
    fmat15.prototype.s8 = null;

    /**
     * fmat15 s9.
     * @member {Ifvec15|null|undefined} s9
     * @memberof fmat15
     * @instance
     */
    fmat15.prototype.s9 = null;

    /**
     * fmat15 sa.
     * @member {Ifvec15|null|undefined} sa
     * @memberof fmat15
     * @instance
     */
    fmat15.prototype.sa = null;

    /**
     * fmat15 sb.
     * @member {Ifvec15|null|undefined} sb
     * @memberof fmat15
     * @instance
     */
    fmat15.prototype.sb = null;

    /**
     * fmat15 sc.
     * @member {Ifvec15|null|undefined} sc
     * @memberof fmat15
     * @instance
     */
    fmat15.prototype.sc = null;

    /**
     * fmat15 sd.
     * @member {Ifvec15|null|undefined} sd
     * @memberof fmat15
     * @instance
     */
    fmat15.prototype.sd = null;

    /**
     * fmat15 se.
     * @member {Ifvec15|null|undefined} se
     * @memberof fmat15
     * @instance
     */
    fmat15.prototype.se = null;

    /**
     * Encodes the specified fmat15 message. Does not implicitly {@link fmat15.verify|verify} messages.
     * @function encode
     * @memberof fmat15
     * @static
     * @param {Ifmat15} message fmat15 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    fmat15.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            $root.fvec15.encode(message.s0, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            $root.fvec15.encode(message.s1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            $root.fvec15.encode(message.s2, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            $root.fvec15.encode(message.s3, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            $root.fvec15.encode(message.s4, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            $root.fvec15.encode(message.s5, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            $root.fvec15.encode(message.s6, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            $root.fvec15.encode(message.s7, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            $root.fvec15.encode(message.s8, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        if (message.s9 != null && Object.hasOwnProperty.call(message, "s9"))
            $root.fvec15.encode(message.s9, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
        if (message.sa != null && Object.hasOwnProperty.call(message, "sa"))
            $root.fvec15.encode(message.sa, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
        if (message.sb != null && Object.hasOwnProperty.call(message, "sb"))
            $root.fvec15.encode(message.sb, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
        if (message.sc != null && Object.hasOwnProperty.call(message, "sc"))
            $root.fvec15.encode(message.sc, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
        if (message.sd != null && Object.hasOwnProperty.call(message, "sd"))
            $root.fvec15.encode(message.sd, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
        if (message.se != null && Object.hasOwnProperty.call(message, "se"))
            $root.fvec15.encode(message.se, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
        return writer;
    };

    /**
     * Decodes a fmat15 message from the specified reader or buffer.
     * @function decode
     * @memberof fmat15
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {fmat15} fmat15
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    fmat15.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.fmat15();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = $root.fvec15.decode(reader, reader.uint32());
                break;
            case 2:
                message.s1 = $root.fvec15.decode(reader, reader.uint32());
                break;
            case 3:
                message.s2 = $root.fvec15.decode(reader, reader.uint32());
                break;
            case 4:
                message.s3 = $root.fvec15.decode(reader, reader.uint32());
                break;
            case 5:
                message.s4 = $root.fvec15.decode(reader, reader.uint32());
                break;
            case 6:
                message.s5 = $root.fvec15.decode(reader, reader.uint32());
                break;
            case 7:
                message.s6 = $root.fvec15.decode(reader, reader.uint32());
                break;
            case 8:
                message.s7 = $root.fvec15.decode(reader, reader.uint32());
                break;
            case 9:
                message.s8 = $root.fvec15.decode(reader, reader.uint32());
                break;
            case 10:
                message.s9 = $root.fvec15.decode(reader, reader.uint32());
                break;
            case 11:
                message.sa = $root.fvec15.decode(reader, reader.uint32());
                break;
            case 12:
                message.sb = $root.fvec15.decode(reader, reader.uint32());
                break;
            case 13:
                message.sc = $root.fvec15.decode(reader, reader.uint32());
                break;
            case 14:
                message.sd = $root.fvec15.decode(reader, reader.uint32());
                break;
            case 15:
                message.se = $root.fvec15.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return fmat15;
})();

export const imat15 = $root.imat15 = (() => {

    /**
     * Properties of an imat15.
     * @exports Iimat15
     * @interface Iimat15
     * @property {Iivec15|null} [s0] imat15 s0
     * @property {Iivec15|null} [s1] imat15 s1
     * @property {Iivec15|null} [s2] imat15 s2
     * @property {Iivec15|null} [s3] imat15 s3
     * @property {Iivec15|null} [s4] imat15 s4
     * @property {Iivec15|null} [s5] imat15 s5
     * @property {Iivec15|null} [s6] imat15 s6
     * @property {Iivec15|null} [s7] imat15 s7
     * @property {Iivec15|null} [s8] imat15 s8
     * @property {Iivec15|null} [s9] imat15 s9
     * @property {Iivec15|null} [sa] imat15 sa
     * @property {Iivec15|null} [sb] imat15 sb
     * @property {Iivec15|null} [sc] imat15 sc
     * @property {Iivec15|null} [sd] imat15 sd
     * @property {Iivec15|null} [se] imat15 se
     */

    /**
     * Constructs a new imat15.
     * @exports imat15
     * @classdesc Represents an imat15.
     * @implements Iimat15
     * @constructor
     * @param {Iimat15=} [properties] Properties to set
     */
    function imat15(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * imat15 s0.
     * @member {Iivec15|null|undefined} s0
     * @memberof imat15
     * @instance
     */
    imat15.prototype.s0 = null;

    /**
     * imat15 s1.
     * @member {Iivec15|null|undefined} s1
     * @memberof imat15
     * @instance
     */
    imat15.prototype.s1 = null;

    /**
     * imat15 s2.
     * @member {Iivec15|null|undefined} s2
     * @memberof imat15
     * @instance
     */
    imat15.prototype.s2 = null;

    /**
     * imat15 s3.
     * @member {Iivec15|null|undefined} s3
     * @memberof imat15
     * @instance
     */
    imat15.prototype.s3 = null;

    /**
     * imat15 s4.
     * @member {Iivec15|null|undefined} s4
     * @memberof imat15
     * @instance
     */
    imat15.prototype.s4 = null;

    /**
     * imat15 s5.
     * @member {Iivec15|null|undefined} s5
     * @memberof imat15
     * @instance
     */
    imat15.prototype.s5 = null;

    /**
     * imat15 s6.
     * @member {Iivec15|null|undefined} s6
     * @memberof imat15
     * @instance
     */
    imat15.prototype.s6 = null;

    /**
     * imat15 s7.
     * @member {Iivec15|null|undefined} s7
     * @memberof imat15
     * @instance
     */
    imat15.prototype.s7 = null;

    /**
     * imat15 s8.
     * @member {Iivec15|null|undefined} s8
     * @memberof imat15
     * @instance
     */
    imat15.prototype.s8 = null;

    /**
     * imat15 s9.
     * @member {Iivec15|null|undefined} s9
     * @memberof imat15
     * @instance
     */
    imat15.prototype.s9 = null;

    /**
     * imat15 sa.
     * @member {Iivec15|null|undefined} sa
     * @memberof imat15
     * @instance
     */
    imat15.prototype.sa = null;

    /**
     * imat15 sb.
     * @member {Iivec15|null|undefined} sb
     * @memberof imat15
     * @instance
     */
    imat15.prototype.sb = null;

    /**
     * imat15 sc.
     * @member {Iivec15|null|undefined} sc
     * @memberof imat15
     * @instance
     */
    imat15.prototype.sc = null;

    /**
     * imat15 sd.
     * @member {Iivec15|null|undefined} sd
     * @memberof imat15
     * @instance
     */
    imat15.prototype.sd = null;

    /**
     * imat15 se.
     * @member {Iivec15|null|undefined} se
     * @memberof imat15
     * @instance
     */
    imat15.prototype.se = null;

    /**
     * Encodes the specified imat15 message. Does not implicitly {@link imat15.verify|verify} messages.
     * @function encode
     * @memberof imat15
     * @static
     * @param {Iimat15} message imat15 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    imat15.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            $root.ivec15.encode(message.s0, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            $root.ivec15.encode(message.s1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            $root.ivec15.encode(message.s2, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            $root.ivec15.encode(message.s3, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            $root.ivec15.encode(message.s4, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            $root.ivec15.encode(message.s5, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            $root.ivec15.encode(message.s6, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            $root.ivec15.encode(message.s7, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            $root.ivec15.encode(message.s8, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        if (message.s9 != null && Object.hasOwnProperty.call(message, "s9"))
            $root.ivec15.encode(message.s9, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
        if (message.sa != null && Object.hasOwnProperty.call(message, "sa"))
            $root.ivec15.encode(message.sa, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
        if (message.sb != null && Object.hasOwnProperty.call(message, "sb"))
            $root.ivec15.encode(message.sb, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
        if (message.sc != null && Object.hasOwnProperty.call(message, "sc"))
            $root.ivec15.encode(message.sc, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
        if (message.sd != null && Object.hasOwnProperty.call(message, "sd"))
            $root.ivec15.encode(message.sd, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
        if (message.se != null && Object.hasOwnProperty.call(message, "se"))
            $root.ivec15.encode(message.se, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
        return writer;
    };

    /**
     * Decodes an imat15 message from the specified reader or buffer.
     * @function decode
     * @memberof imat15
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {imat15} imat15
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    imat15.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.imat15();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = $root.ivec15.decode(reader, reader.uint32());
                break;
            case 2:
                message.s1 = $root.ivec15.decode(reader, reader.uint32());
                break;
            case 3:
                message.s2 = $root.ivec15.decode(reader, reader.uint32());
                break;
            case 4:
                message.s3 = $root.ivec15.decode(reader, reader.uint32());
                break;
            case 5:
                message.s4 = $root.ivec15.decode(reader, reader.uint32());
                break;
            case 6:
                message.s5 = $root.ivec15.decode(reader, reader.uint32());
                break;
            case 7:
                message.s6 = $root.ivec15.decode(reader, reader.uint32());
                break;
            case 8:
                message.s7 = $root.ivec15.decode(reader, reader.uint32());
                break;
            case 9:
                message.s8 = $root.ivec15.decode(reader, reader.uint32());
                break;
            case 10:
                message.s9 = $root.ivec15.decode(reader, reader.uint32());
                break;
            case 11:
                message.sa = $root.ivec15.decode(reader, reader.uint32());
                break;
            case 12:
                message.sb = $root.ivec15.decode(reader, reader.uint32());
                break;
            case 13:
                message.sc = $root.ivec15.decode(reader, reader.uint32());
                break;
            case 14:
                message.sd = $root.ivec15.decode(reader, reader.uint32());
                break;
            case 15:
                message.se = $root.ivec15.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return imat15;
})();

export const umat15 = $root.umat15 = (() => {

    /**
     * Properties of an umat15.
     * @exports Iumat15
     * @interface Iumat15
     * @property {Iuvec15|null} [s0] umat15 s0
     * @property {Iuvec15|null} [s1] umat15 s1
     * @property {Iuvec15|null} [s2] umat15 s2
     * @property {Iuvec15|null} [s3] umat15 s3
     * @property {Iuvec15|null} [s4] umat15 s4
     * @property {Iuvec15|null} [s5] umat15 s5
     * @property {Iuvec15|null} [s6] umat15 s6
     * @property {Iuvec15|null} [s7] umat15 s7
     * @property {Iuvec15|null} [s8] umat15 s8
     * @property {Iuvec15|null} [s9] umat15 s9
     * @property {Iuvec15|null} [sa] umat15 sa
     * @property {Iuvec15|null} [sb] umat15 sb
     * @property {Iuvec15|null} [sc] umat15 sc
     * @property {Iuvec15|null} [sd] umat15 sd
     * @property {Iuvec15|null} [se] umat15 se
     */

    /**
     * Constructs a new umat15.
     * @exports umat15
     * @classdesc Represents an umat15.
     * @implements Iumat15
     * @constructor
     * @param {Iumat15=} [properties] Properties to set
     */
    function umat15(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * umat15 s0.
     * @member {Iuvec15|null|undefined} s0
     * @memberof umat15
     * @instance
     */
    umat15.prototype.s0 = null;

    /**
     * umat15 s1.
     * @member {Iuvec15|null|undefined} s1
     * @memberof umat15
     * @instance
     */
    umat15.prototype.s1 = null;

    /**
     * umat15 s2.
     * @member {Iuvec15|null|undefined} s2
     * @memberof umat15
     * @instance
     */
    umat15.prototype.s2 = null;

    /**
     * umat15 s3.
     * @member {Iuvec15|null|undefined} s3
     * @memberof umat15
     * @instance
     */
    umat15.prototype.s3 = null;

    /**
     * umat15 s4.
     * @member {Iuvec15|null|undefined} s4
     * @memberof umat15
     * @instance
     */
    umat15.prototype.s4 = null;

    /**
     * umat15 s5.
     * @member {Iuvec15|null|undefined} s5
     * @memberof umat15
     * @instance
     */
    umat15.prototype.s5 = null;

    /**
     * umat15 s6.
     * @member {Iuvec15|null|undefined} s6
     * @memberof umat15
     * @instance
     */
    umat15.prototype.s6 = null;

    /**
     * umat15 s7.
     * @member {Iuvec15|null|undefined} s7
     * @memberof umat15
     * @instance
     */
    umat15.prototype.s7 = null;

    /**
     * umat15 s8.
     * @member {Iuvec15|null|undefined} s8
     * @memberof umat15
     * @instance
     */
    umat15.prototype.s8 = null;

    /**
     * umat15 s9.
     * @member {Iuvec15|null|undefined} s9
     * @memberof umat15
     * @instance
     */
    umat15.prototype.s9 = null;

    /**
     * umat15 sa.
     * @member {Iuvec15|null|undefined} sa
     * @memberof umat15
     * @instance
     */
    umat15.prototype.sa = null;

    /**
     * umat15 sb.
     * @member {Iuvec15|null|undefined} sb
     * @memberof umat15
     * @instance
     */
    umat15.prototype.sb = null;

    /**
     * umat15 sc.
     * @member {Iuvec15|null|undefined} sc
     * @memberof umat15
     * @instance
     */
    umat15.prototype.sc = null;

    /**
     * umat15 sd.
     * @member {Iuvec15|null|undefined} sd
     * @memberof umat15
     * @instance
     */
    umat15.prototype.sd = null;

    /**
     * umat15 se.
     * @member {Iuvec15|null|undefined} se
     * @memberof umat15
     * @instance
     */
    umat15.prototype.se = null;

    /**
     * Encodes the specified umat15 message. Does not implicitly {@link umat15.verify|verify} messages.
     * @function encode
     * @memberof umat15
     * @static
     * @param {Iumat15} message umat15 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    umat15.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            $root.uvec15.encode(message.s0, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            $root.uvec15.encode(message.s1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            $root.uvec15.encode(message.s2, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            $root.uvec15.encode(message.s3, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            $root.uvec15.encode(message.s4, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            $root.uvec15.encode(message.s5, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            $root.uvec15.encode(message.s6, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            $root.uvec15.encode(message.s7, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            $root.uvec15.encode(message.s8, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        if (message.s9 != null && Object.hasOwnProperty.call(message, "s9"))
            $root.uvec15.encode(message.s9, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
        if (message.sa != null && Object.hasOwnProperty.call(message, "sa"))
            $root.uvec15.encode(message.sa, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
        if (message.sb != null && Object.hasOwnProperty.call(message, "sb"))
            $root.uvec15.encode(message.sb, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
        if (message.sc != null && Object.hasOwnProperty.call(message, "sc"))
            $root.uvec15.encode(message.sc, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
        if (message.sd != null && Object.hasOwnProperty.call(message, "sd"))
            $root.uvec15.encode(message.sd, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
        if (message.se != null && Object.hasOwnProperty.call(message, "se"))
            $root.uvec15.encode(message.se, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
        return writer;
    };

    /**
     * Decodes an umat15 message from the specified reader or buffer.
     * @function decode
     * @memberof umat15
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {umat15} umat15
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    umat15.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.umat15();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = $root.uvec15.decode(reader, reader.uint32());
                break;
            case 2:
                message.s1 = $root.uvec15.decode(reader, reader.uint32());
                break;
            case 3:
                message.s2 = $root.uvec15.decode(reader, reader.uint32());
                break;
            case 4:
                message.s3 = $root.uvec15.decode(reader, reader.uint32());
                break;
            case 5:
                message.s4 = $root.uvec15.decode(reader, reader.uint32());
                break;
            case 6:
                message.s5 = $root.uvec15.decode(reader, reader.uint32());
                break;
            case 7:
                message.s6 = $root.uvec15.decode(reader, reader.uint32());
                break;
            case 8:
                message.s7 = $root.uvec15.decode(reader, reader.uint32());
                break;
            case 9:
                message.s8 = $root.uvec15.decode(reader, reader.uint32());
                break;
            case 10:
                message.s9 = $root.uvec15.decode(reader, reader.uint32());
                break;
            case 11:
                message.sa = $root.uvec15.decode(reader, reader.uint32());
                break;
            case 12:
                message.sb = $root.uvec15.decode(reader, reader.uint32());
                break;
            case 13:
                message.sc = $root.uvec15.decode(reader, reader.uint32());
                break;
            case 14:
                message.sd = $root.uvec15.decode(reader, reader.uint32());
                break;
            case 15:
                message.se = $root.uvec15.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return umat15;
})();

export const mat16 = $root.mat16 = (() => {

    /**
     * Properties of a mat16.
     * @exports Imat16
     * @interface Imat16
     * @property {Ivec16|null} [s0] mat16 s0
     * @property {Ivec16|null} [s1] mat16 s1
     * @property {Ivec16|null} [s2] mat16 s2
     * @property {Ivec16|null} [s3] mat16 s3
     * @property {Ivec16|null} [s4] mat16 s4
     * @property {Ivec16|null} [s5] mat16 s5
     * @property {Ivec16|null} [s6] mat16 s6
     * @property {Ivec16|null} [s7] mat16 s7
     * @property {Ivec16|null} [s8] mat16 s8
     * @property {Ivec16|null} [s9] mat16 s9
     * @property {Ivec16|null} [sa] mat16 sa
     * @property {Ivec16|null} [sb] mat16 sb
     * @property {Ivec16|null} [sc] mat16 sc
     * @property {Ivec16|null} [sd] mat16 sd
     * @property {Ivec16|null} [se] mat16 se
     * @property {Ivec16|null} [sf] mat16 sf
     */

    /**
     * Constructs a new mat16.
     * @exports mat16
     * @classdesc Represents a mat16.
     * @implements Imat16
     * @constructor
     * @param {Imat16=} [properties] Properties to set
     */
    function mat16(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * mat16 s0.
     * @member {Ivec16|null|undefined} s0
     * @memberof mat16
     * @instance
     */
    mat16.prototype.s0 = null;

    /**
     * mat16 s1.
     * @member {Ivec16|null|undefined} s1
     * @memberof mat16
     * @instance
     */
    mat16.prototype.s1 = null;

    /**
     * mat16 s2.
     * @member {Ivec16|null|undefined} s2
     * @memberof mat16
     * @instance
     */
    mat16.prototype.s2 = null;

    /**
     * mat16 s3.
     * @member {Ivec16|null|undefined} s3
     * @memberof mat16
     * @instance
     */
    mat16.prototype.s3 = null;

    /**
     * mat16 s4.
     * @member {Ivec16|null|undefined} s4
     * @memberof mat16
     * @instance
     */
    mat16.prototype.s4 = null;

    /**
     * mat16 s5.
     * @member {Ivec16|null|undefined} s5
     * @memberof mat16
     * @instance
     */
    mat16.prototype.s5 = null;

    /**
     * mat16 s6.
     * @member {Ivec16|null|undefined} s6
     * @memberof mat16
     * @instance
     */
    mat16.prototype.s6 = null;

    /**
     * mat16 s7.
     * @member {Ivec16|null|undefined} s7
     * @memberof mat16
     * @instance
     */
    mat16.prototype.s7 = null;

    /**
     * mat16 s8.
     * @member {Ivec16|null|undefined} s8
     * @memberof mat16
     * @instance
     */
    mat16.prototype.s8 = null;

    /**
     * mat16 s9.
     * @member {Ivec16|null|undefined} s9
     * @memberof mat16
     * @instance
     */
    mat16.prototype.s9 = null;

    /**
     * mat16 sa.
     * @member {Ivec16|null|undefined} sa
     * @memberof mat16
     * @instance
     */
    mat16.prototype.sa = null;

    /**
     * mat16 sb.
     * @member {Ivec16|null|undefined} sb
     * @memberof mat16
     * @instance
     */
    mat16.prototype.sb = null;

    /**
     * mat16 sc.
     * @member {Ivec16|null|undefined} sc
     * @memberof mat16
     * @instance
     */
    mat16.prototype.sc = null;

    /**
     * mat16 sd.
     * @member {Ivec16|null|undefined} sd
     * @memberof mat16
     * @instance
     */
    mat16.prototype.sd = null;

    /**
     * mat16 se.
     * @member {Ivec16|null|undefined} se
     * @memberof mat16
     * @instance
     */
    mat16.prototype.se = null;

    /**
     * mat16 sf.
     * @member {Ivec16|null|undefined} sf
     * @memberof mat16
     * @instance
     */
    mat16.prototype.sf = null;

    /**
     * Encodes the specified mat16 message. Does not implicitly {@link mat16.verify|verify} messages.
     * @function encode
     * @memberof mat16
     * @static
     * @param {Imat16} message mat16 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    mat16.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            $root.vec16.encode(message.s0, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            $root.vec16.encode(message.s1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            $root.vec16.encode(message.s2, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            $root.vec16.encode(message.s3, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            $root.vec16.encode(message.s4, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            $root.vec16.encode(message.s5, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            $root.vec16.encode(message.s6, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            $root.vec16.encode(message.s7, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            $root.vec16.encode(message.s8, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        if (message.s9 != null && Object.hasOwnProperty.call(message, "s9"))
            $root.vec16.encode(message.s9, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
        if (message.sa != null && Object.hasOwnProperty.call(message, "sa"))
            $root.vec16.encode(message.sa, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
        if (message.sb != null && Object.hasOwnProperty.call(message, "sb"))
            $root.vec16.encode(message.sb, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
        if (message.sc != null && Object.hasOwnProperty.call(message, "sc"))
            $root.vec16.encode(message.sc, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
        if (message.sd != null && Object.hasOwnProperty.call(message, "sd"))
            $root.vec16.encode(message.sd, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
        if (message.se != null && Object.hasOwnProperty.call(message, "se"))
            $root.vec16.encode(message.se, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
        if (message.sf != null && Object.hasOwnProperty.call(message, "sf"))
            $root.vec16.encode(message.sf, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
        return writer;
    };

    /**
     * Decodes a mat16 message from the specified reader or buffer.
     * @function decode
     * @memberof mat16
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {mat16} mat16
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    mat16.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.mat16();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = $root.vec16.decode(reader, reader.uint32());
                break;
            case 2:
                message.s1 = $root.vec16.decode(reader, reader.uint32());
                break;
            case 3:
                message.s2 = $root.vec16.decode(reader, reader.uint32());
                break;
            case 4:
                message.s3 = $root.vec16.decode(reader, reader.uint32());
                break;
            case 5:
                message.s4 = $root.vec16.decode(reader, reader.uint32());
                break;
            case 6:
                message.s5 = $root.vec16.decode(reader, reader.uint32());
                break;
            case 7:
                message.s6 = $root.vec16.decode(reader, reader.uint32());
                break;
            case 8:
                message.s7 = $root.vec16.decode(reader, reader.uint32());
                break;
            case 9:
                message.s8 = $root.vec16.decode(reader, reader.uint32());
                break;
            case 10:
                message.s9 = $root.vec16.decode(reader, reader.uint32());
                break;
            case 11:
                message.sa = $root.vec16.decode(reader, reader.uint32());
                break;
            case 12:
                message.sb = $root.vec16.decode(reader, reader.uint32());
                break;
            case 13:
                message.sc = $root.vec16.decode(reader, reader.uint32());
                break;
            case 14:
                message.sd = $root.vec16.decode(reader, reader.uint32());
                break;
            case 15:
                message.se = $root.vec16.decode(reader, reader.uint32());
                break;
            case 16:
                message.sf = $root.vec16.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return mat16;
})();

export const fmat16 = $root.fmat16 = (() => {

    /**
     * Properties of a fmat16.
     * @exports Ifmat16
     * @interface Ifmat16
     * @property {Ifvec16|null} [s0] fmat16 s0
     * @property {Ifvec16|null} [s1] fmat16 s1
     * @property {Ifvec16|null} [s2] fmat16 s2
     * @property {Ifvec16|null} [s3] fmat16 s3
     * @property {Ifvec16|null} [s4] fmat16 s4
     * @property {Ifvec16|null} [s5] fmat16 s5
     * @property {Ifvec16|null} [s6] fmat16 s6
     * @property {Ifvec16|null} [s7] fmat16 s7
     * @property {Ifvec16|null} [s8] fmat16 s8
     * @property {Ifvec16|null} [s9] fmat16 s9
     * @property {Ifvec16|null} [sa] fmat16 sa
     * @property {Ifvec16|null} [sb] fmat16 sb
     * @property {Ifvec16|null} [sc] fmat16 sc
     * @property {Ifvec16|null} [sd] fmat16 sd
     * @property {Ifvec16|null} [se] fmat16 se
     * @property {Ifvec16|null} [sf] fmat16 sf
     */

    /**
     * Constructs a new fmat16.
     * @exports fmat16
     * @classdesc Represents a fmat16.
     * @implements Ifmat16
     * @constructor
     * @param {Ifmat16=} [properties] Properties to set
     */
    function fmat16(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * fmat16 s0.
     * @member {Ifvec16|null|undefined} s0
     * @memberof fmat16
     * @instance
     */
    fmat16.prototype.s0 = null;

    /**
     * fmat16 s1.
     * @member {Ifvec16|null|undefined} s1
     * @memberof fmat16
     * @instance
     */
    fmat16.prototype.s1 = null;

    /**
     * fmat16 s2.
     * @member {Ifvec16|null|undefined} s2
     * @memberof fmat16
     * @instance
     */
    fmat16.prototype.s2 = null;

    /**
     * fmat16 s3.
     * @member {Ifvec16|null|undefined} s3
     * @memberof fmat16
     * @instance
     */
    fmat16.prototype.s3 = null;

    /**
     * fmat16 s4.
     * @member {Ifvec16|null|undefined} s4
     * @memberof fmat16
     * @instance
     */
    fmat16.prototype.s4 = null;

    /**
     * fmat16 s5.
     * @member {Ifvec16|null|undefined} s5
     * @memberof fmat16
     * @instance
     */
    fmat16.prototype.s5 = null;

    /**
     * fmat16 s6.
     * @member {Ifvec16|null|undefined} s6
     * @memberof fmat16
     * @instance
     */
    fmat16.prototype.s6 = null;

    /**
     * fmat16 s7.
     * @member {Ifvec16|null|undefined} s7
     * @memberof fmat16
     * @instance
     */
    fmat16.prototype.s7 = null;

    /**
     * fmat16 s8.
     * @member {Ifvec16|null|undefined} s8
     * @memberof fmat16
     * @instance
     */
    fmat16.prototype.s8 = null;

    /**
     * fmat16 s9.
     * @member {Ifvec16|null|undefined} s9
     * @memberof fmat16
     * @instance
     */
    fmat16.prototype.s9 = null;

    /**
     * fmat16 sa.
     * @member {Ifvec16|null|undefined} sa
     * @memberof fmat16
     * @instance
     */
    fmat16.prototype.sa = null;

    /**
     * fmat16 sb.
     * @member {Ifvec16|null|undefined} sb
     * @memberof fmat16
     * @instance
     */
    fmat16.prototype.sb = null;

    /**
     * fmat16 sc.
     * @member {Ifvec16|null|undefined} sc
     * @memberof fmat16
     * @instance
     */
    fmat16.prototype.sc = null;

    /**
     * fmat16 sd.
     * @member {Ifvec16|null|undefined} sd
     * @memberof fmat16
     * @instance
     */
    fmat16.prototype.sd = null;

    /**
     * fmat16 se.
     * @member {Ifvec16|null|undefined} se
     * @memberof fmat16
     * @instance
     */
    fmat16.prototype.se = null;

    /**
     * fmat16 sf.
     * @member {Ifvec16|null|undefined} sf
     * @memberof fmat16
     * @instance
     */
    fmat16.prototype.sf = null;

    /**
     * Encodes the specified fmat16 message. Does not implicitly {@link fmat16.verify|verify} messages.
     * @function encode
     * @memberof fmat16
     * @static
     * @param {Ifmat16} message fmat16 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    fmat16.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            $root.fvec16.encode(message.s0, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            $root.fvec16.encode(message.s1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            $root.fvec16.encode(message.s2, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            $root.fvec16.encode(message.s3, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            $root.fvec16.encode(message.s4, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            $root.fvec16.encode(message.s5, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            $root.fvec16.encode(message.s6, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            $root.fvec16.encode(message.s7, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            $root.fvec16.encode(message.s8, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        if (message.s9 != null && Object.hasOwnProperty.call(message, "s9"))
            $root.fvec16.encode(message.s9, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
        if (message.sa != null && Object.hasOwnProperty.call(message, "sa"))
            $root.fvec16.encode(message.sa, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
        if (message.sb != null && Object.hasOwnProperty.call(message, "sb"))
            $root.fvec16.encode(message.sb, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
        if (message.sc != null && Object.hasOwnProperty.call(message, "sc"))
            $root.fvec16.encode(message.sc, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
        if (message.sd != null && Object.hasOwnProperty.call(message, "sd"))
            $root.fvec16.encode(message.sd, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
        if (message.se != null && Object.hasOwnProperty.call(message, "se"))
            $root.fvec16.encode(message.se, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
        if (message.sf != null && Object.hasOwnProperty.call(message, "sf"))
            $root.fvec16.encode(message.sf, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
        return writer;
    };

    /**
     * Decodes a fmat16 message from the specified reader or buffer.
     * @function decode
     * @memberof fmat16
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {fmat16} fmat16
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    fmat16.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.fmat16();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = $root.fvec16.decode(reader, reader.uint32());
                break;
            case 2:
                message.s1 = $root.fvec16.decode(reader, reader.uint32());
                break;
            case 3:
                message.s2 = $root.fvec16.decode(reader, reader.uint32());
                break;
            case 4:
                message.s3 = $root.fvec16.decode(reader, reader.uint32());
                break;
            case 5:
                message.s4 = $root.fvec16.decode(reader, reader.uint32());
                break;
            case 6:
                message.s5 = $root.fvec16.decode(reader, reader.uint32());
                break;
            case 7:
                message.s6 = $root.fvec16.decode(reader, reader.uint32());
                break;
            case 8:
                message.s7 = $root.fvec16.decode(reader, reader.uint32());
                break;
            case 9:
                message.s8 = $root.fvec16.decode(reader, reader.uint32());
                break;
            case 10:
                message.s9 = $root.fvec16.decode(reader, reader.uint32());
                break;
            case 11:
                message.sa = $root.fvec16.decode(reader, reader.uint32());
                break;
            case 12:
                message.sb = $root.fvec16.decode(reader, reader.uint32());
                break;
            case 13:
                message.sc = $root.fvec16.decode(reader, reader.uint32());
                break;
            case 14:
                message.sd = $root.fvec16.decode(reader, reader.uint32());
                break;
            case 15:
                message.se = $root.fvec16.decode(reader, reader.uint32());
                break;
            case 16:
                message.sf = $root.fvec16.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return fmat16;
})();

export const imat16 = $root.imat16 = (() => {

    /**
     * Properties of an imat16.
     * @exports Iimat16
     * @interface Iimat16
     * @property {Iivec16|null} [s0] imat16 s0
     * @property {Iivec16|null} [s1] imat16 s1
     * @property {Iivec16|null} [s2] imat16 s2
     * @property {Iivec16|null} [s3] imat16 s3
     * @property {Iivec16|null} [s4] imat16 s4
     * @property {Iivec16|null} [s5] imat16 s5
     * @property {Iivec16|null} [s6] imat16 s6
     * @property {Iivec16|null} [s7] imat16 s7
     * @property {Iivec16|null} [s8] imat16 s8
     * @property {Iivec16|null} [s9] imat16 s9
     * @property {Iivec16|null} [sa] imat16 sa
     * @property {Iivec16|null} [sb] imat16 sb
     * @property {Iivec16|null} [sc] imat16 sc
     * @property {Iivec16|null} [sd] imat16 sd
     * @property {Iivec16|null} [se] imat16 se
     * @property {Iivec16|null} [sf] imat16 sf
     */

    /**
     * Constructs a new imat16.
     * @exports imat16
     * @classdesc Represents an imat16.
     * @implements Iimat16
     * @constructor
     * @param {Iimat16=} [properties] Properties to set
     */
    function imat16(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * imat16 s0.
     * @member {Iivec16|null|undefined} s0
     * @memberof imat16
     * @instance
     */
    imat16.prototype.s0 = null;

    /**
     * imat16 s1.
     * @member {Iivec16|null|undefined} s1
     * @memberof imat16
     * @instance
     */
    imat16.prototype.s1 = null;

    /**
     * imat16 s2.
     * @member {Iivec16|null|undefined} s2
     * @memberof imat16
     * @instance
     */
    imat16.prototype.s2 = null;

    /**
     * imat16 s3.
     * @member {Iivec16|null|undefined} s3
     * @memberof imat16
     * @instance
     */
    imat16.prototype.s3 = null;

    /**
     * imat16 s4.
     * @member {Iivec16|null|undefined} s4
     * @memberof imat16
     * @instance
     */
    imat16.prototype.s4 = null;

    /**
     * imat16 s5.
     * @member {Iivec16|null|undefined} s5
     * @memberof imat16
     * @instance
     */
    imat16.prototype.s5 = null;

    /**
     * imat16 s6.
     * @member {Iivec16|null|undefined} s6
     * @memberof imat16
     * @instance
     */
    imat16.prototype.s6 = null;

    /**
     * imat16 s7.
     * @member {Iivec16|null|undefined} s7
     * @memberof imat16
     * @instance
     */
    imat16.prototype.s7 = null;

    /**
     * imat16 s8.
     * @member {Iivec16|null|undefined} s8
     * @memberof imat16
     * @instance
     */
    imat16.prototype.s8 = null;

    /**
     * imat16 s9.
     * @member {Iivec16|null|undefined} s9
     * @memberof imat16
     * @instance
     */
    imat16.prototype.s9 = null;

    /**
     * imat16 sa.
     * @member {Iivec16|null|undefined} sa
     * @memberof imat16
     * @instance
     */
    imat16.prototype.sa = null;

    /**
     * imat16 sb.
     * @member {Iivec16|null|undefined} sb
     * @memberof imat16
     * @instance
     */
    imat16.prototype.sb = null;

    /**
     * imat16 sc.
     * @member {Iivec16|null|undefined} sc
     * @memberof imat16
     * @instance
     */
    imat16.prototype.sc = null;

    /**
     * imat16 sd.
     * @member {Iivec16|null|undefined} sd
     * @memberof imat16
     * @instance
     */
    imat16.prototype.sd = null;

    /**
     * imat16 se.
     * @member {Iivec16|null|undefined} se
     * @memberof imat16
     * @instance
     */
    imat16.prototype.se = null;

    /**
     * imat16 sf.
     * @member {Iivec16|null|undefined} sf
     * @memberof imat16
     * @instance
     */
    imat16.prototype.sf = null;

    /**
     * Encodes the specified imat16 message. Does not implicitly {@link imat16.verify|verify} messages.
     * @function encode
     * @memberof imat16
     * @static
     * @param {Iimat16} message imat16 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    imat16.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            $root.ivec16.encode(message.s0, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            $root.ivec16.encode(message.s1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            $root.ivec16.encode(message.s2, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            $root.ivec16.encode(message.s3, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            $root.ivec16.encode(message.s4, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            $root.ivec16.encode(message.s5, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            $root.ivec16.encode(message.s6, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            $root.ivec16.encode(message.s7, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            $root.ivec16.encode(message.s8, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        if (message.s9 != null && Object.hasOwnProperty.call(message, "s9"))
            $root.ivec16.encode(message.s9, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
        if (message.sa != null && Object.hasOwnProperty.call(message, "sa"))
            $root.ivec16.encode(message.sa, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
        if (message.sb != null && Object.hasOwnProperty.call(message, "sb"))
            $root.ivec16.encode(message.sb, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
        if (message.sc != null && Object.hasOwnProperty.call(message, "sc"))
            $root.ivec16.encode(message.sc, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
        if (message.sd != null && Object.hasOwnProperty.call(message, "sd"))
            $root.ivec16.encode(message.sd, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
        if (message.se != null && Object.hasOwnProperty.call(message, "se"))
            $root.ivec16.encode(message.se, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
        if (message.sf != null && Object.hasOwnProperty.call(message, "sf"))
            $root.ivec16.encode(message.sf, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
        return writer;
    };

    /**
     * Decodes an imat16 message from the specified reader or buffer.
     * @function decode
     * @memberof imat16
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {imat16} imat16
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    imat16.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.imat16();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = $root.ivec16.decode(reader, reader.uint32());
                break;
            case 2:
                message.s1 = $root.ivec16.decode(reader, reader.uint32());
                break;
            case 3:
                message.s2 = $root.ivec16.decode(reader, reader.uint32());
                break;
            case 4:
                message.s3 = $root.ivec16.decode(reader, reader.uint32());
                break;
            case 5:
                message.s4 = $root.ivec16.decode(reader, reader.uint32());
                break;
            case 6:
                message.s5 = $root.ivec16.decode(reader, reader.uint32());
                break;
            case 7:
                message.s6 = $root.ivec16.decode(reader, reader.uint32());
                break;
            case 8:
                message.s7 = $root.ivec16.decode(reader, reader.uint32());
                break;
            case 9:
                message.s8 = $root.ivec16.decode(reader, reader.uint32());
                break;
            case 10:
                message.s9 = $root.ivec16.decode(reader, reader.uint32());
                break;
            case 11:
                message.sa = $root.ivec16.decode(reader, reader.uint32());
                break;
            case 12:
                message.sb = $root.ivec16.decode(reader, reader.uint32());
                break;
            case 13:
                message.sc = $root.ivec16.decode(reader, reader.uint32());
                break;
            case 14:
                message.sd = $root.ivec16.decode(reader, reader.uint32());
                break;
            case 15:
                message.se = $root.ivec16.decode(reader, reader.uint32());
                break;
            case 16:
                message.sf = $root.ivec16.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return imat16;
})();

export const umat16 = $root.umat16 = (() => {

    /**
     * Properties of an umat16.
     * @exports Iumat16
     * @interface Iumat16
     * @property {Iuvec16|null} [s0] umat16 s0
     * @property {Iuvec16|null} [s1] umat16 s1
     * @property {Iuvec16|null} [s2] umat16 s2
     * @property {Iuvec16|null} [s3] umat16 s3
     * @property {Iuvec16|null} [s4] umat16 s4
     * @property {Iuvec16|null} [s5] umat16 s5
     * @property {Iuvec16|null} [s6] umat16 s6
     * @property {Iuvec16|null} [s7] umat16 s7
     * @property {Iuvec16|null} [s8] umat16 s8
     * @property {Iuvec16|null} [s9] umat16 s9
     * @property {Iuvec16|null} [sa] umat16 sa
     * @property {Iuvec16|null} [sb] umat16 sb
     * @property {Iuvec16|null} [sc] umat16 sc
     * @property {Iuvec16|null} [sd] umat16 sd
     * @property {Iuvec16|null} [se] umat16 se
     * @property {Iuvec16|null} [sf] umat16 sf
     */

    /**
     * Constructs a new umat16.
     * @exports umat16
     * @classdesc Represents an umat16.
     * @implements Iumat16
     * @constructor
     * @param {Iumat16=} [properties] Properties to set
     */
    function umat16(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * umat16 s0.
     * @member {Iuvec16|null|undefined} s0
     * @memberof umat16
     * @instance
     */
    umat16.prototype.s0 = null;

    /**
     * umat16 s1.
     * @member {Iuvec16|null|undefined} s1
     * @memberof umat16
     * @instance
     */
    umat16.prototype.s1 = null;

    /**
     * umat16 s2.
     * @member {Iuvec16|null|undefined} s2
     * @memberof umat16
     * @instance
     */
    umat16.prototype.s2 = null;

    /**
     * umat16 s3.
     * @member {Iuvec16|null|undefined} s3
     * @memberof umat16
     * @instance
     */
    umat16.prototype.s3 = null;

    /**
     * umat16 s4.
     * @member {Iuvec16|null|undefined} s4
     * @memberof umat16
     * @instance
     */
    umat16.prototype.s4 = null;

    /**
     * umat16 s5.
     * @member {Iuvec16|null|undefined} s5
     * @memberof umat16
     * @instance
     */
    umat16.prototype.s5 = null;

    /**
     * umat16 s6.
     * @member {Iuvec16|null|undefined} s6
     * @memberof umat16
     * @instance
     */
    umat16.prototype.s6 = null;

    /**
     * umat16 s7.
     * @member {Iuvec16|null|undefined} s7
     * @memberof umat16
     * @instance
     */
    umat16.prototype.s7 = null;

    /**
     * umat16 s8.
     * @member {Iuvec16|null|undefined} s8
     * @memberof umat16
     * @instance
     */
    umat16.prototype.s8 = null;

    /**
     * umat16 s9.
     * @member {Iuvec16|null|undefined} s9
     * @memberof umat16
     * @instance
     */
    umat16.prototype.s9 = null;

    /**
     * umat16 sa.
     * @member {Iuvec16|null|undefined} sa
     * @memberof umat16
     * @instance
     */
    umat16.prototype.sa = null;

    /**
     * umat16 sb.
     * @member {Iuvec16|null|undefined} sb
     * @memberof umat16
     * @instance
     */
    umat16.prototype.sb = null;

    /**
     * umat16 sc.
     * @member {Iuvec16|null|undefined} sc
     * @memberof umat16
     * @instance
     */
    umat16.prototype.sc = null;

    /**
     * umat16 sd.
     * @member {Iuvec16|null|undefined} sd
     * @memberof umat16
     * @instance
     */
    umat16.prototype.sd = null;

    /**
     * umat16 se.
     * @member {Iuvec16|null|undefined} se
     * @memberof umat16
     * @instance
     */
    umat16.prototype.se = null;

    /**
     * umat16 sf.
     * @member {Iuvec16|null|undefined} sf
     * @memberof umat16
     * @instance
     */
    umat16.prototype.sf = null;

    /**
     * Encodes the specified umat16 message. Does not implicitly {@link umat16.verify|verify} messages.
     * @function encode
     * @memberof umat16
     * @static
     * @param {Iumat16} message umat16 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    umat16.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.s0 != null && Object.hasOwnProperty.call(message, "s0"))
            $root.uvec16.encode(message.s0, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.s1 != null && Object.hasOwnProperty.call(message, "s1"))
            $root.uvec16.encode(message.s1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.s2 != null && Object.hasOwnProperty.call(message, "s2"))
            $root.uvec16.encode(message.s2, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.s3 != null && Object.hasOwnProperty.call(message, "s3"))
            $root.uvec16.encode(message.s3, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.s4 != null && Object.hasOwnProperty.call(message, "s4"))
            $root.uvec16.encode(message.s4, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.s5 != null && Object.hasOwnProperty.call(message, "s5"))
            $root.uvec16.encode(message.s5, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.s6 != null && Object.hasOwnProperty.call(message, "s6"))
            $root.uvec16.encode(message.s6, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.s7 != null && Object.hasOwnProperty.call(message, "s7"))
            $root.uvec16.encode(message.s7, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        if (message.s8 != null && Object.hasOwnProperty.call(message, "s8"))
            $root.uvec16.encode(message.s8, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        if (message.s9 != null && Object.hasOwnProperty.call(message, "s9"))
            $root.uvec16.encode(message.s9, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
        if (message.sa != null && Object.hasOwnProperty.call(message, "sa"))
            $root.uvec16.encode(message.sa, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
        if (message.sb != null && Object.hasOwnProperty.call(message, "sb"))
            $root.uvec16.encode(message.sb, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
        if (message.sc != null && Object.hasOwnProperty.call(message, "sc"))
            $root.uvec16.encode(message.sc, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
        if (message.sd != null && Object.hasOwnProperty.call(message, "sd"))
            $root.uvec16.encode(message.sd, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
        if (message.se != null && Object.hasOwnProperty.call(message, "se"))
            $root.uvec16.encode(message.se, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
        if (message.sf != null && Object.hasOwnProperty.call(message, "sf"))
            $root.uvec16.encode(message.sf, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
        return writer;
    };

    /**
     * Decodes an umat16 message from the specified reader or buffer.
     * @function decode
     * @memberof umat16
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {umat16} umat16
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    umat16.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.umat16();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.s0 = $root.uvec16.decode(reader, reader.uint32());
                break;
            case 2:
                message.s1 = $root.uvec16.decode(reader, reader.uint32());
                break;
            case 3:
                message.s2 = $root.uvec16.decode(reader, reader.uint32());
                break;
            case 4:
                message.s3 = $root.uvec16.decode(reader, reader.uint32());
                break;
            case 5:
                message.s4 = $root.uvec16.decode(reader, reader.uint32());
                break;
            case 6:
                message.s5 = $root.uvec16.decode(reader, reader.uint32());
                break;
            case 7:
                message.s6 = $root.uvec16.decode(reader, reader.uint32());
                break;
            case 8:
                message.s7 = $root.uvec16.decode(reader, reader.uint32());
                break;
            case 9:
                message.s8 = $root.uvec16.decode(reader, reader.uint32());
                break;
            case 10:
                message.s9 = $root.uvec16.decode(reader, reader.uint32());
                break;
            case 11:
                message.sa = $root.uvec16.decode(reader, reader.uint32());
                break;
            case 12:
                message.sb = $root.uvec16.decode(reader, reader.uint32());
                break;
            case 13:
                message.sc = $root.uvec16.decode(reader, reader.uint32());
                break;
            case 14:
                message.sd = $root.uvec16.decode(reader, reader.uint32());
                break;
            case 15:
                message.se = $root.uvec16.decode(reader, reader.uint32());
                break;
            case 16:
                message.sf = $root.uvec16.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    return umat16;
})();

export const google = $root.google = (() => {

    /**
     * Namespace google.
     * @exports google
     * @namespace
     */
    const google = {};

    google.protobuf = (function() {

        /**
         * Namespace protobuf.
         * @memberof google
         * @namespace
         */
        const protobuf = {};

        protobuf.Timestamp = (function() {

            /**
             * Properties of a Timestamp.
             * @memberof google.protobuf
             * @interface ITimestamp
             * @property {number|Long|null} [seconds] Timestamp seconds
             * @property {number|null} [nanos] Timestamp nanos
             */

            /**
             * Constructs a new Timestamp.
             * @memberof google.protobuf
             * @classdesc Represents a Timestamp.
             * @implements ITimestamp
             * @constructor
             * @param {google.protobuf.ITimestamp=} [properties] Properties to set
             */
            function Timestamp(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Timestamp seconds.
             * @member {number|Long} seconds
             * @memberof google.protobuf.Timestamp
             * @instance
             */
            Timestamp.prototype.seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Timestamp nanos.
             * @member {number} nanos
             * @memberof google.protobuf.Timestamp
             * @instance
             */
            Timestamp.prototype.nanos = 0;

            /**
             * Encodes the specified Timestamp message. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {google.protobuf.ITimestamp} message Timestamp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Timestamp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.seconds != null && Object.hasOwnProperty.call(message, "seconds"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.seconds);
                if (message.nanos != null && Object.hasOwnProperty.call(message, "nanos"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.nanos);
                return writer;
            };

            /**
             * Decodes a Timestamp message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Timestamp} Timestamp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Timestamp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Timestamp();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.seconds = reader.int64();
                        break;
                    case 2:
                        message.nanos = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return Timestamp;
        })();

        protobuf.FileDescriptorSet = (function() {

            /**
             * Properties of a FileDescriptorSet.
             * @memberof google.protobuf
             * @interface IFileDescriptorSet
             * @property {Array.<google.protobuf.IFileDescriptorProto>|null} [file] FileDescriptorSet file
             */

            /**
             * Constructs a new FileDescriptorSet.
             * @memberof google.protobuf
             * @classdesc Represents a FileDescriptorSet.
             * @implements IFileDescriptorSet
             * @constructor
             * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set
             */
            function FileDescriptorSet(properties) {
                this.file = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FileDescriptorSet file.
             * @member {Array.<google.protobuf.IFileDescriptorProto>} file
             * @memberof google.protobuf.FileDescriptorSet
             * @instance
             */
            FileDescriptorSet.prototype.file = $util.emptyArray;

            /**
             * Encodes the specified FileDescriptorSet message. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {google.protobuf.IFileDescriptorSet} message FileDescriptorSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileDescriptorSet.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.file != null && message.file.length)
                    for (let i = 0; i < message.file.length; ++i)
                        $root.google.protobuf.FileDescriptorProto.encode(message.file[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a FileDescriptorSet message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileDescriptorSet.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorSet();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.file && message.file.length))
                            message.file = [];
                        message.file.push($root.google.protobuf.FileDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return FileDescriptorSet;
        })();

        protobuf.FileDescriptorProto = (function() {

            /**
             * Properties of a FileDescriptorProto.
             * @memberof google.protobuf
             * @interface IFileDescriptorProto
             * @property {string|null} [name] FileDescriptorProto name
             * @property {string|null} ["package"] FileDescriptorProto package
             * @property {Array.<string>|null} [dependency] FileDescriptorProto dependency
             * @property {Array.<number>|null} [publicDependency] FileDescriptorProto publicDependency
             * @property {Array.<number>|null} [weakDependency] FileDescriptorProto weakDependency
             * @property {Array.<google.protobuf.IDescriptorProto>|null} [messageType] FileDescriptorProto messageType
             * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enumType] FileDescriptorProto enumType
             * @property {Array.<google.protobuf.IServiceDescriptorProto>|null} [service] FileDescriptorProto service
             * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] FileDescriptorProto extension
             * @property {google.protobuf.IFileOptions|null} [options] FileDescriptorProto options
             * @property {google.protobuf.ISourceCodeInfo|null} [sourceCodeInfo] FileDescriptorProto sourceCodeInfo
             * @property {string|null} [syntax] FileDescriptorProto syntax
             */

            /**
             * Constructs a new FileDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a FileDescriptorProto.
             * @implements IFileDescriptorProto
             * @constructor
             * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set
             */
            function FileDescriptorProto(properties) {
                this.dependency = [];
                this.publicDependency = [];
                this.weakDependency = [];
                this.messageType = [];
                this.enumType = [];
                this.service = [];
                this.extension = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FileDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.name = "";

            /**
             * FileDescriptorProto package.
             * @member {string} package
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype["package"] = "";

            /**
             * FileDescriptorProto dependency.
             * @member {Array.<string>} dependency
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.dependency = $util.emptyArray;

            /**
             * FileDescriptorProto publicDependency.
             * @member {Array.<number>} publicDependency
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.publicDependency = $util.emptyArray;

            /**
             * FileDescriptorProto weakDependency.
             * @member {Array.<number>} weakDependency
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.weakDependency = $util.emptyArray;

            /**
             * FileDescriptorProto messageType.
             * @member {Array.<google.protobuf.IDescriptorProto>} messageType
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.messageType = $util.emptyArray;

            /**
             * FileDescriptorProto enumType.
             * @member {Array.<google.protobuf.IEnumDescriptorProto>} enumType
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.enumType = $util.emptyArray;

            /**
             * FileDescriptorProto service.
             * @member {Array.<google.protobuf.IServiceDescriptorProto>} service
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.service = $util.emptyArray;

            /**
             * FileDescriptorProto extension.
             * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.extension = $util.emptyArray;

            /**
             * FileDescriptorProto options.
             * @member {google.protobuf.IFileOptions|null|undefined} options
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.options = null;

            /**
             * FileDescriptorProto sourceCodeInfo.
             * @member {google.protobuf.ISourceCodeInfo|null|undefined} sourceCodeInfo
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.sourceCodeInfo = null;

            /**
             * FileDescriptorProto syntax.
             * @member {string} syntax
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.syntax = "";

            /**
             * Encodes the specified FileDescriptorProto message. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {google.protobuf.IFileDescriptorProto} message FileDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message["package"] != null && Object.hasOwnProperty.call(message, "package"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message["package"]);
                if (message.dependency != null && message.dependency.length)
                    for (let i = 0; i < message.dependency.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.dependency[i]);
                if (message.messageType != null && message.messageType.length)
                    for (let i = 0; i < message.messageType.length; ++i)
                        $root.google.protobuf.DescriptorProto.encode(message.messageType[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.enumType != null && message.enumType.length)
                    for (let i = 0; i < message.enumType.length; ++i)
                        $root.google.protobuf.EnumDescriptorProto.encode(message.enumType[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.service != null && message.service.length)
                    for (let i = 0; i < message.service.length; ++i)
                        $root.google.protobuf.ServiceDescriptorProto.encode(message.service[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.extension != null && message.extension.length)
                    for (let i = 0; i < message.extension.length; ++i)
                        $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                    $root.google.protobuf.FileOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.sourceCodeInfo != null && Object.hasOwnProperty.call(message, "sourceCodeInfo"))
                    $root.google.protobuf.SourceCodeInfo.encode(message.sourceCodeInfo, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.publicDependency != null && message.publicDependency.length)
                    for (let i = 0; i < message.publicDependency.length; ++i)
                        writer.uint32(/* id 10, wireType 0 =*/80).int32(message.publicDependency[i]);
                if (message.weakDependency != null && message.weakDependency.length)
                    for (let i = 0; i < message.weakDependency.length; ++i)
                        writer.uint32(/* id 11, wireType 0 =*/88).int32(message.weakDependency[i]);
                if (message.syntax != null && Object.hasOwnProperty.call(message, "syntax"))
                    writer.uint32(/* id 12, wireType 2 =*/98).string(message.syntax);
                return writer;
            };

            /**
             * Decodes a FileDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message["package"] = reader.string();
                        break;
                    case 3:
                        if (!(message.dependency && message.dependency.length))
                            message.dependency = [];
                        message.dependency.push(reader.string());
                        break;
                    case 10:
                        if (!(message.publicDependency && message.publicDependency.length))
                            message.publicDependency = [];
                        if ((tag & 7) === 2) {
                            let end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.publicDependency.push(reader.int32());
                        } else
                            message.publicDependency.push(reader.int32());
                        break;
                    case 11:
                        if (!(message.weakDependency && message.weakDependency.length))
                            message.weakDependency = [];
                        if ((tag & 7) === 2) {
                            let end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.weakDependency.push(reader.int32());
                        } else
                            message.weakDependency.push(reader.int32());
                        break;
                    case 4:
                        if (!(message.messageType && message.messageType.length))
                            message.messageType = [];
                        message.messageType.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.enumType && message.enumType.length))
                            message.enumType = [];
                        message.enumType.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.service && message.service.length))
                            message.service = [];
                        message.service.push($root.google.protobuf.ServiceDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        if (!(message.extension && message.extension.length))
                            message.extension = [];
                        message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        message.options = $root.google.protobuf.FileOptions.decode(reader, reader.uint32());
                        break;
                    case 9:
                        message.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.decode(reader, reader.uint32());
                        break;
                    case 12:
                        message.syntax = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return FileDescriptorProto;
        })();

        protobuf.DescriptorProto = (function() {

            /**
             * Properties of a DescriptorProto.
             * @memberof google.protobuf
             * @interface IDescriptorProto
             * @property {string|null} [name] DescriptorProto name
             * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [field] DescriptorProto field
             * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] DescriptorProto extension
             * @property {Array.<google.protobuf.IDescriptorProto>|null} [nestedType] DescriptorProto nestedType
             * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enumType] DescriptorProto enumType
             * @property {Array.<google.protobuf.DescriptorProto.IExtensionRange>|null} [extensionRange] DescriptorProto extensionRange
             * @property {Array.<google.protobuf.IOneofDescriptorProto>|null} [oneofDecl] DescriptorProto oneofDecl
             * @property {google.protobuf.IMessageOptions|null} [options] DescriptorProto options
             * @property {Array.<google.protobuf.DescriptorProto.IReservedRange>|null} [reservedRange] DescriptorProto reservedRange
             * @property {Array.<string>|null} [reservedName] DescriptorProto reservedName
             */

            /**
             * Constructs a new DescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a DescriptorProto.
             * @implements IDescriptorProto
             * @constructor
             * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set
             */
            function DescriptorProto(properties) {
                this.field = [];
                this.extension = [];
                this.nestedType = [];
                this.enumType = [];
                this.extensionRange = [];
                this.oneofDecl = [];
                this.reservedRange = [];
                this.reservedName = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.name = "";

            /**
             * DescriptorProto field.
             * @member {Array.<google.protobuf.IFieldDescriptorProto>} field
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.field = $util.emptyArray;

            /**
             * DescriptorProto extension.
             * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.extension = $util.emptyArray;

            /**
             * DescriptorProto nestedType.
             * @member {Array.<google.protobuf.IDescriptorProto>} nestedType
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.nestedType = $util.emptyArray;

            /**
             * DescriptorProto enumType.
             * @member {Array.<google.protobuf.IEnumDescriptorProto>} enumType
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.enumType = $util.emptyArray;

            /**
             * DescriptorProto extensionRange.
             * @member {Array.<google.protobuf.DescriptorProto.IExtensionRange>} extensionRange
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.extensionRange = $util.emptyArray;

            /**
             * DescriptorProto oneofDecl.
             * @member {Array.<google.protobuf.IOneofDescriptorProto>} oneofDecl
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.oneofDecl = $util.emptyArray;

            /**
             * DescriptorProto options.
             * @member {google.protobuf.IMessageOptions|null|undefined} options
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.options = null;

            /**
             * DescriptorProto reservedRange.
             * @member {Array.<google.protobuf.DescriptorProto.IReservedRange>} reservedRange
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.reservedRange = $util.emptyArray;

            /**
             * DescriptorProto reservedName.
             * @member {Array.<string>} reservedName
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.reservedName = $util.emptyArray;

            /**
             * Encodes the specified DescriptorProto message. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {google.protobuf.IDescriptorProto} message DescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.field != null && message.field.length)
                    for (let i = 0; i < message.field.length; ++i)
                        $root.google.protobuf.FieldDescriptorProto.encode(message.field[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.nestedType != null && message.nestedType.length)
                    for (let i = 0; i < message.nestedType.length; ++i)
                        $root.google.protobuf.DescriptorProto.encode(message.nestedType[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.enumType != null && message.enumType.length)
                    for (let i = 0; i < message.enumType.length; ++i)
                        $root.google.protobuf.EnumDescriptorProto.encode(message.enumType[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.extensionRange != null && message.extensionRange.length)
                    for (let i = 0; i < message.extensionRange.length; ++i)
                        $root.google.protobuf.DescriptorProto.ExtensionRange.encode(message.extensionRange[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.extension != null && message.extension.length)
                    for (let i = 0; i < message.extension.length; ++i)
                        $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                    $root.google.protobuf.MessageOptions.encode(message.options, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.oneofDecl != null && message.oneofDecl.length)
                    for (let i = 0; i < message.oneofDecl.length; ++i)
                        $root.google.protobuf.OneofDescriptorProto.encode(message.oneofDecl[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.reservedRange != null && message.reservedRange.length)
                    for (let i = 0; i < message.reservedRange.length; ++i)
                        $root.google.protobuf.DescriptorProto.ReservedRange.encode(message.reservedRange[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.reservedName != null && message.reservedName.length)
                    for (let i = 0; i < message.reservedName.length; ++i)
                        writer.uint32(/* id 10, wireType 2 =*/82).string(message.reservedName[i]);
                return writer;
            };

            /**
             * Decodes a DescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.DescriptorProto} DescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        if (!(message.field && message.field.length))
                            message.field = [];
                        message.field.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.extension && message.extension.length))
                            message.extension = [];
                        message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.nestedType && message.nestedType.length))
                            message.nestedType = [];
                        message.nestedType.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        if (!(message.enumType && message.enumType.length))
                            message.enumType = [];
                        message.enumType.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.extensionRange && message.extensionRange.length))
                            message.extensionRange = [];
                        message.extensionRange.push($root.google.protobuf.DescriptorProto.ExtensionRange.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        if (!(message.oneofDecl && message.oneofDecl.length))
                            message.oneofDecl = [];
                        message.oneofDecl.push($root.google.protobuf.OneofDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        message.options = $root.google.protobuf.MessageOptions.decode(reader, reader.uint32());
                        break;
                    case 9:
                        if (!(message.reservedRange && message.reservedRange.length))
                            message.reservedRange = [];
                        message.reservedRange.push($root.google.protobuf.DescriptorProto.ReservedRange.decode(reader, reader.uint32()));
                        break;
                    case 10:
                        if (!(message.reservedName && message.reservedName.length))
                            message.reservedName = [];
                        message.reservedName.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            DescriptorProto.ExtensionRange = (function() {

                /**
                 * Properties of an ExtensionRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @interface IExtensionRange
                 * @property {number|null} [start] ExtensionRange start
                 * @property {number|null} [end] ExtensionRange end
                 */

                /**
                 * Constructs a new ExtensionRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @classdesc Represents an ExtensionRange.
                 * @implements IExtensionRange
                 * @constructor
                 * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set
                 */
                function ExtensionRange(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ExtensionRange start.
                 * @member {number} start
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @instance
                 */
                ExtensionRange.prototype.start = 0;

                /**
                 * ExtensionRange end.
                 * @member {number} end
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @instance
                 */
                ExtensionRange.prototype.end = 0;

                /**
                 * Encodes the specified ExtensionRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IExtensionRange} message ExtensionRange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExtensionRange.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.start != null && Object.hasOwnProperty.call(message, "start"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.start);
                    if (message.end != null && Object.hasOwnProperty.call(message, "end"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);
                    return writer;
                };

                /**
                 * Decodes an ExtensionRange message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExtensionRange.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.start = reader.int32();
                            break;
                        case 2:
                            message.end = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return ExtensionRange;
            })();

            DescriptorProto.ReservedRange = (function() {

                /**
                 * Properties of a ReservedRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @interface IReservedRange
                 * @property {number|null} [start] ReservedRange start
                 * @property {number|null} [end] ReservedRange end
                 */

                /**
                 * Constructs a new ReservedRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @classdesc Represents a ReservedRange.
                 * @implements IReservedRange
                 * @constructor
                 * @param {google.protobuf.DescriptorProto.IReservedRange=} [properties] Properties to set
                 */
                function ReservedRange(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ReservedRange start.
                 * @member {number} start
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @instance
                 */
                ReservedRange.prototype.start = 0;

                /**
                 * ReservedRange end.
                 * @member {number} end
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @instance
                 */
                ReservedRange.prototype.end = 0;

                /**
                 * Encodes the specified ReservedRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ReservedRange.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IReservedRange} message ReservedRange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReservedRange.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.start != null && Object.hasOwnProperty.call(message, "start"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.start);
                    if (message.end != null && Object.hasOwnProperty.call(message, "end"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);
                    return writer;
                };

                /**
                 * Decodes a ReservedRange message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReservedRange.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto.ReservedRange();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.start = reader.int32();
                            break;
                        case 2:
                            message.end = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return ReservedRange;
            })();

            return DescriptorProto;
        })();

        protobuf.FieldDescriptorProto = (function() {

            /**
             * Properties of a FieldDescriptorProto.
             * @memberof google.protobuf
             * @interface IFieldDescriptorProto
             * @property {string|null} [name] FieldDescriptorProto name
             * @property {number|null} [number] FieldDescriptorProto number
             * @property {google.protobuf.FieldDescriptorProto.Label|null} [label] FieldDescriptorProto label
             * @property {google.protobuf.FieldDescriptorProto.Type|null} [type] FieldDescriptorProto type
             * @property {string|null} [typeName] FieldDescriptorProto typeName
             * @property {string|null} [extendee] FieldDescriptorProto extendee
             * @property {string|null} [defaultValue] FieldDescriptorProto defaultValue
             * @property {number|null} [oneofIndex] FieldDescriptorProto oneofIndex
             * @property {string|null} [jsonName] FieldDescriptorProto jsonName
             * @property {google.protobuf.IFieldOptions|null} [options] FieldDescriptorProto options
             */

            /**
             * Constructs a new FieldDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a FieldDescriptorProto.
             * @implements IFieldDescriptorProto
             * @constructor
             * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set
             */
            function FieldDescriptorProto(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FieldDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.name = "";

            /**
             * FieldDescriptorProto number.
             * @member {number} number
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.number = 0;

            /**
             * FieldDescriptorProto label.
             * @member {google.protobuf.FieldDescriptorProto.Label} label
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.label = 1;

            /**
             * FieldDescriptorProto type.
             * @member {google.protobuf.FieldDescriptorProto.Type} type
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.type = 1;

            /**
             * FieldDescriptorProto typeName.
             * @member {string} typeName
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.typeName = "";

            /**
             * FieldDescriptorProto extendee.
             * @member {string} extendee
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.extendee = "";

            /**
             * FieldDescriptorProto defaultValue.
             * @member {string} defaultValue
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.defaultValue = "";

            /**
             * FieldDescriptorProto oneofIndex.
             * @member {number} oneofIndex
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.oneofIndex = 0;

            /**
             * FieldDescriptorProto jsonName.
             * @member {string} jsonName
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.jsonName = "";

            /**
             * FieldDescriptorProto options.
             * @member {google.protobuf.IFieldOptions|null|undefined} options
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.options = null;

            /**
             * Encodes the specified FieldDescriptorProto message. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {google.protobuf.IFieldDescriptorProto} message FieldDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.extendee != null && Object.hasOwnProperty.call(message, "extendee"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.extendee);
                if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.number);
                if (message.label != null && Object.hasOwnProperty.call(message, "label"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.label);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.type);
                if (message.typeName != null && Object.hasOwnProperty.call(message, "typeName"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.typeName);
                if (message.defaultValue != null && Object.hasOwnProperty.call(message, "defaultValue"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.defaultValue);
                if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                    $root.google.protobuf.FieldOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.oneofIndex != null && Object.hasOwnProperty.call(message, "oneofIndex"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.oneofIndex);
                if (message.jsonName != null && Object.hasOwnProperty.call(message, "jsonName"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.jsonName);
                return writer;
            };

            /**
             * Decodes a FieldDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 3:
                        message.number = reader.int32();
                        break;
                    case 4:
                        message.label = reader.int32();
                        break;
                    case 5:
                        message.type = reader.int32();
                        break;
                    case 6:
                        message.typeName = reader.string();
                        break;
                    case 2:
                        message.extendee = reader.string();
                        break;
                    case 7:
                        message.defaultValue = reader.string();
                        break;
                    case 9:
                        message.oneofIndex = reader.int32();
                        break;
                    case 10:
                        message.jsonName = reader.string();
                        break;
                    case 8:
                        message.options = $root.google.protobuf.FieldOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Type enum.
             * @name google.protobuf.FieldDescriptorProto.Type
             * @enum {number}
             * @property {number} TYPE_DOUBLE=1 TYPE_DOUBLE value
             * @property {number} TYPE_FLOAT=2 TYPE_FLOAT value
             * @property {number} TYPE_INT64=3 TYPE_INT64 value
             * @property {number} TYPE_UINT64=4 TYPE_UINT64 value
             * @property {number} TYPE_INT32=5 TYPE_INT32 value
             * @property {number} TYPE_FIXED64=6 TYPE_FIXED64 value
             * @property {number} TYPE_FIXED32=7 TYPE_FIXED32 value
             * @property {number} TYPE_BOOL=8 TYPE_BOOL value
             * @property {number} TYPE_STRING=9 TYPE_STRING value
             * @property {number} TYPE_GROUP=10 TYPE_GROUP value
             * @property {number} TYPE_MESSAGE=11 TYPE_MESSAGE value
             * @property {number} TYPE_BYTES=12 TYPE_BYTES value
             * @property {number} TYPE_UINT32=13 TYPE_UINT32 value
             * @property {number} TYPE_ENUM=14 TYPE_ENUM value
             * @property {number} TYPE_SFIXED32=15 TYPE_SFIXED32 value
             * @property {number} TYPE_SFIXED64=16 TYPE_SFIXED64 value
             * @property {number} TYPE_SINT32=17 TYPE_SINT32 value
             * @property {number} TYPE_SINT64=18 TYPE_SINT64 value
             */
            FieldDescriptorProto.Type = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "TYPE_DOUBLE"] = 1;
                values[valuesById[2] = "TYPE_FLOAT"] = 2;
                values[valuesById[3] = "TYPE_INT64"] = 3;
                values[valuesById[4] = "TYPE_UINT64"] = 4;
                values[valuesById[5] = "TYPE_INT32"] = 5;
                values[valuesById[6] = "TYPE_FIXED64"] = 6;
                values[valuesById[7] = "TYPE_FIXED32"] = 7;
                values[valuesById[8] = "TYPE_BOOL"] = 8;
                values[valuesById[9] = "TYPE_STRING"] = 9;
                values[valuesById[10] = "TYPE_GROUP"] = 10;
                values[valuesById[11] = "TYPE_MESSAGE"] = 11;
                values[valuesById[12] = "TYPE_BYTES"] = 12;
                values[valuesById[13] = "TYPE_UINT32"] = 13;
                values[valuesById[14] = "TYPE_ENUM"] = 14;
                values[valuesById[15] = "TYPE_SFIXED32"] = 15;
                values[valuesById[16] = "TYPE_SFIXED64"] = 16;
                values[valuesById[17] = "TYPE_SINT32"] = 17;
                values[valuesById[18] = "TYPE_SINT64"] = 18;
                return values;
            })();

            /**
             * Label enum.
             * @name google.protobuf.FieldDescriptorProto.Label
             * @enum {number}
             * @property {number} LABEL_OPTIONAL=1 LABEL_OPTIONAL value
             * @property {number} LABEL_REQUIRED=2 LABEL_REQUIRED value
             * @property {number} LABEL_REPEATED=3 LABEL_REPEATED value
             */
            FieldDescriptorProto.Label = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "LABEL_OPTIONAL"] = 1;
                values[valuesById[2] = "LABEL_REQUIRED"] = 2;
                values[valuesById[3] = "LABEL_REPEATED"] = 3;
                return values;
            })();

            return FieldDescriptorProto;
        })();

        protobuf.OneofDescriptorProto = (function() {

            /**
             * Properties of an OneofDescriptorProto.
             * @memberof google.protobuf
             * @interface IOneofDescriptorProto
             * @property {string|null} [name] OneofDescriptorProto name
             * @property {google.protobuf.IOneofOptions|null} [options] OneofDescriptorProto options
             */

            /**
             * Constructs a new OneofDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents an OneofDescriptorProto.
             * @implements IOneofDescriptorProto
             * @constructor
             * @param {google.protobuf.IOneofDescriptorProto=} [properties] Properties to set
             */
            function OneofDescriptorProto(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * OneofDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.OneofDescriptorProto
             * @instance
             */
            OneofDescriptorProto.prototype.name = "";

            /**
             * OneofDescriptorProto options.
             * @member {google.protobuf.IOneofOptions|null|undefined} options
             * @memberof google.protobuf.OneofDescriptorProto
             * @instance
             */
            OneofDescriptorProto.prototype.options = null;

            /**
             * Encodes the specified OneofDescriptorProto message. Does not implicitly {@link google.protobuf.OneofDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {google.protobuf.IOneofDescriptorProto} message OneofDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OneofDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                    $root.google.protobuf.OneofOptions.encode(message.options, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes an OneofDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OneofDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.OneofDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.options = $root.google.protobuf.OneofOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return OneofDescriptorProto;
        })();

        protobuf.EnumDescriptorProto = (function() {

            /**
             * Properties of an EnumDescriptorProto.
             * @memberof google.protobuf
             * @interface IEnumDescriptorProto
             * @property {string|null} [name] EnumDescriptorProto name
             * @property {Array.<google.protobuf.IEnumValueDescriptorProto>|null} [value] EnumDescriptorProto value
             * @property {google.protobuf.IEnumOptions|null} [options] EnumDescriptorProto options
             */

            /**
             * Constructs a new EnumDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents an EnumDescriptorProto.
             * @implements IEnumDescriptorProto
             * @constructor
             * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set
             */
            function EnumDescriptorProto(properties) {
                this.value = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             */
            EnumDescriptorProto.prototype.name = "";

            /**
             * EnumDescriptorProto value.
             * @member {Array.<google.protobuf.IEnumValueDescriptorProto>} value
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             */
            EnumDescriptorProto.prototype.value = $util.emptyArray;

            /**
             * EnumDescriptorProto options.
             * @member {google.protobuf.IEnumOptions|null|undefined} options
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             */
            EnumDescriptorProto.prototype.options = null;

            /**
             * Encodes the specified EnumDescriptorProto message. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {google.protobuf.IEnumDescriptorProto} message EnumDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.value != null && message.value.length)
                    for (let i = 0; i < message.value.length; ++i)
                        $root.google.protobuf.EnumValueDescriptorProto.encode(message.value[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                    $root.google.protobuf.EnumOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes an EnumDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        if (!(message.value && message.value.length))
                            message.value = [];
                        message.value.push($root.google.protobuf.EnumValueDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.options = $root.google.protobuf.EnumOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return EnumDescriptorProto;
        })();

        protobuf.EnumValueDescriptorProto = (function() {

            /**
             * Properties of an EnumValueDescriptorProto.
             * @memberof google.protobuf
             * @interface IEnumValueDescriptorProto
             * @property {string|null} [name] EnumValueDescriptorProto name
             * @property {number|null} [number] EnumValueDescriptorProto number
             * @property {google.protobuf.IEnumValueOptions|null} [options] EnumValueDescriptorProto options
             */

            /**
             * Constructs a new EnumValueDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents an EnumValueDescriptorProto.
             * @implements IEnumValueDescriptorProto
             * @constructor
             * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set
             */
            function EnumValueDescriptorProto(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumValueDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @instance
             */
            EnumValueDescriptorProto.prototype.name = "";

            /**
             * EnumValueDescriptorProto number.
             * @member {number} number
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @instance
             */
            EnumValueDescriptorProto.prototype.number = 0;

            /**
             * EnumValueDescriptorProto options.
             * @member {google.protobuf.IEnumValueOptions|null|undefined} options
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @instance
             */
            EnumValueDescriptorProto.prototype.options = null;

            /**
             * Encodes the specified EnumValueDescriptorProto message. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {google.protobuf.IEnumValueDescriptorProto} message EnumValueDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumValueDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.number);
                if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                    $root.google.protobuf.EnumValueOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes an EnumValueDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumValueDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.number = reader.int32();
                        break;
                    case 3:
                        message.options = $root.google.protobuf.EnumValueOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return EnumValueDescriptorProto;
        })();

        protobuf.ServiceDescriptorProto = (function() {

            /**
             * Properties of a ServiceDescriptorProto.
             * @memberof google.protobuf
             * @interface IServiceDescriptorProto
             * @property {string|null} [name] ServiceDescriptorProto name
             * @property {Array.<google.protobuf.IMethodDescriptorProto>|null} [method] ServiceDescriptorProto method
             * @property {google.protobuf.IServiceOptions|null} [options] ServiceDescriptorProto options
             */

            /**
             * Constructs a new ServiceDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a ServiceDescriptorProto.
             * @implements IServiceDescriptorProto
             * @constructor
             * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set
             */
            function ServiceDescriptorProto(properties) {
                this.method = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ServiceDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.ServiceDescriptorProto
             * @instance
             */
            ServiceDescriptorProto.prototype.name = "";

            /**
             * ServiceDescriptorProto method.
             * @member {Array.<google.protobuf.IMethodDescriptorProto>} method
             * @memberof google.protobuf.ServiceDescriptorProto
             * @instance
             */
            ServiceDescriptorProto.prototype.method = $util.emptyArray;

            /**
             * ServiceDescriptorProto options.
             * @member {google.protobuf.IServiceOptions|null|undefined} options
             * @memberof google.protobuf.ServiceDescriptorProto
             * @instance
             */
            ServiceDescriptorProto.prototype.options = null;

            /**
             * Encodes the specified ServiceDescriptorProto message. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {google.protobuf.IServiceDescriptorProto} message ServiceDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServiceDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.method != null && message.method.length)
                    for (let i = 0; i < message.method.length; ++i)
                        $root.google.protobuf.MethodDescriptorProto.encode(message.method[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                    $root.google.protobuf.ServiceOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a ServiceDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServiceDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        if (!(message.method && message.method.length))
                            message.method = [];
                        message.method.push($root.google.protobuf.MethodDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.options = $root.google.protobuf.ServiceOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return ServiceDescriptorProto;
        })();

        protobuf.MethodDescriptorProto = (function() {

            /**
             * Properties of a MethodDescriptorProto.
             * @memberof google.protobuf
             * @interface IMethodDescriptorProto
             * @property {string|null} [name] MethodDescriptorProto name
             * @property {string|null} [inputType] MethodDescriptorProto inputType
             * @property {string|null} [outputType] MethodDescriptorProto outputType
             * @property {google.protobuf.IMethodOptions|null} [options] MethodDescriptorProto options
             * @property {boolean|null} [clientStreaming] MethodDescriptorProto clientStreaming
             * @property {boolean|null} [serverStreaming] MethodDescriptorProto serverStreaming
             */

            /**
             * Constructs a new MethodDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a MethodDescriptorProto.
             * @implements IMethodDescriptorProto
             * @constructor
             * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set
             */
            function MethodDescriptorProto(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MethodDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.name = "";

            /**
             * MethodDescriptorProto inputType.
             * @member {string} inputType
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.inputType = "";

            /**
             * MethodDescriptorProto outputType.
             * @member {string} outputType
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.outputType = "";

            /**
             * MethodDescriptorProto options.
             * @member {google.protobuf.IMethodOptions|null|undefined} options
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.options = null;

            /**
             * MethodDescriptorProto clientStreaming.
             * @member {boolean} clientStreaming
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.clientStreaming = false;

            /**
             * MethodDescriptorProto serverStreaming.
             * @member {boolean} serverStreaming
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.serverStreaming = false;

            /**
             * Encodes the specified MethodDescriptorProto message. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {google.protobuf.IMethodDescriptorProto} message MethodDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MethodDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.inputType != null && Object.hasOwnProperty.call(message, "inputType"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.inputType);
                if (message.outputType != null && Object.hasOwnProperty.call(message, "outputType"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.outputType);
                if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                    $root.google.protobuf.MethodOptions.encode(message.options, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.clientStreaming != null && Object.hasOwnProperty.call(message, "clientStreaming"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.clientStreaming);
                if (message.serverStreaming != null && Object.hasOwnProperty.call(message, "serverStreaming"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.serverStreaming);
                return writer;
            };

            /**
             * Decodes a MethodDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MethodDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.inputType = reader.string();
                        break;
                    case 3:
                        message.outputType = reader.string();
                        break;
                    case 4:
                        message.options = $root.google.protobuf.MethodOptions.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.clientStreaming = reader.bool();
                        break;
                    case 6:
                        message.serverStreaming = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return MethodDescriptorProto;
        })();

        protobuf.FileOptions = (function() {

            /**
             * Properties of a FileOptions.
             * @memberof google.protobuf
             * @interface IFileOptions
             * @property {string|null} [javaPackage] FileOptions javaPackage
             * @property {string|null} [javaOuterClassname] FileOptions javaOuterClassname
             * @property {boolean|null} [javaMultipleFiles] FileOptions javaMultipleFiles
             * @property {boolean|null} [javaGenerateEqualsAndHash] FileOptions javaGenerateEqualsAndHash
             * @property {boolean|null} [javaStringCheckUtf8] FileOptions javaStringCheckUtf8
             * @property {google.protobuf.FileOptions.OptimizeMode|null} [optimizeFor] FileOptions optimizeFor
             * @property {string|null} [goPackage] FileOptions goPackage
             * @property {boolean|null} [ccGenericServices] FileOptions ccGenericServices
             * @property {boolean|null} [javaGenericServices] FileOptions javaGenericServices
             * @property {boolean|null} [pyGenericServices] FileOptions pyGenericServices
             * @property {boolean|null} [deprecated] FileOptions deprecated
             * @property {boolean|null} [ccEnableArenas] FileOptions ccEnableArenas
             * @property {string|null} [objcClassPrefix] FileOptions objcClassPrefix
             * @property {string|null} [csharpNamespace] FileOptions csharpNamespace
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] FileOptions uninterpretedOption
             */

            /**
             * Constructs a new FileOptions.
             * @memberof google.protobuf
             * @classdesc Represents a FileOptions.
             * @implements IFileOptions
             * @constructor
             * @param {google.protobuf.IFileOptions=} [properties] Properties to set
             */
            function FileOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FileOptions javaPackage.
             * @member {string} javaPackage
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaPackage = "";

            /**
             * FileOptions javaOuterClassname.
             * @member {string} javaOuterClassname
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaOuterClassname = "";

            /**
             * FileOptions javaMultipleFiles.
             * @member {boolean} javaMultipleFiles
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaMultipleFiles = false;

            /**
             * FileOptions javaGenerateEqualsAndHash.
             * @member {boolean} javaGenerateEqualsAndHash
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaGenerateEqualsAndHash = false;

            /**
             * FileOptions javaStringCheckUtf8.
             * @member {boolean} javaStringCheckUtf8
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaStringCheckUtf8 = false;

            /**
             * FileOptions optimizeFor.
             * @member {google.protobuf.FileOptions.OptimizeMode} optimizeFor
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.optimizeFor = 1;

            /**
             * FileOptions goPackage.
             * @member {string} goPackage
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.goPackage = "";

            /**
             * FileOptions ccGenericServices.
             * @member {boolean} ccGenericServices
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.ccGenericServices = false;

            /**
             * FileOptions javaGenericServices.
             * @member {boolean} javaGenericServices
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaGenericServices = false;

            /**
             * FileOptions pyGenericServices.
             * @member {boolean} pyGenericServices
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.pyGenericServices = false;

            /**
             * FileOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.deprecated = false;

            /**
             * FileOptions ccEnableArenas.
             * @member {boolean} ccEnableArenas
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.ccEnableArenas = false;

            /**
             * FileOptions objcClassPrefix.
             * @member {string} objcClassPrefix
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.objcClassPrefix = "";

            /**
             * FileOptions csharpNamespace.
             * @member {string} csharpNamespace
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.csharpNamespace = "";

            /**
             * FileOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Encodes the specified FileOptions message. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {google.protobuf.IFileOptions} message FileOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.javaPackage != null && Object.hasOwnProperty.call(message, "javaPackage"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.javaPackage);
                if (message.javaOuterClassname != null && Object.hasOwnProperty.call(message, "javaOuterClassname"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.javaOuterClassname);
                if (message.optimizeFor != null && Object.hasOwnProperty.call(message, "optimizeFor"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.optimizeFor);
                if (message.javaMultipleFiles != null && Object.hasOwnProperty.call(message, "javaMultipleFiles"))
                    writer.uint32(/* id 10, wireType 0 =*/80).bool(message.javaMultipleFiles);
                if (message.goPackage != null && Object.hasOwnProperty.call(message, "goPackage"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.goPackage);
                if (message.ccGenericServices != null && Object.hasOwnProperty.call(message, "ccGenericServices"))
                    writer.uint32(/* id 16, wireType 0 =*/128).bool(message.ccGenericServices);
                if (message.javaGenericServices != null && Object.hasOwnProperty.call(message, "javaGenericServices"))
                    writer.uint32(/* id 17, wireType 0 =*/136).bool(message.javaGenericServices);
                if (message.pyGenericServices != null && Object.hasOwnProperty.call(message, "pyGenericServices"))
                    writer.uint32(/* id 18, wireType 0 =*/144).bool(message.pyGenericServices);
                if (message.javaGenerateEqualsAndHash != null && Object.hasOwnProperty.call(message, "javaGenerateEqualsAndHash"))
                    writer.uint32(/* id 20, wireType 0 =*/160).bool(message.javaGenerateEqualsAndHash);
                if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                    writer.uint32(/* id 23, wireType 0 =*/184).bool(message.deprecated);
                if (message.javaStringCheckUtf8 != null && Object.hasOwnProperty.call(message, "javaStringCheckUtf8"))
                    writer.uint32(/* id 27, wireType 0 =*/216).bool(message.javaStringCheckUtf8);
                if (message.ccEnableArenas != null && Object.hasOwnProperty.call(message, "ccEnableArenas"))
                    writer.uint32(/* id 31, wireType 0 =*/248).bool(message.ccEnableArenas);
                if (message.objcClassPrefix != null && Object.hasOwnProperty.call(message, "objcClassPrefix"))
                    writer.uint32(/* id 36, wireType 2 =*/290).string(message.objcClassPrefix);
                if (message.csharpNamespace != null && Object.hasOwnProperty.call(message, "csharpNamespace"))
                    writer.uint32(/* id 37, wireType 2 =*/298).string(message.csharpNamespace);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (let i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a FileOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FileOptions} FileOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.javaPackage = reader.string();
                        break;
                    case 8:
                        message.javaOuterClassname = reader.string();
                        break;
                    case 10:
                        message.javaMultipleFiles = reader.bool();
                        break;
                    case 20:
                        message.javaGenerateEqualsAndHash = reader.bool();
                        break;
                    case 27:
                        message.javaStringCheckUtf8 = reader.bool();
                        break;
                    case 9:
                        message.optimizeFor = reader.int32();
                        break;
                    case 11:
                        message.goPackage = reader.string();
                        break;
                    case 16:
                        message.ccGenericServices = reader.bool();
                        break;
                    case 17:
                        message.javaGenericServices = reader.bool();
                        break;
                    case 18:
                        message.pyGenericServices = reader.bool();
                        break;
                    case 23:
                        message.deprecated = reader.bool();
                        break;
                    case 31:
                        message.ccEnableArenas = reader.bool();
                        break;
                    case 36:
                        message.objcClassPrefix = reader.string();
                        break;
                    case 37:
                        message.csharpNamespace = reader.string();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * OptimizeMode enum.
             * @name google.protobuf.FileOptions.OptimizeMode
             * @enum {number}
             * @property {number} SPEED=1 SPEED value
             * @property {number} CODE_SIZE=2 CODE_SIZE value
             * @property {number} LITE_RUNTIME=3 LITE_RUNTIME value
             */
            FileOptions.OptimizeMode = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "SPEED"] = 1;
                values[valuesById[2] = "CODE_SIZE"] = 2;
                values[valuesById[3] = "LITE_RUNTIME"] = 3;
                return values;
            })();

            return FileOptions;
        })();

        protobuf.MessageOptions = (function() {

            /**
             * Properties of a MessageOptions.
             * @memberof google.protobuf
             * @interface IMessageOptions
             * @property {boolean|null} [messageSetWireFormat] MessageOptions messageSetWireFormat
             * @property {boolean|null} [noStandardDescriptorAccessor] MessageOptions noStandardDescriptorAccessor
             * @property {boolean|null} [deprecated] MessageOptions deprecated
             * @property {boolean|null} [mapEntry] MessageOptions mapEntry
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] MessageOptions uninterpretedOption
             */

            /**
             * Constructs a new MessageOptions.
             * @memberof google.protobuf
             * @classdesc Represents a MessageOptions.
             * @implements IMessageOptions
             * @constructor
             * @param {google.protobuf.IMessageOptions=} [properties] Properties to set
             */
            function MessageOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MessageOptions messageSetWireFormat.
             * @member {boolean} messageSetWireFormat
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.messageSetWireFormat = false;

            /**
             * MessageOptions noStandardDescriptorAccessor.
             * @member {boolean} noStandardDescriptorAccessor
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.noStandardDescriptorAccessor = false;

            /**
             * MessageOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.deprecated = false;

            /**
             * MessageOptions mapEntry.
             * @member {boolean} mapEntry
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.mapEntry = false;

            /**
             * MessageOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Encodes the specified MessageOptions message. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {google.protobuf.IMessageOptions} message MessageOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MessageOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.messageSetWireFormat != null && Object.hasOwnProperty.call(message, "messageSetWireFormat"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.messageSetWireFormat);
                if (message.noStandardDescriptorAccessor != null && Object.hasOwnProperty.call(message, "noStandardDescriptorAccessor"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.noStandardDescriptorAccessor);
                if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                if (message.mapEntry != null && Object.hasOwnProperty.call(message, "mapEntry"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.mapEntry);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (let i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a MessageOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.MessageOptions} MessageOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MessageOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MessageOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.messageSetWireFormat = reader.bool();
                        break;
                    case 2:
                        message.noStandardDescriptorAccessor = reader.bool();
                        break;
                    case 3:
                        message.deprecated = reader.bool();
                        break;
                    case 7:
                        message.mapEntry = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return MessageOptions;
        })();

        protobuf.FieldOptions = (function() {

            /**
             * Properties of a FieldOptions.
             * @memberof google.protobuf
             * @interface IFieldOptions
             * @property {google.protobuf.FieldOptions.CType|null} [ctype] FieldOptions ctype
             * @property {boolean|null} [packed] FieldOptions packed
             * @property {google.protobuf.FieldOptions.JSType|null} [jstype] FieldOptions jstype
             * @property {boolean|null} [lazy] FieldOptions lazy
             * @property {boolean|null} [deprecated] FieldOptions deprecated
             * @property {boolean|null} [weak] FieldOptions weak
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] FieldOptions uninterpretedOption
             * @property {PointerType|null} [".pointer"] FieldOptions .pointer
             * @property {number|null} [".arraySize"] FieldOptions .arraySize
             */

            /**
             * Constructs a new FieldOptions.
             * @memberof google.protobuf
             * @classdesc Represents a FieldOptions.
             * @implements IFieldOptions
             * @constructor
             * @param {google.protobuf.IFieldOptions=} [properties] Properties to set
             */
            function FieldOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FieldOptions ctype.
             * @member {google.protobuf.FieldOptions.CType} ctype
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.ctype = 0;

            /**
             * FieldOptions packed.
             * @member {boolean} packed
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.packed = false;

            /**
             * FieldOptions jstype.
             * @member {google.protobuf.FieldOptions.JSType} jstype
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.jstype = 0;

            /**
             * FieldOptions lazy.
             * @member {boolean} lazy
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.lazy = false;

            /**
             * FieldOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.deprecated = false;

            /**
             * FieldOptions weak.
             * @member {boolean} weak
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.weak = false;

            /**
             * FieldOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * FieldOptions .pointer.
             * @member {PointerType} .pointer
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype[".pointer"] = 0;

            /**
             * FieldOptions .arraySize.
             * @member {number} .arraySize
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype[".arraySize"] = 0;

            /**
             * Encodes the specified FieldOptions message. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {google.protobuf.IFieldOptions} message FieldOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.ctype != null && Object.hasOwnProperty.call(message, "ctype"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ctype);
                if (message.packed != null && Object.hasOwnProperty.call(message, "packed"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.packed);
                if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                if (message.lazy != null && Object.hasOwnProperty.call(message, "lazy"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.lazy);
                if (message.jstype != null && Object.hasOwnProperty.call(message, "jstype"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.jstype);
                if (message.weak != null && Object.hasOwnProperty.call(message, "weak"))
                    writer.uint32(/* id 10, wireType 0 =*/80).bool(message.weak);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (let i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                if (message[".pointer"] != null && Object.hasOwnProperty.call(message, ".pointer"))
                    writer.uint32(/* id 50000, wireType 0 =*/400000).int32(message[".pointer"]);
                if (message[".arraySize"] != null && Object.hasOwnProperty.call(message, ".arraySize"))
                    writer.uint32(/* id 50001, wireType 0 =*/400008).uint32(message[".arraySize"]);
                return writer;
            };

            /**
             * Decodes a FieldOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FieldOptions} FieldOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.ctype = reader.int32();
                        break;
                    case 2:
                        message.packed = reader.bool();
                        break;
                    case 6:
                        message.jstype = reader.int32();
                        break;
                    case 5:
                        message.lazy = reader.bool();
                        break;
                    case 3:
                        message.deprecated = reader.bool();
                        break;
                    case 10:
                        message.weak = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    case 50000:
                        message[".pointer"] = reader.int32();
                        break;
                    case 50001:
                        message[".arraySize"] = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * CType enum.
             * @name google.protobuf.FieldOptions.CType
             * @enum {number}
             * @property {number} STRING=0 STRING value
             * @property {number} CORD=1 CORD value
             * @property {number} STRING_PIECE=2 STRING_PIECE value
             */
            FieldOptions.CType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "STRING"] = 0;
                values[valuesById[1] = "CORD"] = 1;
                values[valuesById[2] = "STRING_PIECE"] = 2;
                return values;
            })();

            /**
             * JSType enum.
             * @name google.protobuf.FieldOptions.JSType
             * @enum {number}
             * @property {number} JS_NORMAL=0 JS_NORMAL value
             * @property {number} JS_STRING=1 JS_STRING value
             * @property {number} JS_NUMBER=2 JS_NUMBER value
             */
            FieldOptions.JSType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "JS_NORMAL"] = 0;
                values[valuesById[1] = "JS_STRING"] = 1;
                values[valuesById[2] = "JS_NUMBER"] = 2;
                return values;
            })();

            return FieldOptions;
        })();

        protobuf.OneofOptions = (function() {

            /**
             * Properties of an OneofOptions.
             * @memberof google.protobuf
             * @interface IOneofOptions
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] OneofOptions uninterpretedOption
             */

            /**
             * Constructs a new OneofOptions.
             * @memberof google.protobuf
             * @classdesc Represents an OneofOptions.
             * @implements IOneofOptions
             * @constructor
             * @param {google.protobuf.IOneofOptions=} [properties] Properties to set
             */
            function OneofOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * OneofOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.OneofOptions
             * @instance
             */
            OneofOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Encodes the specified OneofOptions message. Does not implicitly {@link google.protobuf.OneofOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {google.protobuf.IOneofOptions} message OneofOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OneofOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (let i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes an OneofOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.OneofOptions} OneofOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OneofOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.OneofOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return OneofOptions;
        })();

        protobuf.EnumOptions = (function() {

            /**
             * Properties of an EnumOptions.
             * @memberof google.protobuf
             * @interface IEnumOptions
             * @property {boolean|null} [allowAlias] EnumOptions allowAlias
             * @property {boolean|null} [deprecated] EnumOptions deprecated
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] EnumOptions uninterpretedOption
             */

            /**
             * Constructs a new EnumOptions.
             * @memberof google.protobuf
             * @classdesc Represents an EnumOptions.
             * @implements IEnumOptions
             * @constructor
             * @param {google.protobuf.IEnumOptions=} [properties] Properties to set
             */
            function EnumOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumOptions allowAlias.
             * @member {boolean} allowAlias
             * @memberof google.protobuf.EnumOptions
             * @instance
             */
            EnumOptions.prototype.allowAlias = false;

            /**
             * EnumOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.EnumOptions
             * @instance
             */
            EnumOptions.prototype.deprecated = false;

            /**
             * EnumOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.EnumOptions
             * @instance
             */
            EnumOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Encodes the specified EnumOptions message. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {google.protobuf.IEnumOptions} message EnumOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.allowAlias != null && Object.hasOwnProperty.call(message, "allowAlias"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.allowAlias);
                if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (let i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes an EnumOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumOptions} EnumOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2:
                        message.allowAlias = reader.bool();
                        break;
                    case 3:
                        message.deprecated = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return EnumOptions;
        })();

        protobuf.EnumValueOptions = (function() {

            /**
             * Properties of an EnumValueOptions.
             * @memberof google.protobuf
             * @interface IEnumValueOptions
             * @property {boolean|null} [deprecated] EnumValueOptions deprecated
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] EnumValueOptions uninterpretedOption
             */

            /**
             * Constructs a new EnumValueOptions.
             * @memberof google.protobuf
             * @classdesc Represents an EnumValueOptions.
             * @implements IEnumValueOptions
             * @constructor
             * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set
             */
            function EnumValueOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumValueOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.EnumValueOptions
             * @instance
             */
            EnumValueOptions.prototype.deprecated = false;

            /**
             * EnumValueOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.EnumValueOptions
             * @instance
             */
            EnumValueOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Encodes the specified EnumValueOptions message. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {google.protobuf.IEnumValueOptions} message EnumValueOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumValueOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.deprecated);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (let i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes an EnumValueOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumValueOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.deprecated = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return EnumValueOptions;
        })();

        protobuf.ServiceOptions = (function() {

            /**
             * Properties of a ServiceOptions.
             * @memberof google.protobuf
             * @interface IServiceOptions
             * @property {boolean|null} [deprecated] ServiceOptions deprecated
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] ServiceOptions uninterpretedOption
             */

            /**
             * Constructs a new ServiceOptions.
             * @memberof google.protobuf
             * @classdesc Represents a ServiceOptions.
             * @implements IServiceOptions
             * @constructor
             * @param {google.protobuf.IServiceOptions=} [properties] Properties to set
             */
            function ServiceOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ServiceOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.ServiceOptions
             * @instance
             */
            ServiceOptions.prototype.deprecated = false;

            /**
             * ServiceOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.ServiceOptions
             * @instance
             */
            ServiceOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Encodes the specified ServiceOptions message. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {google.protobuf.IServiceOptions} message ServiceOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServiceOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                    writer.uint32(/* id 33, wireType 0 =*/264).bool(message.deprecated);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (let i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a ServiceOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.ServiceOptions} ServiceOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServiceOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 33:
                        message.deprecated = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return ServiceOptions;
        })();

        protobuf.MethodOptions = (function() {

            /**
             * Properties of a MethodOptions.
             * @memberof google.protobuf
             * @interface IMethodOptions
             * @property {boolean|null} [deprecated] MethodOptions deprecated
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] MethodOptions uninterpretedOption
             */

            /**
             * Constructs a new MethodOptions.
             * @memberof google.protobuf
             * @classdesc Represents a MethodOptions.
             * @implements IMethodOptions
             * @constructor
             * @param {google.protobuf.IMethodOptions=} [properties] Properties to set
             */
            function MethodOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MethodOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.MethodOptions
             * @instance
             */
            MethodOptions.prototype.deprecated = false;

            /**
             * MethodOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.MethodOptions
             * @instance
             */
            MethodOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Encodes the specified MethodOptions message. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {google.protobuf.IMethodOptions} message MethodOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MethodOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                    writer.uint32(/* id 33, wireType 0 =*/264).bool(message.deprecated);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (let i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a MethodOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.MethodOptions} MethodOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MethodOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 33:
                        message.deprecated = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return MethodOptions;
        })();

        protobuf.UninterpretedOption = (function() {

            /**
             * Properties of an UninterpretedOption.
             * @memberof google.protobuf
             * @interface IUninterpretedOption
             * @property {Array.<google.protobuf.UninterpretedOption.INamePart>|null} [name] UninterpretedOption name
             * @property {string|null} [identifierValue] UninterpretedOption identifierValue
             * @property {number|Long|null} [positiveIntValue] UninterpretedOption positiveIntValue
             * @property {number|Long|null} [negativeIntValue] UninterpretedOption negativeIntValue
             * @property {number|null} [doubleValue] UninterpretedOption doubleValue
             * @property {Uint8Array|null} [stringValue] UninterpretedOption stringValue
             * @property {string|null} [aggregateValue] UninterpretedOption aggregateValue
             */

            /**
             * Constructs a new UninterpretedOption.
             * @memberof google.protobuf
             * @classdesc Represents an UninterpretedOption.
             * @implements IUninterpretedOption
             * @constructor
             * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set
             */
            function UninterpretedOption(properties) {
                this.name = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UninterpretedOption name.
             * @member {Array.<google.protobuf.UninterpretedOption.INamePart>} name
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.name = $util.emptyArray;

            /**
             * UninterpretedOption identifierValue.
             * @member {string} identifierValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.identifierValue = "";

            /**
             * UninterpretedOption positiveIntValue.
             * @member {number|Long} positiveIntValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.positiveIntValue = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * UninterpretedOption negativeIntValue.
             * @member {number|Long} negativeIntValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.negativeIntValue = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * UninterpretedOption doubleValue.
             * @member {number} doubleValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.doubleValue = 0;

            /**
             * UninterpretedOption stringValue.
             * @member {Uint8Array} stringValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.stringValue = $util.newBuffer([]);

            /**
             * UninterpretedOption aggregateValue.
             * @member {string} aggregateValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.aggregateValue = "";

            /**
             * Encodes the specified UninterpretedOption message. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {google.protobuf.IUninterpretedOption} message UninterpretedOption message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UninterpretedOption.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.name.length)
                    for (let i = 0; i < message.name.length; ++i)
                        $root.google.protobuf.UninterpretedOption.NamePart.encode(message.name[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.identifierValue != null && Object.hasOwnProperty.call(message, "identifierValue"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.identifierValue);
                if (message.positiveIntValue != null && Object.hasOwnProperty.call(message, "positiveIntValue"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.positiveIntValue);
                if (message.negativeIntValue != null && Object.hasOwnProperty.call(message, "negativeIntValue"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.negativeIntValue);
                if (message.doubleValue != null && Object.hasOwnProperty.call(message, "doubleValue"))
                    writer.uint32(/* id 6, wireType 1 =*/49).double(message.doubleValue);
                if (message.stringValue != null && Object.hasOwnProperty.call(message, "stringValue"))
                    writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.stringValue);
                if (message.aggregateValue != null && Object.hasOwnProperty.call(message, "aggregateValue"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.aggregateValue);
                return writer;
            };

            /**
             * Decodes an UninterpretedOption message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UninterpretedOption.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2:
                        if (!(message.name && message.name.length))
                            message.name = [];
                        message.name.push($root.google.protobuf.UninterpretedOption.NamePart.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.identifierValue = reader.string();
                        break;
                    case 4:
                        message.positiveIntValue = reader.uint64();
                        break;
                    case 5:
                        message.negativeIntValue = reader.int64();
                        break;
                    case 6:
                        message.doubleValue = reader.double();
                        break;
                    case 7:
                        message.stringValue = reader.bytes();
                        break;
                    case 8:
                        message.aggregateValue = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            UninterpretedOption.NamePart = (function() {

                /**
                 * Properties of a NamePart.
                 * @memberof google.protobuf.UninterpretedOption
                 * @interface INamePart
                 * @property {string} namePart NamePart namePart
                 * @property {boolean} isExtension NamePart isExtension
                 */

                /**
                 * Constructs a new NamePart.
                 * @memberof google.protobuf.UninterpretedOption
                 * @classdesc Represents a NamePart.
                 * @implements INamePart
                 * @constructor
                 * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set
                 */
                function NamePart(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * NamePart namePart.
                 * @member {string} namePart
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @instance
                 */
                NamePart.prototype.namePart = "";

                /**
                 * NamePart isExtension.
                 * @member {boolean} isExtension
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @instance
                 */
                NamePart.prototype.isExtension = false;

                /**
                 * Encodes the specified NamePart message. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {google.protobuf.UninterpretedOption.INamePart} message NamePart message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NamePart.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.namePart);
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isExtension);
                    return writer;
                };

                /**
                 * Decodes a NamePart message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NamePart.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption.NamePart();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.namePart = reader.string();
                            break;
                        case 2:
                            message.isExtension = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("namePart"))
                        throw $util.ProtocolError("missing required 'namePart'", { instance: message });
                    if (!message.hasOwnProperty("isExtension"))
                        throw $util.ProtocolError("missing required 'isExtension'", { instance: message });
                    return message;
                };

                return NamePart;
            })();

            return UninterpretedOption;
        })();

        protobuf.SourceCodeInfo = (function() {

            /**
             * Properties of a SourceCodeInfo.
             * @memberof google.protobuf
             * @interface ISourceCodeInfo
             * @property {Array.<google.protobuf.SourceCodeInfo.ILocation>|null} [location] SourceCodeInfo location
             */

            /**
             * Constructs a new SourceCodeInfo.
             * @memberof google.protobuf
             * @classdesc Represents a SourceCodeInfo.
             * @implements ISourceCodeInfo
             * @constructor
             * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set
             */
            function SourceCodeInfo(properties) {
                this.location = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SourceCodeInfo location.
             * @member {Array.<google.protobuf.SourceCodeInfo.ILocation>} location
             * @memberof google.protobuf.SourceCodeInfo
             * @instance
             */
            SourceCodeInfo.prototype.location = $util.emptyArray;

            /**
             * Encodes the specified SourceCodeInfo message. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {google.protobuf.ISourceCodeInfo} message SourceCodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SourceCodeInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.location != null && message.location.length)
                    for (let i = 0; i < message.location.length; ++i)
                        $root.google.protobuf.SourceCodeInfo.Location.encode(message.location[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a SourceCodeInfo message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SourceCodeInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.location && message.location.length))
                            message.location = [];
                        message.location.push($root.google.protobuf.SourceCodeInfo.Location.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            SourceCodeInfo.Location = (function() {

                /**
                 * Properties of a Location.
                 * @memberof google.protobuf.SourceCodeInfo
                 * @interface ILocation
                 * @property {Array.<number>|null} [path] Location path
                 * @property {Array.<number>|null} [span] Location span
                 * @property {string|null} [leadingComments] Location leadingComments
                 * @property {string|null} [trailingComments] Location trailingComments
                 * @property {Array.<string>|null} [leadingDetachedComments] Location leadingDetachedComments
                 */

                /**
                 * Constructs a new Location.
                 * @memberof google.protobuf.SourceCodeInfo
                 * @classdesc Represents a Location.
                 * @implements ILocation
                 * @constructor
                 * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set
                 */
                function Location(properties) {
                    this.path = [];
                    this.span = [];
                    this.leadingDetachedComments = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Location path.
                 * @member {Array.<number>} path
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.path = $util.emptyArray;

                /**
                 * Location span.
                 * @member {Array.<number>} span
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.span = $util.emptyArray;

                /**
                 * Location leadingComments.
                 * @member {string} leadingComments
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.leadingComments = "";

                /**
                 * Location trailingComments.
                 * @member {string} trailingComments
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.trailingComments = "";

                /**
                 * Location leadingDetachedComments.
                 * @member {Array.<string>} leadingDetachedComments
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.leadingDetachedComments = $util.emptyArray;

                /**
                 * Encodes the specified Location message. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {google.protobuf.SourceCodeInfo.ILocation} message Location message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Location.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.path != null && message.path.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (let i = 0; i < message.path.length; ++i)
                            writer.int32(message.path[i]);
                        writer.ldelim();
                    }
                    if (message.span != null && message.span.length) {
                        writer.uint32(/* id 2, wireType 2 =*/18).fork();
                        for (let i = 0; i < message.span.length; ++i)
                            writer.int32(message.span[i]);
                        writer.ldelim();
                    }
                    if (message.leadingComments != null && Object.hasOwnProperty.call(message, "leadingComments"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.leadingComments);
                    if (message.trailingComments != null && Object.hasOwnProperty.call(message, "trailingComments"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.trailingComments);
                    if (message.leadingDetachedComments != null && message.leadingDetachedComments.length)
                        for (let i = 0; i < message.leadingDetachedComments.length; ++i)
                            writer.uint32(/* id 6, wireType 2 =*/50).string(message.leadingDetachedComments[i]);
                    return writer;
                };

                /**
                 * Decodes a Location message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Location.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo.Location();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.path && message.path.length))
                                message.path = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.path.push(reader.int32());
                            } else
                                message.path.push(reader.int32());
                            break;
                        case 2:
                            if (!(message.span && message.span.length))
                                message.span = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.span.push(reader.int32());
                            } else
                                message.span.push(reader.int32());
                            break;
                        case 3:
                            message.leadingComments = reader.string();
                            break;
                        case 4:
                            message.trailingComments = reader.string();
                            break;
                        case 6:
                            if (!(message.leadingDetachedComments && message.leadingDetachedComments.length))
                                message.leadingDetachedComments = [];
                            message.leadingDetachedComments.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return Location;
            })();

            return SourceCodeInfo;
        })();

        protobuf.GeneratedCodeInfo = (function() {

            /**
             * Properties of a GeneratedCodeInfo.
             * @memberof google.protobuf
             * @interface IGeneratedCodeInfo
             * @property {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>|null} [annotation] GeneratedCodeInfo annotation
             */

            /**
             * Constructs a new GeneratedCodeInfo.
             * @memberof google.protobuf
             * @classdesc Represents a GeneratedCodeInfo.
             * @implements IGeneratedCodeInfo
             * @constructor
             * @param {google.protobuf.IGeneratedCodeInfo=} [properties] Properties to set
             */
            function GeneratedCodeInfo(properties) {
                this.annotation = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GeneratedCodeInfo annotation.
             * @member {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>} annotation
             * @memberof google.protobuf.GeneratedCodeInfo
             * @instance
             */
            GeneratedCodeInfo.prototype.annotation = $util.emptyArray;

            /**
             * Encodes the specified GeneratedCodeInfo message. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {google.protobuf.IGeneratedCodeInfo} message GeneratedCodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GeneratedCodeInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.annotation != null && message.annotation.length)
                    for (let i = 0; i < message.annotation.length; ++i)
                        $root.google.protobuf.GeneratedCodeInfo.Annotation.encode(message.annotation[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Decodes a GeneratedCodeInfo message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GeneratedCodeInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.GeneratedCodeInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.annotation && message.annotation.length))
                            message.annotation = [];
                        message.annotation.push($root.google.protobuf.GeneratedCodeInfo.Annotation.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            GeneratedCodeInfo.Annotation = (function() {

                /**
                 * Properties of an Annotation.
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @interface IAnnotation
                 * @property {Array.<number>|null} [path] Annotation path
                 * @property {string|null} [sourceFile] Annotation sourceFile
                 * @property {number|null} [begin] Annotation begin
                 * @property {number|null} [end] Annotation end
                 */

                /**
                 * Constructs a new Annotation.
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @classdesc Represents an Annotation.
                 * @implements IAnnotation
                 * @constructor
                 * @param {google.protobuf.GeneratedCodeInfo.IAnnotation=} [properties] Properties to set
                 */
                function Annotation(properties) {
                    this.path = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Annotation path.
                 * @member {Array.<number>} path
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.path = $util.emptyArray;

                /**
                 * Annotation sourceFile.
                 * @member {string} sourceFile
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.sourceFile = "";

                /**
                 * Annotation begin.
                 * @member {number} begin
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.begin = 0;

                /**
                 * Annotation end.
                 * @member {number} end
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.end = 0;

                /**
                 * Encodes the specified Annotation message. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.Annotation.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {google.protobuf.GeneratedCodeInfo.IAnnotation} message Annotation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Annotation.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.path != null && message.path.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (let i = 0; i < message.path.length; ++i)
                            writer.int32(message.path[i]);
                        writer.ldelim();
                    }
                    if (message.sourceFile != null && Object.hasOwnProperty.call(message, "sourceFile"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.sourceFile);
                    if (message.begin != null && Object.hasOwnProperty.call(message, "begin"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.begin);
                    if (message.end != null && Object.hasOwnProperty.call(message, "end"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.end);
                    return writer;
                };

                /**
                 * Decodes an Annotation message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Annotation.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.GeneratedCodeInfo.Annotation();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.path && message.path.length))
                                message.path = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.path.push(reader.int32());
                            } else
                                message.path.push(reader.int32());
                            break;
                        case 2:
                            message.sourceFile = reader.string();
                            break;
                        case 3:
                            message.begin = reader.int32();
                            break;
                        case 4:
                            message.end = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                return Annotation;
            })();

            return GeneratedCodeInfo;
        })();

        protobuf.Duration = (function() {

            /**
             * Properties of a Duration.
             * @memberof google.protobuf
             * @interface IDuration
             * @property {number|Long|null} [seconds] Duration seconds
             * @property {number|null} [nanos] Duration nanos
             */

            /**
             * Constructs a new Duration.
             * @memberof google.protobuf
             * @classdesc Represents a Duration.
             * @implements IDuration
             * @constructor
             * @param {google.protobuf.IDuration=} [properties] Properties to set
             */
            function Duration(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Duration seconds.
             * @member {number|Long} seconds
             * @memberof google.protobuf.Duration
             * @instance
             */
            Duration.prototype.seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Duration nanos.
             * @member {number} nanos
             * @memberof google.protobuf.Duration
             * @instance
             */
            Duration.prototype.nanos = 0;

            /**
             * Encodes the specified Duration message. Does not implicitly {@link google.protobuf.Duration.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Duration
             * @static
             * @param {google.protobuf.IDuration} message Duration message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Duration.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.seconds != null && Object.hasOwnProperty.call(message, "seconds"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.seconds);
                if (message.nanos != null && Object.hasOwnProperty.call(message, "nanos"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.nanos);
                return writer;
            };

            /**
             * Decodes a Duration message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Duration
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Duration} Duration
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Duration.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Duration();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.seconds = reader.int64();
                        break;
                    case 2:
                        message.nanos = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return Duration;
        })();

        return protobuf;
    })();

    return google;
})();

/**
 * PointerType enum.
 * @exports PointerType
 * @enum {number}
 * @property {number} NONE=0 NONE value
 * @property {number} RAW=1 RAW value
 * @property {number} SHARED=2 SHARED value
 * @property {number} UNIQUE=3 UNIQUE value
 */
export const PointerType = $root.PointerType = (() => {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "NONE"] = 0;
    values[valuesById[1] = "RAW"] = 1;
    values[valuesById[2] = "SHARED"] = 2;
    values[valuesById[3] = "UNIQUE"] = 3;
    return values;
})();

export { $root as default };
