<!-- HTML header for doxygen 1.9.3-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=11" />
    <meta name="generator" content="Doxygen 1.9.1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>NUbots: module::extension::Director Class Reference</title>
    <link href="tabs.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <!--START doxygen_awesome-->
    <script type="text/javascript" src="styles/doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript">
      DoxygenAwesomeDarkModeToggle.init();
    </script>
    <!--END doxygen_awesome-->
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
 <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  </head>
  <body>
    <a href="https://github.com/NUbots/NUbots" class="github-corner" title="View source on GitHub" target="_blank">
      <svg
        viewBox="0 0 250 250"
        width="40"
        height="40"
        style="position: absolute; top: 0; border: 0; right: 0; z-index: 99"
        aria-hidden="true"
      >
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path
          d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
          fill="currentColor"
          style="transform-origin: 130px 106px"
          class="octo-arm"
        ></path>
        <path
          d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
          fill="currentColor"
          class="octo-body"
        ></path></svg></a
    ><style>
      .github-corner:hover .octo-arm {
        animation: octocat-wave 560ms ease-in-out;
      }
      @keyframes octocat-wave {
        0%,
        100% {
          transform: rotate(0);
        }
        20%,
        60% {
          transform: rotate(-25deg);
        }
        40%,
        80% {
          transform: rotate(10deg);
        }
      }
      @media (max-width: 500px) {
        .github-corner:hover .octo-arm {
          animation: none;
        }
        .github-corner .octo-arm {
          animation: octocat-wave 560ms ease-in-out;
        }
      }
    </style>
      <div id="top">
        <!-- do not remove this div, it is closed by doxygen! -->
        <div id="titlearea">
          <table cellspacing="0" cellpadding="0">
            <tbody>
              <tr id="projectrow">
                <td id="projectlogo"><img alt="Logo" src="banner.png" /></td>
                <td id="projectalign">
                  <div id="projectname">
                    NUbots
                  </div>
                  <div id="projectbrief">NUbots Main Codebase</div>
                </td>
              </tr>
              <!--BEGIN FULL_SIDEBAR-->
              <tr>
                <td colspan="2">        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
              </tr>
              <!--END FULL_SIDEBAR-->
            </tbody>
          </table>
        </div>
        <!-- end header part -->
      </div>
    </div>
  </body>
</html>
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classmodule_1_1extension_1_1Director.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classmodule_1_1extension_1_1Director-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">module::extension::Director Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for module::extension::Director:</div>
<div class="dyncontent">
<div class="center"><img src="classmodule_1_1extension_1_1Director__inherit__graph.png" border="0" usemap="#amodule_1_1extension_1_1Director_inherit__map" alt="Inheritance graph"/></div>
<map name="amodule_1_1extension_1_1Director_inherit__map" id="amodule_1_1extension_1_1Director_inherit__map">
<area shape="rect" title=" " alt="" coords="5,80,156,121"/>
<area shape="rect" title=" " alt="" coords="13,5,148,32"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for module::extension::Director:</div>
<div class="dyncontent">
<div class="center"><img src="classmodule_1_1extension_1_1Director__coll__graph.png" border="0" usemap="#amodule_1_1extension_1_1Director_coll__map" alt="Collaboration graph"/></div>
<map name="amodule_1_1extension_1_1Director_coll__map" id="amodule_1_1extension_1_1Director_coll__map">
<area shape="rect" title=" " alt="" coords="5,80,156,121"/>
<area shape="rect" title=" " alt="" coords="13,5,148,32"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmodule_1_1extension_1_1Director_1_1OkSolution.html">OkSolution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a solution that we can run now, i.e.  <a href="structmodule_1_1extension_1_1Director_1_1OkSolution.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmodule_1_1extension_1_1Director_1_1RunResult.html">RunResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The result of running a set of tasks.  <a href="structmodule_1_1extension_1_1Director_1_1RunResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmodule_1_1extension_1_1Director_1_1Solution.html">Solution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object which holds the possible solutions to running a task.  <a href="structmodule_1_1extension_1_1Director_1_1Solution.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmodule_1_1extension_1_1Director_1_1TaskPack.html">TaskPack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A task pack is the result of a set of tasks emitted by a provider that should be run together.  <a href="structmodule_1_1extension_1_1Director_1_1TaskPack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmodule_1_1extension_1_1Director_1_1WaitFinished.html">WaitFinished</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A request to run the specified provider, after a <code>Wait</code> task's time has elapsed.  <a href="structmodule_1_1extension_1_1Director_1_1WaitFinished.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a7021252f80d525cec056bec1adfa81eb"><td class="memItemLeft" align="right" valign="top"><a id="a7021252f80d525cec056bec1adfa81eb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodule_1_1extension_1_1Director.html#a7021252f80d525cec056bec1adfa81eb">TaskList</a> = std::vector&lt; std::shared_ptr&lt; <a class="el" href="structmodule_1_1extension_1_1component_1_1DirectorTask.html">component::DirectorTask</a> &gt; &gt;</td></tr>
<tr class="memdesc:a7021252f80d525cec056bec1adfa81eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A task list holds a list of tasks. <br /></td></tr>
<tr class="separator:a7021252f80d525cec056bec1adfa81eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab5586dc9feb7878dd9a6a6234088d8a3"><td class="memItemLeft" align="right" valign="top"><a id="ab5586dc9feb7878dd9a6a6234088d8a3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodule_1_1extension_1_1Director.html#ab5586dc9feb7878dd9a6a6234088d8a3">Director</a> (std::unique_ptr&lt; NUClear::Environment &gt; environment)</td></tr>
<tr class="memdesc:ab5586dc9feb7878dd9a6a6234088d8a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by the powerplant to build and setup the <a class="el" href="classmodule_1_1extension_1_1Director.html">Director</a> reactor. <br /></td></tr>
<tr class="separator:ab5586dc9feb7878dd9a6a6234088d8a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a774a9943509e7bd672ac9e54c8aa7026"><td class="memItemLeft" align="right" valign="top"><a id="a774a9943509e7bd672ac9e54c8aa7026"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>concurrency</b> = 1</td></tr>
<tr class="separator:a774a9943509e7bd672ac9e54c8aa7026"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a058f702f618f27cceb1ade5526ad2c77"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodule_1_1extension_1_1Director.html#a058f702f618f27cceb1ade5526ad2c77">RunLevel</a> { <a class="el" href="classmodule_1_1extension_1_1Director.html#a058f702f618f27cceb1ade5526ad2c77afae7fc26dfef15f5c935685710e572d9">OK</a>
, <a class="el" href="classmodule_1_1extension_1_1Director.html#a058f702f618f27cceb1ade5526ad2c77a84f6f1116ae35c9f652a614104bb91eb">PUSH</a>
, <a class="el" href="classmodule_1_1extension_1_1Director.html#a058f702f618f27cceb1ade5526ad2c77a0ff28619a17818aeff9f773b91b554ca">BLOCKED</a>
 }</td></tr>
<tr class="memdesc:a058f702f618f27cceb1ade5526ad2c77"><td class="mdescLeft">&#160;</td><td class="mdescRight">The level of solution that we can run at.  <a href="classmodule_1_1extension_1_1Director.html#a058f702f618f27cceb1ade5526ad2c77">More...</a><br /></td></tr>
<tr class="separator:a058f702f618f27cceb1ade5526ad2c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ae38a0f87a58faec7521d61eb4faaae7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodule_1_1extension_1_1Director.html#ae38a0f87a58faec7521d61eb4faaae7a">add_causing</a> (const ::<a class="el" href="structextension_1_1behaviour_1_1commands_1_1CausingExpression.html">extension::behaviour::commands::CausingExpression</a> &amp;causing)</td></tr>
<tr class="memdesc:ae38a0f87a58faec7521d61eb4faaae7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a causing condition to an existing Provider.  <a href="classmodule_1_1extension_1_1Director.html#ae38a0f87a58faec7521d61eb4faaae7a">More...</a><br /></td></tr>
<tr class="separator:ae38a0f87a58faec7521d61eb4faaae7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa959f154ca485d8bb435b898ecb3223"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodule_1_1extension_1_1Director.html#aaa959f154ca485d8bb435b898ecb3223">add_needs</a> (const ::<a class="el" href="structextension_1_1behaviour_1_1commands_1_1NeedsExpression.html">extension::behaviour::commands::NeedsExpression</a> &amp;needs)</td></tr>
<tr class="memdesc:aaa959f154ca485d8bb435b898ecb3223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a needs to an existing Provider.  <a href="classmodule_1_1extension_1_1Director.html#aaa959f154ca485d8bb435b898ecb3223">More...</a><br /></td></tr>
<tr class="separator:aaa959f154ca485d8bb435b898ecb3223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a194487bb54ff0df9fb6dfd687b8f80f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodule_1_1extension_1_1Director.html#a194487bb54ff0df9fb6dfd687b8f80f6">add_provider</a> (const ::<a class="el" href="structextension_1_1behaviour_1_1commands_1_1ProvideReaction.html">extension::behaviour::commands::ProvideReaction</a> &amp;provide)</td></tr>
<tr class="memdesc:a194487bb54ff0df9fb6dfd687b8f80f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a Provider for a type.  <a href="classmodule_1_1extension_1_1Director.html#a194487bb54ff0df9fb6dfd687b8f80f6">More...</a><br /></td></tr>
<tr class="separator:a194487bb54ff0df9fb6dfd687b8f80f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f5fe71a8de8e8282b0a2774e6249e43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodule_1_1extension_1_1Director.html#a0f5fe71a8de8e8282b0a2774e6249e43">add_when</a> (const ::<a class="el" href="structextension_1_1behaviour_1_1commands_1_1WhenExpression.html">extension::behaviour::commands::WhenExpression</a> &amp;when)</td></tr>
<tr class="memdesc:a0f5fe71a8de8e8282b0a2774e6249e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a when condition to an existing Provider.  <a href="classmodule_1_1extension_1_1Director.html#a0f5fe71a8de8e8282b0a2774e6249e43">More...</a><br /></td></tr>
<tr class="separator:a0f5fe71a8de8e8282b0a2774e6249e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e12b0846a7c148a6dea84299670b45c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodule_1_1extension_1_1Director.html#a6e12b0846a7c148a6dea84299670b45c">challenge_priority</a> (const std::shared_ptr&lt; <a class="el" href="structmodule_1_1extension_1_1component_1_1DirectorTask.html">component::DirectorTask</a> &gt; &amp;incumbent, const std::shared_ptr&lt; <a class="el" href="structmodule_1_1extension_1_1component_1_1DirectorTask.html">component::DirectorTask</a> &gt; &amp;challenger)</td></tr>
<tr class="memdesc:a6e12b0846a7c148a6dea84299670b45c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the challenge priorities of two director tasks and returns true if the challenger has priority over the incumbent using challenge priority.  <a href="classmodule_1_1extension_1_1Director.html#a6e12b0846a7c148a6dea84299670b45c">More...</a><br /></td></tr>
<tr class="separator:a6e12b0846a7c148a6dea84299670b45c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53c31913830e62fdc1b7c49c9a259191"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmodule_1_1extension_1_1Director_1_1OkSolution.html">OkSolution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodule_1_1extension_1_1Director.html#a53c31913830e62fdc1b7c49c9a259191">find_ok_solution</a> (const <a class="el" href="structmodule_1_1extension_1_1Director_1_1Solution.html">Solution</a> &amp;requirement, const std::set&lt; std::type_index &gt; &amp;used_types)</td></tr>
<tr class="memdesc:a53c31913830e62fdc1b7c49c9a259191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first available option for a solution that we can run now for this solution.  <a href="classmodule_1_1extension_1_1Director.html#a53c31913830e62fdc1b7c49c9a259191">More...</a><br /></td></tr>
<tr class="separator:a53c31913830e62fdc1b7c49c9a259191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90923156eb8865e70b76295c7f2925ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmodule_1_1extension_1_1Director_1_1OkSolution.html">OkSolution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodule_1_1extension_1_1Director.html#a90923156eb8865e70b76295c7f2925ac">find_ok_solution</a> (const <a class="el" href="structmodule_1_1extension_1_1Director_1_1Solution_1_1Option.html">Solution::Option</a> &amp;option, std::set&lt; std::type_index &gt; used_types)</td></tr>
<tr class="memdesc:a90923156eb8865e70b76295c7f2925ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Joins all of the requirements of an option into a single <a class="el" href="structmodule_1_1extension_1_1Director_1_1OkSolution.html" title="Represents a solution that we can run now, i.e.">OkSolution</a> instance.  <a href="classmodule_1_1extension_1_1Director.html#a90923156eb8865e70b76295c7f2925ac">More...</a><br /></td></tr>
<tr class="separator:a90923156eb8865e70b76295c7f2925ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a064eb8cb122b43693170af234a60756b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structmodule_1_1extension_1_1Director_1_1OkSolution.html">OkSolution</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodule_1_1extension_1_1Director.html#a064eb8cb122b43693170af234a60756b">find_ok_solutions</a> (const std::vector&lt; <a class="el" href="structmodule_1_1extension_1_1Director_1_1Solution.html">Solution</a> &gt; &amp;solutions, const std::set&lt; std::type_index &gt; &amp;used_types)</td></tr>
<tr class="memdesc:a064eb8cb122b43693170af234a60756b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves each of a series of Solutions and returns a list of OkSolutions that represents the first solution that can execute, or a blocked solution if none of the solutions can execute.  <a href="classmodule_1_1extension_1_1Director.html#a064eb8cb122b43693170af234a60756b">More...</a><br /></td></tr>
<tr class="separator:a064eb8cb122b43693170af234a60756b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a553b675b4947fe028b198285a393d778"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="structmodule_1_1extension_1_1component_1_1Provider.html">component::Provider</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodule_1_1extension_1_1Director.html#a553b675b4947fe028b198285a393d778">get_root_provider</a> (const std::type_index &amp;root_type)</td></tr>
<tr class="memdesc:a553b675b4947fe028b198285a393d778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds or creates a root provider for a task and returns it.  <a href="classmodule_1_1extension_1_1Director.html#a553b675b4947fe028b198285a393d778">More...</a><br /></td></tr>
<tr class="separator:a553b675b4947fe028b198285a393d778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2525565f36ac81678c9987d70bfa35e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodule_1_1extension_1_1Director.html#aa2525565f36ac81678c9987d70bfa35e">reevaluate_children</a> (<a class="el" href="structmodule_1_1extension_1_1component_1_1ProviderGroup.html">component::ProviderGroup</a> &amp;group)</td></tr>
<tr class="memdesc:aa2525565f36ac81678c9987d70bfa35e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs a reevaluation on not only the passed group, but any groups that it is using.  <a href="classmodule_1_1extension_1_1Director.html#aa2525565f36ac81678c9987d70bfa35e">More...</a><br /></td></tr>
<tr class="separator:aa2525565f36ac81678c9987d70bfa35e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98348af06fa8b1126bc28e2d21695668"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodule_1_1extension_1_1Director.html#a98348af06fa8b1126bc28e2d21695668">reevaluate_group</a> (<a class="el" href="structmodule_1_1extension_1_1component_1_1ProviderGroup.html">component::ProviderGroup</a> &amp;group)</td></tr>
<tr class="memdesc:a98348af06fa8b1126bc28e2d21695668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reevaluates all of the tasks that are queued to execute on a provider group.  <a href="classmodule_1_1extension_1_1Director.html#a98348af06fa8b1126bc28e2d21695668">More...</a><br /></td></tr>
<tr class="separator:a98348af06fa8b1126bc28e2d21695668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5cb1189cc1ccd5680fdc36dcbf47178"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodule_1_1extension_1_1Director.html#ab5cb1189cc1ccd5680fdc36dcbf47178">remove_provider</a> (const NUClear::id_t &amp;id)</td></tr>
<tr class="memdesc:ab5cb1189cc1ccd5680fdc36dcbf47178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a Provider for a type.  <a href="classmodule_1_1extension_1_1Director.html#ab5cb1189cc1ccd5680fdc36dcbf47178">More...</a><br /></td></tr>
<tr class="separator:ab5cb1189cc1ccd5680fdc36dcbf47178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a310d77d2ee390e96e2e35db3d3a45a73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodule_1_1extension_1_1Director.html#a310d77d2ee390e96e2e35db3d3a45a73">remove_task</a> (const std::shared_ptr&lt; <a class="el" href="structmodule_1_1extension_1_1component_1_1DirectorTask.html">component::DirectorTask</a> &gt; &amp;task)</td></tr>
<tr class="memdesc:a310d77d2ee390e96e2e35db3d3a45a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the provided task from the <a class="el" href="classmodule_1_1extension_1_1Director.html">Director</a>.  <a href="classmodule_1_1extension_1_1Director.html#a310d77d2ee390e96e2e35db3d3a45a73">More...</a><br /></td></tr>
<tr class="separator:a310d77d2ee390e96e2e35db3d3a45a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa3e4a164097d1ca11e840072c261f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodule_1_1extension_1_1Director.html#afaa3e4a164097d1ca11e840072c261f9">run_task_on_provider</a> (const std::shared_ptr&lt; <a class="el" href="structmodule_1_1extension_1_1component_1_1DirectorTask.html">component::DirectorTask</a> &gt; &amp;task, const std::shared_ptr&lt; <a class="el" href="structmodule_1_1extension_1_1component_1_1Provider.html">component::Provider</a> &gt; &amp;provider, const ::extension::behaviour::RunReason &amp;run_reason)</td></tr>
<tr class="memdesc:afaa3e4a164097d1ca11e840072c261f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs the passed task on the passed provider.  <a href="classmodule_1_1extension_1_1Director.html#afaa3e4a164097d1ca11e840072c261f9">More...</a><br /></td></tr>
<tr class="separator:afaa3e4a164097d1ca11e840072c261f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a867e019bba1e28cf210a89d786452bf5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodule_1_1extension_1_1Director.html#a867e019bba1e28cf210a89d786452bf5">run_task_pack</a> (const <a class="el" href="structmodule_1_1extension_1_1Director_1_1TaskPack.html">TaskPack</a> &amp;pack)</td></tr>
<tr class="memdesc:a867e019bba1e28cf210a89d786452bf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks at all the tasks that are in the pack and determines if they should run, and if so runs them.  <a href="classmodule_1_1extension_1_1Director.html#a867e019bba1e28cf210a89d786452bf5">More...</a><br /></td></tr>
<tr class="separator:a867e019bba1e28cf210a89d786452bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af83cc11c92a845bfcd7810873b731dda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmodule_1_1extension_1_1Director_1_1RunResult.html">RunResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodule_1_1extension_1_1Director.html#af83cc11c92a845bfcd7810873b731dda">run_tasks</a> (<a class="el" href="structmodule_1_1extension_1_1component_1_1ProviderGroup.html">component::ProviderGroup</a> &amp;group, const <a class="el" href="classmodule_1_1extension_1_1Director.html#a7021252f80d525cec056bec1adfa81eb">TaskList</a> &amp;pack, const <a class="el" href="classmodule_1_1extension_1_1Director.html#a058f702f618f27cceb1ade5526ad2c77">RunLevel</a> &amp;run_level, const std::set&lt; std::type_index &gt; &amp;used)</td></tr>
<tr class="memdesc:af83cc11c92a845bfcd7810873b731dda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to execute tasks in the pack, but only up to the passed run level.  <a href="classmodule_1_1extension_1_1Director.html#af83cc11c92a845bfcd7810873b731dda">More...</a><br /></td></tr>
<tr class="separator:af83cc11c92a845bfcd7810873b731dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afedb2bfa4e97b1c4ea03645541bb59f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmodule_1_1extension_1_1Director_1_1Solution.html">Solution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodule_1_1extension_1_1Director.html#afedb2bfa4e97b1c4ea03645541bb59f7">solve_group</a> (const std::type_index &amp;type, const std::shared_ptr&lt; <a class="el" href="structmodule_1_1extension_1_1component_1_1DirectorTask.html">component::DirectorTask</a> &gt; &amp;authority, const std::set&lt; std::type_index &gt; &amp;visited)</td></tr>
<tr class="memdesc:afedb2bfa4e97b1c4ea03645541bb59f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates options for each provider in a provider group specified by the passed type.  <a href="classmodule_1_1extension_1_1Director.html#afedb2bfa4e97b1c4ea03645541bb59f7">More...</a><br /></td></tr>
<tr class="separator:afedb2bfa4e97b1c4ea03645541bb59f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6441c5661adb6df1a67bc76571e2aea0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmodule_1_1extension_1_1Director_1_1Solution_1_1Option.html">Solution::Option</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodule_1_1extension_1_1Director.html#a6441c5661adb6df1a67bc76571e2aea0">solve_provider</a> (const std::shared_ptr&lt; <a class="el" href="structmodule_1_1extension_1_1component_1_1Provider.html">component::Provider</a> &gt; &amp;provider, const std::shared_ptr&lt; <a class="el" href="structmodule_1_1extension_1_1component_1_1DirectorTask.html">component::DirectorTask</a> &gt; &amp;authority, std::set&lt; std::type_index &gt; visited)</td></tr>
<tr class="memdesc:a6441c5661adb6df1a67bc76571e2aea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the passed provider as an option for a solution along with its requirements.  <a href="classmodule_1_1extension_1_1Director.html#a6441c5661adb6df1a67bc76571e2aea0">More...</a><br /></td></tr>
<tr class="separator:a6441c5661adb6df1a67bc76571e2aea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addeec0f3be82e2b190be9af57edfb40d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmodule_1_1extension_1_1Director_1_1Solution.html">Solution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodule_1_1extension_1_1Director.html#addeec0f3be82e2b190be9af57edfb40d">solve_task</a> (const std::shared_ptr&lt; <a class="el" href="structmodule_1_1extension_1_1component_1_1DirectorTask.html">component::DirectorTask</a> &gt; &amp;task)</td></tr>
<tr class="memdesc:addeec0f3be82e2b190be9af57edfb40d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a solution for a given task.  <a href="classmodule_1_1extension_1_1Director.html#addeec0f3be82e2b190be9af57edfb40d">More...</a><br /></td></tr>
<tr class="separator:addeec0f3be82e2b190be9af57edfb40d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a065cf29244da79d96ebd3c94fea7153f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmodule_1_1extension_1_1Director_1_1Solution.html">Solution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodule_1_1extension_1_1Director.html#a065cf29244da79d96ebd3c94fea7153f">solve_when</a> (const <a class="el" href="structmodule_1_1extension_1_1component_1_1Provider_1_1WhenCondition.html">component::Provider::WhenCondition</a> &amp;when, const std::shared_ptr&lt; <a class="el" href="structmodule_1_1extension_1_1component_1_1DirectorTask.html">component::DirectorTask</a> &gt; &amp;authority, const std::set&lt; std::type_index &gt; &amp;visited)</td></tr>
<tr class="memdesc:a065cf29244da79d96ebd3c94fea7153f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the providers that can cause the passed when condition to be met.  <a href="classmodule_1_1extension_1_1Director.html#a065cf29244da79d96ebd3c94fea7153f">More...</a><br /></td></tr>
<tr class="separator:a065cf29244da79d96ebd3c94fea7153f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:aadabed75b770382026823c49eba00812"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodule_1_1extension_1_1Director.html#aadabed75b770382026823c49eba00812">direct_priority</a> (const std::shared_ptr&lt; <a class="el" href="structmodule_1_1extension_1_1component_1_1DirectorTask.html">component::DirectorTask</a> &gt; &amp;incumbent, const std::shared_ptr&lt; <a class="el" href="structmodule_1_1extension_1_1component_1_1DirectorTask.html">component::DirectorTask</a> &gt; &amp;challenger)</td></tr>
<tr class="memdesc:aadabed75b770382026823c49eba00812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the direct priorities of two director tasks and returns true if the challenger has priority over the incumbent.  <a href="classmodule_1_1extension_1_1Director.html#aadabed75b770382026823c49eba00812">More...</a><br /></td></tr>
<tr class="separator:aadabed75b770382026823c49eba00812"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ab2350ea1c07f3e9dd54776dcadf29e4d"><td class="memItemLeft" align="right" valign="top"><a id="ab2350ea1c07f3e9dd54776dcadf29e4d"></a>
std::map&lt; std::type_index, <a class="el" href="structmodule_1_1extension_1_1component_1_1ProviderGroup.html">component::ProviderGroup</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodule_1_1extension_1_1Director.html#ab2350ea1c07f3e9dd54776dcadf29e4d">groups</a></td></tr>
<tr class="memdesc:ab2350ea1c07f3e9dd54776dcadf29e4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of Provider groups. <br /></td></tr>
<tr class="separator:ab2350ea1c07f3e9dd54776dcadf29e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77eb6bb5d67d9956c0cce227bcc38276"><td class="memItemLeft" align="right" valign="top"><a id="a77eb6bb5d67d9956c0cce227bcc38276"></a>
std::map&lt; NUClear::id_t, std::shared_ptr&lt; <a class="el" href="structmodule_1_1extension_1_1component_1_1Provider.html">component::Provider</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodule_1_1extension_1_1Director.html#a77eb6bb5d67d9956c0cce227bcc38276">providers</a></td></tr>
<tr class="memdesc:a77eb6bb5d67d9956c0cce227bcc38276"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps reaction_id to the Provider which implements it. <br /></td></tr>
<tr class="separator:a77eb6bb5d67d9956c0cce227bcc38276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ef90d64bf20ee88eec5c956790d55b"><td class="memItemLeft" align="right" valign="top"><a id="af5ef90d64bf20ee88eec5c956790d55b"></a>
NUClear::id_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodule_1_1extension_1_1Director.html#af5ef90d64bf20ee88eec5c956790d55b">unique_id_source</a> = 0</td></tr>
<tr class="memdesc:af5ef90d64bf20ee88eec5c956790d55b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A source for unique reaction ids when making root task providers. Starts at 0 and wraps around to maxvalue. <br /></td></tr>
<tr class="separator:af5ef90d64bf20ee88eec5c956790d55b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a058f702f618f27cceb1ade5526ad2c77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a058f702f618f27cceb1ade5526ad2c77">&#9670;&nbsp;</a></span>RunLevel</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classmodule_1_1extension_1_1Director.html#a058f702f618f27cceb1ade5526ad2c77">module::extension::Director::RunLevel</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The level of solution that we can run at. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a058f702f618f27cceb1ade5526ad2c77afae7fc26dfef15f5c935685710e572d9"></a>OK&#160;</td><td class="fielddoc"><p>We can run all our tasks on providers now. </p>
</td></tr>
<tr><td class="fieldname"><a id="a058f702f618f27cceb1ade5526ad2c77a84f6f1116ae35c9f652a614104bb91eb"></a>PUSH&#160;</td><td class="fielddoc"><p>We can't run all our tasks on providers now, but we can push to fix our requirements. </p>
</td></tr>
<tr><td class="fieldname"><a id="a058f702f618f27cceb1ade5526ad2c77a0ff28619a17818aeff9f773b91b554ca"></a>BLOCKED&#160;</td><td class="fielddoc"><p>We can't run all our tasks on providers now, and we can't push to fix our requirements. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae38a0f87a58faec7521d61eb4faaae7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae38a0f87a58faec7521d61eb4faaae7a">&#9670;&nbsp;</a></span>add_causing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void module::extension::Director::add_causing </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="structextension_1_1behaviour_1_1commands_1_1CausingExpression.html">extension::behaviour::commands::CausingExpression</a> &amp;&#160;</td>
          <td class="paramname"><em>causing</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a causing condition to an existing Provider. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">causing</td><td>the description of the Causing expression from the behaviour extension </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa959f154ca485d8bb435b898ecb3223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa959f154ca485d8bb435b898ecb3223">&#9670;&nbsp;</a></span>add_needs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void module::extension::Director::add_needs </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="structextension_1_1behaviour_1_1commands_1_1NeedsExpression.html">extension::behaviour::commands::NeedsExpression</a> &amp;&#160;</td>
          <td class="paramname"><em>needs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a needs to an existing Provider. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needs</td><td>the description of the Needs expression from the behaviour extension </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a194487bb54ff0df9fb6dfd687b8f80f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a194487bb54ff0df9fb6dfd687b8f80f6">&#9670;&nbsp;</a></span>add_provider()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void module::extension::Director::add_provider </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="structextension_1_1behaviour_1_1commands_1_1ProvideReaction.html">extension::behaviour::commands::ProvideReaction</a> &amp;&#160;</td>
          <td class="paramname"><em>provide</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a Provider for a type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the ProvideReaction object that was generated by the Behaviour extension</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>when there is more than one Provide in an on statement </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f5fe71a8de8e8282b0a2774e6249e43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f5fe71a8de8e8282b0a2774e6249e43">&#9670;&nbsp;</a></span>add_when()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void module::extension::Director::add_when </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="structextension_1_1behaviour_1_1commands_1_1WhenExpression.html">extension::behaviour::commands::WhenExpression</a> &amp;&#160;</td>
          <td class="paramname"><em>when</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a when condition to an existing Provider. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">when</td><td>the description of the When expression from the Behaviour extension </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e12b0846a7c148a6dea84299670b45c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e12b0846a7c148a6dea84299670b45c">&#9670;&nbsp;</a></span>challenge_priority()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool module::extension::Director::challenge_priority </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="structmodule_1_1extension_1_1component_1_1DirectorTask.html">component::DirectorTask</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>incumbent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="structmodule_1_1extension_1_1component_1_1DirectorTask.html">component::DirectorTask</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>challenger</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the challenge priorities of two director tasks and returns true if the challenger has priority over the incumbent using challenge priority. </p>
<p>i.e. incumbent &lt; challenger</p>
<p>The function requires that the challenger's precedence is strictly greater than the incumbent's. This ensures that we don't change tasks unnecessarily when the priority is equal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">incumbent</td><td>the task to compare which is currently the active running task </td></tr>
    <tr><td class="paramname">challenger</td><td>the task to compare which wants to run but is not currently running</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the challenger has strictly higher priority than the incumbent </dd>
<dd>
false if the incumbent task has equal or higher priority</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the director's provider ancestry is broken </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aadabed75b770382026823c49eba00812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadabed75b770382026823c49eba00812">&#9670;&nbsp;</a></span>direct_priority()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool module::extension::Director::direct_priority </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="structmodule_1_1extension_1_1component_1_1DirectorTask.html">component::DirectorTask</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>incumbent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="structmodule_1_1extension_1_1component_1_1DirectorTask.html">component::DirectorTask</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>challenger</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the direct priorities of two director tasks and returns true if the challenger has priority over the incumbent. </p>
<p>i.e. incumbent &lt; challenger</p>
<p>The function requires that the challenger's precedence is strictly greater than the incumbent's. This ensures that we don't change tasks unnecessarily when the priority is equal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">incumbent</td><td>the task to compare which is currently the active running task </td></tr>
    <tr><td class="paramname">challenger</td><td>the task to compare which wants to run but is not currently running</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the challenger has strictly higher priority than the incumbent </dd>
<dd>
false if the incumbent task has equal or higher priority</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the director's provider ancestry is broken </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a53c31913830e62fdc1b7c49c9a259191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53c31913830e62fdc1b7c49c9a259191">&#9670;&nbsp;</a></span>find_ok_solution() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmodule_1_1extension_1_1Director_1_1OkSolution.html">Director::OkSolution</a> module::extension::Director::find_ok_solution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmodule_1_1extension_1_1Director_1_1Solution.html">Solution</a> &amp;&#160;</td>
          <td class="paramname"><em>requirement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; std::type_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>used_types</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first available option for a solution that we can run now for this solution. </p>
<p>Or if there is no option that can be run now, it will return that it is blocked and which groups we wanted to run but wasn't able to.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">requirement</td><td>the requirement that we are searching for options we can execute </td></tr>
    <tr><td class="paramname">used_types</td><td>types that have already been used higher in the solution tree that are blocked to us</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An OKSolution instance that represents a solution we can run now or a blocked solution </dd></dl>

</div>
</div>
<a id="a90923156eb8865e70b76295c7f2925ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90923156eb8865e70b76295c7f2925ac">&#9670;&nbsp;</a></span>find_ok_solution() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmodule_1_1extension_1_1Director_1_1OkSolution.html">Director::OkSolution</a> module::extension::Director::find_ok_solution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmodule_1_1extension_1_1Director_1_1Solution_1_1Option.html">Solution::Option</a> &amp;&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; std::type_index &gt;&#160;</td>
          <td class="paramname"><em>used_types</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Joins all of the requirements of an option into a single <a class="el" href="structmodule_1_1extension_1_1Director_1_1OkSolution.html" title="Represents a solution that we can run now, i.e.">OkSolution</a> instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">option</td><td>the option we are joining the requirements of </td></tr>
    <tr><td class="paramname">used_types</td><td>the set of provider groups that have been used in this solution</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="structmodule_1_1extension_1_1Director_1_1OkSolution.html" title="Represents a solution that we can run now, i.e.">OkSolution</a> that represents the requirements of the passed option fused together </dd></dl>

</div>
</div>
<a id="a064eb8cb122b43693170af234a60756b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a064eb8cb122b43693170af234a60756b">&#9670;&nbsp;</a></span>find_ok_solutions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structmodule_1_1extension_1_1Director_1_1OkSolution.html">Director::OkSolution</a> &gt; module::extension::Director::find_ok_solutions </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structmodule_1_1extension_1_1Director_1_1Solution.html">Solution</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>solutions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; std::type_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>used_types</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solves each of a series of Solutions and returns a list of OkSolutions that represents the first solution that can execute, or a blocked solution if none of the solutions can execute. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">solutions</td><td>the set of solutions that we are trying to find an <a class="el" href="structmodule_1_1extension_1_1Director_1_1OkSolution.html" title="Represents a solution that we can run now, i.e.">OkSolution</a> for </td></tr>
    <tr><td class="paramname">used_types</td><td>types that have already been used higher in the solution tree that are blocked to us</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of OkSolutions that represents the first solution that can execute, or a blocked solution if none of the solutions can execute. </dd></dl>

</div>
</div>
<a id="a553b675b4947fe028b198285a393d778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a553b675b4947fe028b198285a393d778">&#9670;&nbsp;</a></span>get_root_provider()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="structmodule_1_1extension_1_1component_1_1Provider.html">component::Provider</a> &gt; module::extension::Director::get_root_provider </td>
          <td>(</td>
          <td class="paramtype">const std::type_index &amp;&#160;</td>
          <td class="paramname"><em>root_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds or creates a root provider for a task and returns it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_type</td><td>the root task type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the root provider </dd></dl>
<p>Can leave the data_setter as nullptr as nobody should ever issue tasks to a root provider</p>

</div>
</div>
<a id="aa2525565f36ac81678c9987d70bfa35e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2525565f36ac81678c9987d70bfa35e">&#9670;&nbsp;</a></span>reevaluate_children()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void module::extension::Director::reevaluate_children </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmodule_1_1extension_1_1component_1_1ProviderGroup.html">component::ProviderGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>group</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Runs a reevaluation on not only the passed group, but any groups that it is using. </p>
<p>It will run reevaluate_group on the passed group, and then if nothing changes in the group it will look at each of the subtasks. If a subtask is currently the active task in another group it will recursively call on that group. This will terminate once there are no more subtasks that are active in other groups or when calling reevaluate_group results in a change of the currently running task.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>the group whose queue we want to reevaluate along with all children </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a98348af06fa8b1126bc28e2d21695668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98348af06fa8b1126bc28e2d21695668">&#9670;&nbsp;</a></span>reevaluate_group()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool module::extension::Director::reevaluate_group </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmodule_1_1extension_1_1component_1_1ProviderGroup.html">component::ProviderGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>group</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reevaluates all of the tasks that are queued to execute on a provider group. </p>
<p>Each of the tasks in the queue are waiting to use this provider group but cannot for some reason or another. In order to determine if they can now run on the queue we need to look at each queued task and inspect if the provider that created them can now run. We do this by simply trying to run them all again.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>the group whose queue we want to reevaluate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if as a result of reevaluating we changed tasks </dd></dl>

</div>
</div>
<a id="ab5cb1189cc1ccd5680fdc36dcbf47178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5cb1189cc1ccd5680fdc36dcbf47178">&#9670;&nbsp;</a></span>remove_provider()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void module::extension::Director::remove_provider </td>
          <td>(</td>
          <td class="paramtype">const NUClear::id_t &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a Provider for a type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>the id of the reaction we want to remove the Provider for</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>when the reaction does not provide anything </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a310d77d2ee390e96e2e35db3d3a45a73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a310d77d2ee390e96e2e35db3d3a45a73">&#9670;&nbsp;</a></span>remove_task()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void module::extension::Director::remove_task </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="structmodule_1_1extension_1_1component_1_1DirectorTask.html">component::DirectorTask</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the provided task from the <a class="el" href="classmodule_1_1extension_1_1Director.html">Director</a>. </p>
<p>This function also deals with all the consequences of removing the task including looking to see if a queued task can now be run.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>the task to remove from the <a class="el" href="classmodule_1_1extension_1_1Director.html">Director</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afaa3e4a164097d1ca11e840072c261f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaa3e4a164097d1ca11e840072c261f9">&#9670;&nbsp;</a></span>run_task_on_provider()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void module::extension::Director::run_task_on_provider </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="structmodule_1_1extension_1_1component_1_1DirectorTask.html">component::DirectorTask</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="structmodule_1_1extension_1_1component_1_1Provider.html">component::Provider</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>provider</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::extension::behaviour::RunReason &amp;&#160;</td>
          <td class="paramname"><em>run_reason</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Runs the passed task on the passed provider. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>the task we are running </td></tr>
    <tr><td class="paramname">provider</td><td>the provider that we are running the task on </td></tr>
    <tr><td class="paramname">run_reason</td><td>the reason that we are running this task </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a867e019bba1e28cf210a89d786452bf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a867e019bba1e28cf210a89d786452bf5">&#9670;&nbsp;</a></span>run_task_pack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void module::extension::Director::run_task_pack </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmodule_1_1extension_1_1Director_1_1TaskPack.html">TaskPack</a> &amp;&#160;</td>
          <td class="paramname"><em>pack</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Looks at all the tasks that are in the pack and determines if they should run, and if so runs them. </p>
<p>This function will ensure that if this pack is to be executed it can be executed as a whole. That means that all of the non optional tasks in it are able to run now given the state of the system. If the system is unable to run due to priority or due to a when condition not met it will not run any of the tasks in this pack, but enqueue them on the relevant providers.</p>
<p>In the event that <code>When</code> conditions needs to be met by this pack and it has sufficient priority, it may also place this provider group into a "Pushing" state whereby it forces another provider group into a state where it will make the system reach the causing it requires.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pack</td><td>the task pack that represents the queued tasks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af83cc11c92a845bfcd7810873b731dda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af83cc11c92a845bfcd7810873b731dda">&#9670;&nbsp;</a></span>run_tasks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmodule_1_1extension_1_1Director_1_1RunResult.html">Director::RunResult</a> module::extension::Director::run_tasks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmodule_1_1extension_1_1component_1_1ProviderGroup.html">component::ProviderGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmodule_1_1extension_1_1Director.html#a7021252f80d525cec056bec1adfa81eb">TaskList</a> &amp;&#160;</td>
          <td class="paramname"><em>pack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmodule_1_1extension_1_1Director.html#a058f702f618f27cceb1ade5526ad2c77">RunLevel</a> &amp;&#160;</td>
          <td class="paramname"><em>run_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; std::type_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>used</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to execute tasks in the pack, but only up to the passed run level. </p>
<p>The passed run level will limit what types of execution are open to us. For example, if the required pack was only able to execute up to the PUSH level, then we will only execute up to the PUSH level for the optional packs that come afterward.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>the provider group that created this pack </td></tr>
    <tr><td class="paramname">pack</td><td>the pack of tasks that we are trying to execute </td></tr>
    <tr><td class="paramname">run_level</td><td>the level of execution that we are allowed to do </td></tr>
    <tr><td class="paramname">used</td><td>the set of provider groups that are already used that we can't use again</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the run level that we were able to execute up to and the set of provider groups that we used </dd></dl>

</div>
</div>
<a id="afedb2bfa4e97b1c4ea03645541bb59f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afedb2bfa4e97b1c4ea03645541bb59f7">&#9670;&nbsp;</a></span>solve_group()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmodule_1_1extension_1_1Director_1_1Solution.html">Director::Solution</a> module::extension::Director::solve_group </td>
          <td>(</td>
          <td class="paramtype">const std::type_index &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="structmodule_1_1extension_1_1component_1_1DirectorTask.html">component::DirectorTask</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>authority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; std::type_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>visited</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates options for each provider in a provider group specified by the passed type. </p>
<p>This function will check each provider in the group and make an option for it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>the type of task we are trying to run </td></tr>
    <tr><td class="paramname">authority</td><td>the task that we are using as our authority token for permission checks </td></tr>
    <tr><td class="paramname">visited</td><td>the set of provider groups that have already been visited to prevent loops</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the set of possible solution options for the provider group of the passed type </dd></dl>

</div>
</div>
<a id="a6441c5661adb6df1a67bc76571e2aea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6441c5661adb6df1a67bc76571e2aea0">&#9670;&nbsp;</a></span>solve_provider()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmodule_1_1extension_1_1Director_1_1Solution_1_1Option.html">Director::Solution::Option</a> module::extension::Director::solve_provider </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="structmodule_1_1extension_1_1component_1_1Provider.html">component::Provider</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>provider</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="structmodule_1_1extension_1_1component_1_1DirectorTask.html">component::DirectorTask</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>authority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; std::type_index &gt;&#160;</td>
          <td class="paramname"><em>visited</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the passed provider as an option for a solution along with its requirements. </p>
<p>It will recursively find Solutions for each of the requirements of the provider including its unmet when conditions and needs relationships.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">provider</td><td>the provider that we are trying to find a solution for </td></tr>
    <tr><td class="paramname">authority</td><td>the task that we are using as our authority token for permission checks </td></tr>
    <tr><td class="paramname">visited</td><td>the set of provider groups that have already been visited to prevent loops</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="addeec0f3be82e2b190be9af57edfb40d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addeec0f3be82e2b190be9af57edfb40d">&#9670;&nbsp;</a></span>solve_task()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmodule_1_1extension_1_1Director_1_1Solution.html">Director::Solution</a> module::extension::Director::solve_task </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="structmodule_1_1extension_1_1component_1_1DirectorTask.html">component::DirectorTask</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds a solution for a given task. </p>
<p>It will start with the provider group for the given task and recursively work its way down to find all possible solutions. It will use the passed task as an authority token for the permission checks on providers that it needs to run.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>the task we are finding solutions for, also used for authority checks</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the set of possible solution options for this task </dd></dl>

</div>
</div>
<a id="a065cf29244da79d96ebd3c94fea7153f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a065cf29244da79d96ebd3c94fea7153f">&#9670;&nbsp;</a></span>solve_when()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmodule_1_1extension_1_1Director_1_1Solution.html">Director::Solution</a> module::extension::Director::solve_when </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmodule_1_1extension_1_1component_1_1Provider_1_1WhenCondition.html">component::Provider::WhenCondition</a> &amp;&#160;</td>
          <td class="paramname"><em>when</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="structmodule_1_1extension_1_1component_1_1DirectorTask.html">component::DirectorTask</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>authority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; std::type_index &gt; &amp;&#160;</td>
          <td class="paramname"><em>visited</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the providers that can cause the passed when condition to be met. </p>
<p>It will then recursively find Solutions for each of the requirements of the provider potentially including more when conditions that need to be met. The final solution for a task could end up with several steps removed from the original task.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">when</td><td>the when condition we want to meet by finding causings that will allow a provider to run </td></tr>
    <tr><td class="paramname">authority</td><td>the task that we are using as our authority token for permission checks </td></tr>
    <tr><td class="paramname">visited</td><td>the set of provider groups that have already been visited to prevent loops</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the set of providers that when run can meet the provided when condition </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>module/extension/Director/src/<a class="el" href="Director_8hpp_source.html">Director.hpp</a></li>
<li>module/extension/Director/src/director/challenge_priority.cpp</li>
<li>module/extension/Director/src/director/direct_priority.cpp</li>
<li>module/extension/Director/src/director/find_ok_solution.cpp</li>
<li>module/extension/Director/src/director/reevaluate_group.cpp</li>
<li>module/extension/Director/src/director/remove_task.cpp</li>
<li>module/extension/Director/src/director/run_task_on_provider.cpp</li>
<li>module/extension/Director/src/director/run_task_pack.cpp</li>
<li>module/extension/Director/src/director/solve.cpp</li>
<li>module/extension/Director/src/Director.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>module</b></li><li class="navelem"><b>extension</b></li><li class="navelem"><a class="el" href="classmodule_1_1extension_1_1Director.html">Director</a></li>
    <li class="footer">Generated on Fri Mar 14 2025 02:40:45 for NUbots by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
