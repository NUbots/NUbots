# Continuous Integration tests
name: NUbots CI

# Controls when the action will run.
on:
  # Triggers the workflow on push or pull request events but only for the master branch
  push:
    branches: [master]
  pull_request:
    branches: [master]

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # Build the docker image
  build_docker:
    name: "Build docker image"

    # The type of runner that the job will run on
    runs-on: ubuntu-20.04

    # We output the image tag that we create so the other jobs can use it
    outputs:
      image: ${{ steps.image_output.outputs.image }}

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - name: Checkout Code
        uses: actions/checkout@v2

      # Setup docker buildx
      - name: üê≥ Set up docker buildx üê≥
        uses: docker/setup-buildx-action@v1

      - name: Login to DockerHub
        uses: docker/login-action@v1
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}

      # Build the docker image
      - name: üê≥ Build the docker image üê≥
        uses: docker/build-push-action@v2
        with:
          pull: true
          tags: "nubots/nubots:${{ hashFiles('docker/**') }}"
          file: docker/Dockerfile
          context: docker
          build-args: |
            platform=generic
          push: true
          cache-from: type=registry,ref=nubots/nubots:generic
          cache-to: type=inline

      - id: image_output
        name: Output the created image
        run: echo "::set-output name=image::nubots/nubots:${{ hashFiles('docker/**') }}"

  # Build the codebase as well as run clang-tidy
  build_nubots:
    name: "Build and test NUbots"

    # The type of runner that the job will run on
    runs-on: ubuntu-20.04
    needs: build_docker

    # Run on the container we just built
    container:
      image: "${{ needs.build_docker.outputs.image }}"
      options: --user 0:0

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - name: Checkout Code
        uses: actions/checkout@v2
        with:
          submodules: true

      - name: Configure the code
        run: |
          mkdir -p build
          cd build
          cmake .. -GNinja \
                   -DCMAKE_BUILD_TYPE=Release \
                   -DCMAKE_TOOLCHAIN_FILE=/usr/local/toolchain.cmake \
                   -DCI_BUILD=ON \
                   -DENABLE_CLANG_TIDY=ON \
                   -DBUILD_TESTS=ON

      - name: Build the code
        run: |
          cd build
          ninja

      - name: Test the code
        run: |
          cd build
          ninja test

  # Check the code is formatted according to clang-format
  clang-format:
    name: "C++/Protobuf Formatting"
    # The type of runner that the job will run on
    runs-on: ubuntu-20.04
    needs: build_docker

    # Run on the container we just built
    container:
      image: "${{ needs.build_docker.outputs.image }}"
      options: --user 0:0

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - name: Checkout Code
        uses: actions/checkout@v2
        with:
          submodules: true

      - name: Check clang-format
        run: .github/workflows/format/validate_clang_format.sh

  # Validate the formatting is correct according to cmake-format
  cmake-format:
    name: "CMake Formatting"
    # The type of runner that the job will run on
    runs-on: ubuntu-20.04
    needs: build_docker

    # Run on the container we just built
    container:
      image: "${{ needs.build_docker.outputs.image }}"
      options: --user 0:0

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - name: Checkout Code
        uses: actions/checkout@v2
        with:
          submodules: true

      - name: Check cmake-format
        run: .github/workflows/format/validate_cmake_format.sh

  # Validate the formatting is correct according to isort and black
  python-format:
    name: "Python Formatting"
    # The type of runner that the job will run on
    runs-on: ubuntu-20.04
    needs: build_docker

    # Run on the container we just built
    container:
      image: "${{ needs.build_docker.outputs.image }}"

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - name: Checkout Code
        uses: actions/checkout@v2
        with:
          submodules: true

      - name: Check isort and black
        run: .github/workflows/format/validate_python_format.sh
